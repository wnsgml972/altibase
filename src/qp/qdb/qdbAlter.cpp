/** 
 *  Copyright (c) 1999~2017, Altibase Corp. and/or its affiliates. All rights reserved.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License, version 3,
 *  as published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
 

/***********************************************************************
 * $Id: qdbAlter.cpp 82209 2018-02-07 07:33:37Z returns $
 **********************************************************************/

#include <idl.h>
#include <ide.h>
#include <smiTableSpace.h>
#include <qdbCommon.h>
#include <qdbAlter.h>
#include <qdn.h>
#include <qmv.h>
#include <qtc.h>
#include <qcm.h>
#include <qcg.h>
#include <qmc.h>
#include <qcmCache.h>
#include <qcmUser.h>
#include <qcmTableSpace.h>
#include <qmvQuerySet.h>
#include <qmo.h>
#include <qmn.h>
#include <qcmTableInfo.h>
#include <qcmView.h>
#include <qcuTemporaryObj.h>
#include <qcuSqlSourceInfo.h>
#include <qdx.h>
#include <qdd.h>
#include <qmx.h>
#include <qcmProc.h>
#include <qdpPrivilege.h>
#include <qdnTrigger.h>
#include <qdtCommon.h>
#include <qmoPartition.h> // PROJ-1502 PARTITIONED DISK TABLE
#include <qdbComment.h>
#include <qcsModule.h>
#include <qdnCheck.h>
#include <qmsDefaultExpr.h>
#include <qcmAudit.h>
#include <qcmDictionary.h>
#include <qcmPkg.h>
#include <qcc.h>
#include <qdpRole.h>

IDE_RC qdbAlter::validateAddCol(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... ADD COLUMN ... 의 validation 수행
 *
 * Implementation :
 *    1. 테이블 존재 여부 체크
 *    2. 테이블의 소유자가 SYSTEM_ 이면 alter 불가능
 *    3. alter table 권한이 있는지 체크
 *    4. 테이블에 Replication이 걸려있으면, Recovery 여부를 확인
 *    5. 나열된 컬럼의 validation 검사 수행
 *       => qdbCommon::validateColumnList 호출
 *    6. 추가되는 constraint 에 대한 validation 수행
 *       => qdn::validateConstraints 호출
 *       => Check Constraint 미지원
 *    7. close 된 테이블이 아닌지 체크
 *    8. UNIQUE KEY, PRIMARY KEY 를 명시한 경우 이들 인덱스의
 *       테이블스페이스를 위해 사용자의 DEFAULT TABLESPACE ID 값을
 *       메타에 읽어와서 파스트리에 저장
 *    9. 테이블에 Replication이 걸려있으면,
 *       FOREIGN KEY, UNIQUE KEY, NOT NULL, Check Constraint Column을 추가할 수 없음을 확인
 *    10. 실시간 Add Column 가능 여부 검사
 *
 ***********************************************************************/

    qdTableParseTree     * sParseTree;
    SInt                   sColumnCount;
    UInt                   sUniqueKeyCnt;
    qcuSqlSourceInfo       sqlInfo;
    smiTableSpaceAttr      TBSAttr;
    qdPartitionAttribute * sPartAttr;

    SInt                   sNewColCnt;
    qcmColumn            * sNewColumns;
    qcmColumn            * sColumn = NULL;
    qcmColumn            * sLobColumn = NULL;
    qcmPartitionInfoList * sPartInfoList;
    qdPartitionAttribute * sNewPartAttr = NULL;
    qcmTableInfo         * sPartInfo;
    UInt                   sPartCnt = 0;
    UInt                   i;
    idBool                 sIsFound = ID_FALSE;
    qdLobAttribute       * sLobAttr;
    qcmTableInfo         * sTempPartInfo;
    smSCN                  sSCN;
    void                 * sHandle;

    qdConstraintSpec     * sCurrConstr = NULL;
    qcmCompressionColumn * sCompColumn = NULL;
    qcmCompressionColumn * sCompPrev = NULL;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // ALTER TABLE 구문의 공통적인 validation 수행
    // => 테이블에 LOCK(IS)
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_FALSE )
              != IDE_SUCCESS );

#if defined(DEBUG)
    // BUG-38501
    // PROJ-2264 Dictionary table
    if ( QCU_FORCE_COMPRESSION_COLUMN == 1 )
    {
        // 다음을 모두 만족하는 경우에 강제로 compression column 으로 만든다.
        // 1. Debug 모드로 빌드 되었을 때
        // 2. Partition table 이 아닐 때
        // 3. Dictionary table 이 아닐 때
        // 4. Compress 절이 없을 때
        // 5. Data memory/disk table 일 때
        // 6. Compression column 이 지원되는 데이터 타입일 때

        if (smiTableSpace::isDataTableSpaceType( sParseTree->TBSAttr.mType ) == ID_TRUE )
        {
            if ((smiTableSpace::isMemTableSpaceType(sParseTree->TBSAttr.mType) != ID_TRUE) &&
                (smiTableSpace::isDiskTableSpaceType(sParseTree->TBSAttr.mType) != ID_TRUE))
            {
                /* do not compress */
                IDE_CONT(LABEL_PASS);
            }
            else
            {
                /* nothing to do */
            }
        }
        else
        {
            /* do not compress */
            IDE_CONT(LABEL_PASS);
        }

        if ( ( sParseTree->tableInfo->tablePartitionType != QCM_PARTITIONED_TABLE ) &&
             ( ( sParseTree->tableAttrValue & SMI_TABLE_DICTIONARY_MASK ) ==
               SMI_TABLE_DICTIONARY_FALSE ) &&
             ( sParseTree->compressionColumn == NULL ))
        {
            for( sColumn = sParseTree->columns; sColumn != NULL; sColumn = sColumn->next )
            {
                switch( sColumn->basicInfo->type.dataTypeId )
                {
                    case MTD_CHAR_ID :
                    case MTD_VARCHAR_ID :
                    case MTD_NCHAR_ID :
                    case MTD_NVARCHAR_ID :
                    case MTD_BYTE_ID :
                    case MTD_VARBYTE_ID :
                    case MTD_NIBBLE_ID :
                    case MTD_BIT_ID :
                    case MTD_VARBIT_ID :
                    case MTD_DATE_ID :
                        // Column 의 저장크기(size)가 smOID 보다 작으면 skip
                        // 우선 compression 하면 오히려 저장 공간을 더 사용하게되고
                        // in-place update 시에 logging 문제도 발생하게 된다.
                        if( sColumn->basicInfo->column.size < ID_SIZEOF(smOID) )
                        {
                            sColumn->basicInfo->column.flag &= ~SMI_COLUMN_COMPRESSION_MASK;
                            sColumn->basicInfo->column.flag |= SMI_COLUMN_COMPRESSION_FALSE;
                        }
                        else
                        {
                            // BUG-38670
                            // Hidden column 은 compress 대상에서 제외한다.
                            // (Function based index)
                            if ( (sColumn->flag & QCM_COLUMN_HIDDEN_COLUMN_MASK)
                                 == QCM_COLUMN_HIDDEN_COLUMN_TRUE )
                            {
                                sColumn->basicInfo->column.flag &= ~SMI_COLUMN_COMPRESSION_MASK;
                                sColumn->basicInfo->column.flag |= SMI_COLUMN_COMPRESSION_FALSE;
                            }
                            else
                            {
                                // Compression column 임을 나타내도록 flag 세팅
                                sColumn->basicInfo->column.flag &= ~SMI_COLUMN_COMPRESSION_MASK;
                                sColumn->basicInfo->column.flag |= SMI_COLUMN_COMPRESSION_TRUE;

                                IDE_TEST( QC_QMP_MEM(aStatement)->alloc( ID_SIZEOF(qcmCompressionColumn),
                                                                         (void**)&sCompColumn )
                                          != IDE_SUCCESS );
                                QCM_COMPRESSION_COLUMN_INIT( sCompColumn );
                                SET_POSITION(sCompColumn->namePos, sColumn->namePos);

                                if( sCompPrev == NULL )
                                {
                                    sParseTree->compressionColumn = sCompColumn;
                                    sCompPrev                     = sCompColumn;
                                }
                                else
                                {
                                    sCompPrev->next               = sCompColumn;
                                    sCompPrev                     = sCompPrev->next;
                                }
                            }
                        }
                        break;
                    default :
                        sColumn->basicInfo->column.flag &= ~SMI_COLUMN_COMPRESSION_MASK;
                        sColumn->basicInfo->column.flag |= SMI_COLUMN_COMPRESSION_FALSE;
                        break;
                }
            }
        }
    }

    IDE_EXCEPTION_CONT(LABEL_PASS);
#endif

    if(sParseTree->tableInfo->replicationCount > 0)
    {
        /* PROJ-1442 Replication Online 중 DDL 허용
         * Recovery 기능과 같이 사용할 수 없음
         */
        IDE_TEST_RAISE(sParseTree->tableInfo->replicationRecoveryCount > 0,
                       ERR_CANNOT_DDL_WITH_RECOVERY);

        if ( sParseTree->compressionColumn != NULL )
        {
            IDE_RAISE( ERR_COMPRESSION_COL_WITH_REPL );
        }
        else
        {
            /* Nothing to do */
        }
    }
    else
    {
        // Nothing to do.
    }

    // PROJ-2264 Dictionary table
    IDE_TEST( qcmDictionary::validateCompressColumn( aStatement,
                                                     sParseTree,
                                                     sParseTree->tableInfo->TBSType )
              != IDE_SUCCESS );

    // validation of columns specification
    sColumnCount = sParseTree->tableInfo->columnCount;
    IDE_TEST( qdbCommon::validateColumnListForAddCol( aStatement,
                                                      sParseTree->tableInfo,
                                                      sParseTree->columns,
                                                      sColumnCount )
              != IDE_SUCCESS );

    for ( sNewColumns = sParseTree->columns, sNewColCnt = 0;
          sNewColumns != NULL;
          sNewColumns = sNewColumns->next, sNewColCnt++ )
    {
        // Nothing to do.
    }

    idlOS::memset( &TBSAttr, 0, ID_SIZEOF( smiTableSpaceAttr ) );

    // PROJ-1362
    // validation of lob column attributes
    TBSAttr.mID = sParseTree->tableInfo->TBSID;
    TBSAttr.mType = sParseTree->tableInfo->TBSType;

    // PROJ-1502 PARTITIONED DISK TABLE
    if( sParseTree->tableInfo->tablePartitionType
        == QCM_NONE_PARTITIONED_TABLE )
    {
        IDE_TEST_RAISE( sParseTree->partTable->partAttr != NULL,
                        ERR_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE );
    }
    else
    {
        // nothing to do
    }

    IDE_TEST(qdbCommon::validateLobAttributeList(
                 aStatement,
                 sParseTree->tableInfo,
                 sParseTree->columns,
                 &TBSAttr,
                 sParseTree->lobAttr )
             != IDE_SUCCESS);

    // PROJ-1502 PARTITIONED DISK TABLE
    if( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        // ADD COLUMN 구문은 파싱단계에서
        // sParseTree->partTable의 메모리 할당이 되어 있다.

        // 모든 파티션에 LOCK(IS)
        // 파티션 리스트를 파스트리에 달아놓는다.
        IDE_TEST( qdbCommon::checkAndSetAllPartitionInfo(
                      aStatement,
                      sParseTree->tableInfo->tableID,
                      & (sParseTree->partTable->partInfoList) )
                  != IDE_SUCCESS );

        // PROJ-1624 non-partitioned index
        IDE_TEST( qdx::makeAndLockIndexTableList(
                      aStatement,
                      ID_FALSE,
                      sParseTree->tableInfo,
                      &(sParseTree->oldIndexTables) )
                  != IDE_SUCCESS );
        
        sPartInfoList = sParseTree->partTable->partInfoList;

        for( sPartCnt = 0;
             sPartInfoList != NULL;
             sPartInfoList = sPartInfoList->next, sPartCnt++ )
        {
            // Nothing to do.
        }

        IDU_LIMITPOINT("qdbAlter::validateAddCol::malloc");
        IDE_TEST(QC_QMP_MEM(aStatement)->cralloc(
                     ID_SIZEOF(qdPartitionAttribute) * sPartCnt,
                     (void**)& sNewPartAttr )
                 != IDE_SUCCESS);

        for( i = 0, sPartInfoList = sParseTree->partTable->partInfoList;
             sPartInfoList != NULL;
             i++, sPartInfoList = sPartInfoList->next )
        {
            // 지정한 파티션 개수만큼 반복하며 TBS 세팅
            sPartInfo = sPartInfoList->partitionInfo;

            for( sPartAttr = sParseTree->partTable->partAttr;
                 sPartAttr != NULL;
                 sPartAttr = sPartAttr->next )
            {
                if( qcmPartition::getPartitionInfo( aStatement,
                                                    sParseTree->tableInfo->tableID,
                                                    sPartAttr->tablePartName,
                                                    & sTempPartInfo,
                                                    & sSCN,
                                                    & sHandle )
                    != IDE_SUCCESS )
                {
                    sqlInfo.setSourceInfo(aStatement,
                                          & sPartAttr->tablePartName);
                    IDE_RAISE( ERR_NOT_EXIST_TABLE_PARTITION );
                }

                if ( idlOS::strMatch( sPartAttr->tablePartName.stmtText + sPartAttr->tablePartName.offset,
                                      sPartAttr->tablePartName.size,
                                      sPartInfo->name,
                                      idlOS::strlen( sPartInfo->name ) ) == 0 )
                {
                    break;
                }
            }

            /* PROJ-2464 hybrid partitioned table 지원 */
            IDE_TEST( qdbCommon::copyAndAdjustColumnList( aStatement,
                                                          TBSAttr.mType,
                                                          sPartInfo->TBSType,
                                                          sParseTree->columns,
                                                          &(sNewPartAttr[i].columns),
                                                          sNewColCnt,
                                                          ID_FALSE /* aEnableVariableColumn */ )
                      != IDE_SUCCESS );

            for( sColumn = sNewPartAttr[i].columns;
                 sColumn != NULL;
                 sColumn = sColumn->next )
            {
                if ((sColumn->basicInfo->module->flag & MTD_COLUMN_TYPE_MASK)
                    == MTD_COLUMN_TYPE_LOB)
                {
                    sIsFound = ID_FALSE;

                    for( sLobAttr = sParseTree->lobAttr;
                         sLobAttr != NULL;
                         sLobAttr = sLobAttr->next )
                    {
                        for( sLobColumn = sLobAttr->columns;
                             sLobColumn != NULL;
                             sLobColumn = sLobColumn->next )
                        {
                            if ( QC_IS_NAME_MATCHED( sLobColumn->namePos, sColumn->namePos ) )
                            {
                                sIsFound = ID_TRUE;
                                break;
                            }
                        }

                        if( sLobAttr->columns == NULL )
                        {
                            sIsFound = ID_TRUE;
                        }

                        if( sIsFound == ID_TRUE )
                        {
                            break;
                        }
                    }

                    if( sIsFound != ID_TRUE )
                    {
                        sColumn->basicInfo->column.colSpace = sPartInfo->TBSID;
                    }
                }
                else
                {
                    sColumn->basicInfo->column.colSpace = sPartInfo->TBSID;
                }
            }

            if( sPartAttr != NULL )
            {
                sNewPartAttr[i].lobAttr = sPartAttr->lobAttr;

                TBSAttr.mID = sPartInfo->TBSID;
                TBSAttr.mType = sPartInfo->TBSType;

                IDE_TEST(qdbCommon::validateLobAttributeList(
                             aStatement,
                             sParseTree->tableInfo,
                             sNewPartAttr[i].columns,
                             & TBSAttr,
                             sPartAttr->lobAttr )
                         != IDE_SUCCESS);
            }

            sNewPartAttr[i].next = NULL;

            if( i > 0 )
            {
                sNewPartAttr[i-1].next = &sNewPartAttr[i];
            }
        }
        sParseTree->partTable->partAttr = sNewPartAttr;
    }

    // validation of constraints
    IDE_TEST(qdn::validateConstraints(
                 aStatement,
                 sParseTree->tableInfo,
                 sParseTree->tableInfo->tableOwnerID,
                 sParseTree->tableInfo->TBSID,
                 sParseTree->tableInfo->TBSType,
                 sParseTree->constraints,
                 QDN_ON_ADD_COLUMN,
                 &sUniqueKeyCnt) != IDE_SUCCESS);

    /* PROJ-2464 hybrid partitioned table 지원
     *  - qdn::validateConstraints, Tablespace Validate 이후에 호출
     */
    IDE_TEST( qdbCommon::validateConstraintRestriction( aStatement,
                                                        sParseTree )
              != IDE_SUCCESS );

    /* PROJ-1107 Check Constraint 지원 */
    for ( sCurrConstr = sParseTree->constraints;
          sCurrConstr != NULL;
          sCurrConstr = sCurrConstr->next )
    {
        if ( sCurrConstr->constrType == QD_CHECK )
        {
            sqlInfo.setSourceInfo( aStatement,
                                   &(sCurrConstr->checkCondition->position) );
            IDE_RAISE( ERR_SET_CHECK_CONSTRAINT );
        }
        else
        {
            /* Nothing to do */
        }
    }

    // set default TBS
    if ( sUniqueKeyCnt > 0 )
    {
        sParseTree->TBSAttr.mID = sParseTree->tableInfo->TBSID;
        /* 명시하지 않은 경우 테이블의 테이블스페이스에 생성한다
           IDE_TEST( qcmUser::getDefaultTBS(
           aStatement,
           sParseTree->tableInfo->tableOwnerID,
           &(sParseTree->TBSAttr.mID)) != IDE_SUCCESS );
        */
    }

    // PROJ-1442 Replication Online 중 DDL 허용
    if(sParseTree->tableInfo->replicationCount > 0)
    {
        for(sCurrConstr = sParseTree->constraints;
            sCurrConstr != NULL;
            sCurrConstr = sCurrConstr->next)
        {
            // Replication 대상 Table에 Foreign Key를 추가할 수 없음
            IDE_TEST_RAISE(sCurrConstr->constrType == QD_FOREIGN,
                           ERR_FOREIGN_KEY_ON_REPLICATED_TABLE);
        }
    }

    // key size limit 검사
    /* BUG-13528 : qdn::validateConstraints() 에서 수행함
       IDE_TEST( qdbCommon::validateKeySizeLimit(
       aStatement,
       sParseTree->tableInfo,
       sParseTree->constraints) != IDE_SUCCESS );
    */

    // check QC_MAX_COLUMN_COUNT in qc.h

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_CANNOT_DDL_WITH_RECOVERY)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_DDL_WITH_RECOVERY));
    }
    IDE_EXCEPTION(ERR_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE));
    }
    IDE_EXCEPTION(ERR_NOT_EXIST_TABLE_PARTITION)
    {
        (void)sqlInfo.init(aStatement->qmeMem);
        IDE_SET(ideSetErrorCode( qpERR_ABORT_QCM_NOT_EXIST_TABLE_PARTITION,
                                 sqlInfo.getErrMessage()) );
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION(ERR_FOREIGN_KEY_ON_REPLICATED_TABLE)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDN_ADD_COL_FOREIGN_KEY_WITH_REPLICATED_TBL));
    }
    IDE_EXCEPTION( ERR_SET_CHECK_CONSTRAINT );
    {
        (void)sqlInfo.init( aStatement->qmeMem );
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_NOT_ALLOWED_CHECK_CONSTRAINT,
                                  sqlInfo.getErrMessage() ) );
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION( ERR_COMPRESSION_COL_WITH_REPL );
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_ADD_COL_COMPRESSION_COL_WITH_REPLICATED_TBL));
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::validateDropCol(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... DROP COLUMN ... 의 validation 수행
 *
 *    주의)
 *    hidden column을 직접 삭제할 수 있다.
 *
 * Implementation :
 *    1. 존재하는 테이블인지 체크
 *    2. ALTER 하려는 테이블이 메타 테이블이면 에러 반환
 *    3. ALTER TABLE 권한이 있는지 체크
 *    4. 테이블에 Replication이 걸려있으면, Recovery 여부를 확인
 *    5. 명시한 컬럼이 존재하는지 체크
 *    6. 컬럼 삭제 후 테이블에 컬럼이 하나도 없게 된다면 에러 반환
 *    7. 삭제하고자 하는 컬럼을 참조하고 있는 포린키가 있다면 에러 반환
 *    8. 테이블에 Replication이 걸려있으면,
 *       PRIMARY KEY, UNIQUE KEY, NOT NULL, Check Constraint, Function-based Index Column을
 *       제거할 수 없음을 확인
 *    9. Multi-column에 대한 Constraint인 경우, 일부 Column만 제거할 수 없음을 확인
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::validateDropCol"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY(""));

    qdTableParseTree    * sParseTree;
    qcmColumn           * sParseColumn;
    qcmColumn           * sColumn;
    UInt                  sColumnCount = 0;
    UInt                  sConstColumnCount;
    UInt                  i;
    UInt                * sIndexColList;
    qcmIndex            * sIndexInfo;
    qcmRefChildInfo     * sChildInfo = NULL;  // BUG-28049
    qcmTableInfo        * sTableInfo;
    qcmIndex            * sPKIndex = NULL;
    qcmCheck            * sCheck = NULL;

    /* PROJ-1090 Function-based Index */
    idBool                sIsRelatedToFunctionBasedIndex = ID_FALSE;
    mtcColumn           * sMtcColumn    = NULL;
    qcmColumn           * sQcmColumn    = NULL;
    qcmColumn           * sHiddenColumn = NULL;
    qcuSqlSourceInfo      sqlInfo;
    UInt                  j;
    
    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // ALTER TABLE 구문의 공통적인 validation 수행
    // => 테이블에 LOCK(IS)
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_FALSE )
              != IDE_SUCCESS );

    sTableInfo = sParseTree->tableInfo;

    /* PROJ-1442 Replication Online 중 DDL 허용
     * Recovery 기능과 같이 사용할 수 없음
     */
    if(sTableInfo->replicationCount > 0)
    {
        IDE_TEST_RAISE(sTableInfo->replicationRecoveryCount > 0,
                       ERR_CANNOT_DDL_WITH_RECOVERY);
    }

    for ( sParseColumn = sParseTree->columns;
          sParseColumn != NULL;
          sParseColumn = sParseColumn->next )
    {
        // check column existence
        IDE_TEST( qcmCache::getColumn( aStatement,
                                       sTableInfo,
                                       sParseColumn->namePos,
                                       &sColumn )
                  != IDE_SUCCESS );
        QDB_SET_QCM_COLUMN( sParseColumn, sColumn );

        // column name을 설정한다.
        idlOS::strncpy( sParseColumn->name,
                        sColumn->name,
                        QC_MAX_OBJECT_NAME_LEN + 1 );
        sParseColumn->name[QC_MAX_OBJECT_NAME_LEN] = '\0';
    }

    /* PROJ-1090 Function-based Index
     *  Function-Based Index 관련 Column인 경우,
     *  Function-Based Index에서 생성한 Hidden Column도 같이 제거한다.
     */
    for ( sParseColumn = sParseTree->columns;
          sParseColumn != NULL;
          sParseColumn = sParseColumn->next )
    {
        if ( (sParseColumn->flag & QCM_COLUMN_HIDDEN_COLUMN_MASK)
             == QCM_COLUMN_HIDDEN_COLUMN_TRUE )
        {
            /* hidden column은 hidden column만 삭제한다. */
        }
        else
        {
            /* 일반 column은 관련된 hidden column까지 삭제한다. */
            
            for ( i = 0; i < sTableInfo->indexCount; i++ )
            {
                sIndexInfo = &(sTableInfo->indices[i]);

                /* Function-Based Index 관련 Column인지 확인한다. */
                IDE_TEST( qmsDefaultExpr::isRelatedToFunctionBasedIndex(
                              aStatement,
                              sTableInfo,
                              sIndexInfo,
                              sParseColumn->basicInfo->column.id,
                              &sIsRelatedToFunctionBasedIndex )
                          != IDE_SUCCESS );

                if ( sIsRelatedToFunctionBasedIndex != ID_TRUE )
                {
                    continue;
                }
                else
                {
                    /* Nothing to do */
                }

                /* Hidden Column을 삭제 대상에 포함한다. */
                for ( j = 0; j < sIndexInfo->keyColCount; j++ )
                {
                    sMtcColumn = &(sIndexInfo->keyColumns[j]);

                    IDE_TEST( qcmCache::getColumnByID( sTableInfo,
                                                       sMtcColumn->column.id,
                                                       &sQcmColumn )
                              != IDE_SUCCESS );

                    /* Hidden Column인지 확인한다. */
                    if ( (sQcmColumn->flag & QCM_COLUMN_HIDDEN_COLUMN_MASK)
                         != QCM_COLUMN_HIDDEN_COLUMN_TRUE )
                    {
                        continue;
                    }
                    else
                    {
                        /* Nothing to do */
                    }

                    /* 이미 삭제 대상에 포함했는지 확인한다. */
                    if ( qdbCommon::findColumnIDInColumnList( sParseTree->columns,
                                                              sMtcColumn->column.id )
                         == ID_TRUE )
                    {
                        continue;
                    }
                    else
                    {
                        /* Nothing to do */
                    }

                    /* 메모리를 할당하고 필요한 정보를 설정한다. */
                    IDE_TEST( QC_QMP_MEM(aStatement)->alloc( ID_SIZEOF(qcmColumn),
                                                             (void**)&sHiddenColumn )
                              != IDE_SUCCESS );

                    QCM_COLUMN_INIT( sHiddenColumn );

                    sHiddenColumn->namePos.stmtText = sQcmColumn->name;
                    sHiddenColumn->namePos.offset   = 0;
                    sHiddenColumn->namePos.size     = idlOS::strlen( sQcmColumn->name );

                    QDB_SET_QCM_COLUMN( sHiddenColumn, sQcmColumn );

                    // column name을 설정한다.
                    idlOS::strncpy( sHiddenColumn->name,
                                    sQcmColumn->name,
                                    QC_MAX_OBJECT_NAME_LEN + 1 );
                    sHiddenColumn->name[QC_MAX_OBJECT_NAME_LEN] = '\0';

                    /* Hidden Column을 Column List에 달아둔다. */
                    sHiddenColumn->next = sParseColumn->next;
                    sParseColumn->next  = sHiddenColumn;
                }
            }
        }
    }

    sParseColumn = sParseTree->columns;

    while ( sParseColumn != NULL )
    {
        // PROJ-1442 Replication Online 중 DDL 허용
        if(sTableInfo->replicationCount > 0)
        {
            // Replication 대상 Table에서 Primary Key를 제거할 수 없음
            sPKIndex = sTableInfo->primaryKey;

            for(i = 0; i < sPKIndex->keyColCount; i++)
            {
                IDE_TEST_RAISE((sParseColumn->basicInfo->column.id & SMI_COLUMN_ID_MASK) ==
                               (sPKIndex->keyColumns[i].column.id & SMI_COLUMN_ID_MASK),
                               ERR_PRIMARY_KEY_ON_REPLICATED_TABLE);
            }

            /* PROJ-2397 Dictionary Compressed Column Replication
             *
             */
            IDE_TEST_RAISE( ( sParseColumn->basicInfo->column.flag &
                              SMI_COLUMN_COMPRESSION_MASK ) == SMI_COLUMN_COMPRESSION_TRUE,
                              ERR_DROP_COMP_COL );

        }

        // check referential constraint exists on this column.
        for (i = 0; i < sTableInfo->uniqueKeyCount; i++)
        {
            sIndexInfo = sTableInfo->uniqueKeys[i].constraintIndex;

            if (qdn::intersectColumn((UInt*) smiGetIndexColumns(sIndexInfo->indexHandle),
                                     sIndexInfo->keyColCount,
                                     &(sParseColumn->basicInfo->column.id), 1) == ID_TRUE)
            {
                IDE_TEST(qcm::getChildKeys(aStatement,
                                           sIndexInfo,
                                           sTableInfo,
                                           &sChildInfo) != IDE_SUCCESS);

                IDE_TEST_RAISE(sChildInfo != NULL,
                               ERR_ABORT_QDB_REFERENTIAL_CONSTRAINT_EXIST);
            }
        }

        sParseColumn = sParseColumn->next;
        sColumnCount++;
    }

    // if table has no column after current column is dropped,
    //  then ERR_HAVE_NO_COLUMN
    IDE_TEST_RAISE(sTableInfo->columnCount == sColumnCount,
                   ERR_HAVE_NO_COLUMN);

    // BUG-22255
    // multi-column constraint 삭제 불가
    for (i = 0; i < sTableInfo->uniqueKeyCount; i++)
    {
        sIndexInfo        = sTableInfo->uniqueKeys[i].constraintIndex;
        sIndexColList     = (UInt*) smiGetIndexColumns(sIndexInfo->indexHandle);
        sParseColumn      = sParseTree->columns;
        sConstColumnCount = 0;

        while ( sParseColumn != NULL )
        {
            if (qdn::intersectColumn( sIndexColList,
                                      sIndexInfo->keyColCount,
                                      &(sParseColumn->basicInfo->column.id), 1) == ID_TRUE)
            {
                sConstColumnCount++;
            }
            else
            {
                // Nothing to do.
            }

            sParseColumn = sParseColumn->next;
        }

        if ( (sConstColumnCount > 0) &&
             (sIndexInfo->keyColCount > sConstColumnCount) )
        {
            IDE_RAISE( ERR_ABORT_DROP_INDEX );
        }
        else
        {
            // Nothing to do.
        }
    }

    /* PROJ-1107 Check Constraint 지원
     * Multi-column에 대한 Check Constraint인 경우, 일부 Column을 제거할 수 없다.
     */
    for ( i = 0; i < sTableInfo->checkCount; i++ )
    {
        sCheck            = &(sTableInfo->checks[i]);
        sConstColumnCount = 0;

        for ( sParseColumn = sParseTree->columns;
              sParseColumn != NULL;
              sParseColumn = sParseColumn->next )
        {
            if ( qdn::intersectColumn( sCheck->constraintColumn,
                                       sCheck->constraintColumnCount,
                                       &(sParseColumn->basicInfo->column.id),
                                       1 )
                 == ID_TRUE )
            {
                sConstColumnCount++;
            }
            else
            {
                /* Nothing to do */
            }
        }

        IDE_TEST_RAISE( (sConstColumnCount > 0) &&
                        (sConstColumnCount < sCheck->constraintColumnCount),
                        ERR_ABORT_DROP_CHECK_CONSTRAINT );
    }

    // PROJ-1502 PARTITIONED DISK TABLE
    if( sTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        sParseColumn = sParseTree->columns;

        while ( sParseColumn != NULL )
        {
            // cannot drop columns related to partitioned key
            if( qcmCache::getPartKeyColumn( aStatement,
                                            sTableInfo,
                                            sParseColumn->namePos,
                                            &sColumn ) == IDE_SUCCESS )
            {
                IDE_RAISE( ERR_ABORT_DROP_PART_KEY );
            }

            sParseColumn = sParseColumn->next;
        }

        // 모든 파티션에 LOCK(IS)
        // 파티션 리스트를 파스트리에 달아놓는다.
        IDE_TEST( qdbCommon::checkAndSetAllPartitionInfo(
                      aStatement,
                      sTableInfo->tableID,
                      & (sParseTree->partTable->partInfoList) )
                  != IDE_SUCCESS );
        
        // PROJ-1624 non-partitioned index
        IDE_TEST( qdx::makeAndLockIndexTableList(
                      aStatement,
                      ID_FALSE,
                      sParseTree->tableInfo,
                      &(sParseTree->oldIndexTables) )
                  != IDE_SUCCESS );
    }
    else
    {
        // Nothing to do.
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_CANNOT_DDL_WITH_RECOVERY)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_DDL_WITH_RECOVERY));
    }
    IDE_EXCEPTION(ERR_PRIMARY_KEY_ON_REPLICATED_TABLE)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDD_DROP_COL_PRIMARY_KEY_WITH_REPLICATED_TBL));
    }
    IDE_EXCEPTION(ERR_ABORT_DROP_PART_KEY);
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_DROP_PART_KEY));
    }
    IDE_EXCEPTION(ERR_HAVE_NO_COLUMN);
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_INVALID_COLUMN_COUNT));
    }
    IDE_EXCEPTION(ERR_ABORT_QDB_REFERENTIAL_CONSTRAINT_EXIST);
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_REFERENTIAL_CONSTRAINT_EXIST));
    }
    IDE_EXCEPTION(ERR_ABORT_DROP_INDEX)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_DROP_MULTI_COLUMN_CONSTRAINT_EXIST));
    }
    IDE_EXCEPTION( ERR_ABORT_DROP_CHECK_CONSTRAINT )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_DROP_MULTI_COLUMN_CONSTRAINT_EXIST ) );
    }
    IDE_EXCEPTION( ERR_DROP_COMP_COL )
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_DROP_COMPRESSED_COLUMN_WITH_REPLICATE_TABLE));
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::validateRenameCol(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... RENAME COLUMN ... 의 validation 수행
 *
 * Implementation :
 *    1. 테이블 존재 여부 체크
 *    2. 테이블의 소유자가 SYSTEM_ 이면 alter 불가능
 *    3. alter table 권한이 있는지 체크
 *    4. 테이블에 이중화가 걸려있으면 에러
 *    5. 변경되기 전의 컬럼 이름이 존재하는지 체크
 *    6. 변경후의 컬럼 이름이 이미 존재하는지 체크
 *    7. check constraint 처리를 위해, 관련 constraint를 Parse Tree에 추가
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::validateRenameCol"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY(""));

    qdTableParseTree    * sParseTree;
    qcmColumn           * sOldColumn;
    qcmColumn           * sNewColumn;
    qcuSqlSourceInfo      sqlInfo;

    // initialize
    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // ALTER TABLE 구문의 공통적인 validation 수행
    // => 테이블에 LOCK(IS)
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_TRUE )
              != IDE_SUCCESS );

    // check old column existence
    IDE_TEST(qcmCache::getColumn(aStatement,
                                 sParseTree->tableInfo,
                                 sParseTree->columns->namePos,
                                 &sOldColumn) != IDE_SUCCESS);
    QDB_SET_QCM_COLUMN(sParseTree->columns, sOldColumn);

    /* PROJ-1090 Function-based Index */
    if ( (sOldColumn->flag & QCM_COLUMN_HIDDEN_COLUMN_MASK)
         == QCM_COLUMN_HIDDEN_COLUMN_TRUE )
    {
        sqlInfo.setSourceInfo( aStatement,
                               &(sParseTree->columns->namePos) );
        IDE_RAISE( ERR_CANNOT_ALTER_HIDDEN_COLUMN );
    }
    else
    {
        /* Nothing to do */
    }
    
    // old column name을 설정한다.
    idlOS::strncpy( sParseTree->columns->name,
                    sOldColumn->name,
                    QC_MAX_OBJECT_NAME_LEN + 1 );
    sParseTree->columns->name[QC_MAX_OBJECT_NAME_LEN] = '\0';

    // PROJ-2002 Column Security
    // 암호 컬럼은 rename 불가
    IDE_TEST_RAISE( (sParseTree->columns->basicInfo->module->flag
                     & MTD_ENCRYPT_TYPE_MASK)
                    == MTD_ENCRYPT_TYPE_TRUE,
                    ERR_EXIST_ENCRYPTED_COLUMN );

    // check new column name
    if (qcmCache::getColumn( aStatement,
                             sParseTree->tableInfo,
                             sParseTree->columns->next->namePos,
                             &sNewColumn)
        == IDE_SUCCESS)
    {
        sqlInfo.setSourceInfo(
            aStatement,
            & sNewColumn->namePos );
        IDE_RAISE(ERR_DUP_COLUMN_NAME);
    }

    /* PROJ-1107 Check Constraint 지원 */
    IDE_TEST( qdnCheck::addCheckConstrSpecRelatedToColumn(
                            aStatement,
                            &(sParseTree->constraints),
                            sParseTree->tableInfo->checks,
                            sParseTree->tableInfo->checkCount,
                            sOldColumn->basicInfo->column.id )
              != IDE_SUCCESS );

    /* PROJ-1090 Function-based Index */
    IDE_TEST( qmsDefaultExpr::addDefaultExpressionColumnsRelatedToColumn(
                  aStatement,
                  &(sParseTree->defaultExprColumns),
                  sParseTree->tableInfo,
                  sOldColumn->basicInfo->column.id )
              != IDE_SUCCESS );
    
    // PROJ-1502 PARTITIONED DISK TABLE
    if( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        // 모든 파티션에 LOCK(IS)
        // 파티션 리스트를 파스트리에 달아놓는다.
        IDE_TEST( qdbCommon::checkAndSetAllPartitionInfo(
                      aStatement,
                      sParseTree->tableInfo->tableID,
                      & (sParseTree->partTable->partInfoList) )
                  != IDE_SUCCESS );
       
        // PROJ-1624 non-partitioned index
        IDE_TEST( qdx::makeAndLockIndexTableList(
                      aStatement,
                      ID_FALSE,
                      sParseTree->tableInfo,
                      &(sParseTree->oldIndexTables) )
                  != IDE_SUCCESS );
    }
    else
    {
        // Nothing to do.
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_DUP_COLUMN_NAME);
    {
        (void)sqlInfo.init(aStatement->qmeMem);
        IDE_SET(
            ideSetErrorCode(qpERR_ABORT_QDB_DUPLICATE_COLUMN,
                            sqlInfo.getErrMessage() ));
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION(ERR_EXIST_ENCRYPTED_COLUMN);
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_EXIST_ENCRYPTED_COLUMN));
    }
    IDE_EXCEPTION( ERR_CANNOT_ALTER_HIDDEN_COLUMN );
    {
        (void)sqlInfo.init( aStatement->qmeMem );
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_CANNOT_ALTER_HIDDEN_COLUMN,
                                  sqlInfo.getErrMessage() ) );
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::validateRenameTable(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... RENAME TO ..., RENAME ... TO ... 의 validation 수행
 *
 * Implementation :
 *    1. 테이블 존재 여부 체크
 *    2. 테이블의 소유자가 SYSTEM_ 이면 alter 불가능
 *    3. alter table 권한이 있는지 체크
 *    4. 테이블에 이중화가 걸려있으면 에러
 *    5. 변경후의 테이블 이름이 이미 존재하는지 체크
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::validateRenameTable"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY(""));

    qdTableParseTree    * sParseTree;
    qsOID                 sProcID;
    UInt                  sUserID;
    qcmColumn           * sColumn;
    UInt                  i;
    qcuSqlSourceInfo      sqlInfo;

    idBool                sExist      = ID_FALSE;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // ALTER TABLE 구문의 공통적인 validation 수행
    // => 테이블에 LOCK(IS)
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_TRUE )
              != IDE_SUCCESS );

    // BUG-34388
    if (qdbCommon::containDollarInName(&(sParseTree->newTableName)) == ID_TRUE)
    {
        sqlInfo.setSourceInfo(aStatement, &(sParseTree->newTableName));
        IDE_RAISE(CANT_USE_RESERVED_WORD);
    }

    /* PROJ-2211 Materialized View */
    IDE_TEST_RAISE( sParseTree->tableInfo->tableType == QCM_MVIEW_TABLE,
                    ERR_RENAME_NOT_SUPPORT_MVIEW );

    // PROJ-2002 Column Security
    // 암호 컬럼이 있는 경우 rename 불가
    for ( i = 0; i < sParseTree->tableInfo->columnCount; i++ )
    {
        sColumn = & sParseTree->tableInfo->columns[i];

        IDE_TEST_RAISE( (sColumn->basicInfo->module->flag
                         & MTD_ENCRYPT_TYPE_MASK)
                        == MTD_ENCRYPT_TYPE_TRUE,
                        ERR_EXIST_ENCRYPTED_COLUMN );
    }

    // if specified new object exists, then error
    IDE_TEST( qcm::existObject( aStatement,
                                ID_FALSE,
                                sParseTree->userName,
                                sParseTree->newTableName,
                                QS_OBJECT_MAX,
                                &sUserID,
                                &sProcID,
                                &sExist )
        != IDE_SUCCESS);

    IDE_TEST_RAISE(sExist == ID_TRUE, ERR_EXIST_OBJECT_NAME );

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_EXIST_OBJECT_NAME);
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_EXIST_OBJECT_NAME));
    }
    IDE_EXCEPTION(ERR_EXIST_ENCRYPTED_COLUMN);
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_EXIST_ENCRYPTED_COLUMN));
    }
    IDE_EXCEPTION( ERR_RENAME_NOT_SUPPORT_MVIEW );
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDM_RENAME_NOT_SUPPORT_MVIEW ) );
    }
    IDE_EXCEPTION( CANT_USE_RESERVED_WORD )
    {
        (void)sqlInfo.init(aStatement->qmeMem);
        IDE_SET( ideSetErrorCode(qpERR_ABORT_QDB_RESERVED_WORD_IN_OBJECT_NAME,
                                 sqlInfo.getErrMessage() ));
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::validateSetDefault(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... ALTER COLUMN (.. SET DEFAULT ..) 의 validation 수행
 *
 * Implementation :
 *    1. 테이블 존재 여부 체크
 *    2. 테이블의 소유자가 SYSTEM_ 이면 alter 불가능
 *    3. alter table 권한이 있는지 체크
 *    4. validation of default expression
 *    5. default 값을 스트링 형태로 구하기
 *    6. alter 하고자 하는 컬럼이 존재하는지 체크
 *    7. 6 에서 구한 default 스트링을 parse tree 에 부여
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::validateSetDefault"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY(""));

    qdTableParseTree    * sParseTree;
    qcmColumn           * sColumn;
    qcuSqlSourceInfo      sqlInfo;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // ALTER TABLE 구문의 공통적인 validation 수행
    // => 테이블에 LOCK(IS)
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_FALSE )
              != IDE_SUCCESS );

    // validation of default expression
    IDE_TEST(qdbCommon::validateDefaultDefinition(
                 aStatement,
                 sParseTree->columns->defaultValue )
             != IDE_SUCCESS);

    // check existence of column
    IDE_TEST(qcmCache::getColumn(aStatement,
                                 sParseTree->tableInfo,
                                 sParseTree->columns->namePos,
                                 &sColumn)
             != IDE_SUCCESS);
    QDB_SET_QCM_COLUMN(sParseTree->columns, sColumn);

    // check TIMESTAMP column
    if( ( sColumn->basicInfo->flag & MTC_COLUMN_TIMESTAMP_MASK )
        == MTC_COLUMN_TIMESTAMP_TRUE )
    {
        sqlInfo.setSourceInfo( aStatement, & sColumn->namePos );
        IDE_RAISE(ERR_CANNOT_SET_TIMESTAMP_DEFAULT);
    }
    
    /* PROJ-1090 Function-based Index */
    if ( (sColumn->flag & QCM_COLUMN_HIDDEN_COLUMN_MASK)
         == QCM_COLUMN_HIDDEN_COLUMN_TRUE )
    {
        sqlInfo.setSourceInfo( aStatement,
                               &(sParseTree->columns->namePos) );
        IDE_RAISE( ERR_CANNOT_ALTER_HIDDEN_COLUMN );
    }
    else
    {
        /* Nothing to do */
    }

    if ( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST( qdbCommon::checkAndSetAllPartitionInfo( aStatement,
                                                          sParseTree->tableInfo->tableID,
                                                          & sParseTree->partTable->partInfoList )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_CANNOT_SET_TIMESTAMP_DEFAULT);
    {
        (void)sqlInfo.init(aStatement->qmeMem);
        IDE_SET(
            ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_SET_TIMESTAMP_DEFAULT,
                            sqlInfo.getErrMessage() ));
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION( ERR_CANNOT_ALTER_HIDDEN_COLUMN );
    {
        (void)sqlInfo.init( aStatement->qmeMem );
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_CANNOT_ALTER_HIDDEN_COLUMN,
                                  sqlInfo.getErrMessage() ) );
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::validateDropDefault(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... ALTER COLUMN(... DROP DEFAULT ..) 의 validation 수행
 *
 * Implementation :
 *    1. 테이블 존재 여부 체크
 *    2. 테이블의 소유자가 SYSTEM_ 이면 alter 불가능
 *    3. alter table 권한이 있는지 체크
 *    4. alter 하고자 하는 컬럼이 존재하는지 체크
 *    5. default 값이 설정되어 있는지 체크
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::validateDropDefault"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY(""));

    qdTableParseTree    * sParseTree;
    qcmColumn           * sColumn;
    qcuSqlSourceInfo      sqlInfo;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // ALTER TABLE 구문의 공통적인 validation 수행
    // => 테이블에 LOCK(IS)
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_FALSE )
              != IDE_SUCCESS );

    // check existence of column
    IDE_TEST(qcmCache::getColumn(aStatement,
                                 sParseTree->tableInfo,
                                 sParseTree->columns->namePos,
                                 &sColumn) != IDE_SUCCESS);
    QDB_SET_QCM_COLUMN(sParseTree->columns, sColumn);

    // check existence of default
    IDE_TEST_RAISE(sColumn->defaultValueStr == NULL, ERR_NOT_EXIST_DEFAULT);

    /* PROJ-1090 Function-based Index */
    if ( (sColumn->flag & QCM_COLUMN_HIDDEN_COLUMN_MASK)
         == QCM_COLUMN_HIDDEN_COLUMN_TRUE )
    {
        sqlInfo.setSourceInfo( aStatement,
                               &(sParseTree->columns->namePos) );
        IDE_RAISE( ERR_CANNOT_ALTER_HIDDEN_COLUMN );
    }
    else
    {
        /* Nothing to do */
    }
    
    if ( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST( qdbCommon::checkAndSetAllPartitionInfo( aStatement,
                                                          sParseTree->tableInfo->tableID,
                                                          & sParseTree->partTable->partInfoList )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_NOT_EXIST_DEFAULT);
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_NOT_EXISTS_DEFAULT));
    }
    IDE_EXCEPTION( ERR_CANNOT_ALTER_HIDDEN_COLUMN );
    {
        (void)sqlInfo.init( aStatement->qmeMem );
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_CANNOT_ALTER_HIDDEN_COLUMN,
                                  sqlInfo.getErrMessage() ) );
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::validateNotNull(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... ALTER COLUMN (.. NOT NULL ..) 의 validation 수행
 *
 * Implementation :
 *    1. 테이블 존재 여부 체크
 *    2. 테이블의 소유자가 SYSTEM_ 이면 alter 불가능
 *    3. alter table 권한이 있는지 체크
 *    4. alter 하고자 하는 컬럼이 존재하는지 체크
 *    5. Compression column 이면 에러
 *    6. not null 이 이미 설정되어 있으면 에러
 *    7. Hidden Column이면 에러
 *    8. check not null constraint => qdn::validateConstraints
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::validateNotNull"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY(""));

    // alter column not null
    qdTableParseTree    * sParseTree;
    qcmColumn           * sColumn;
    qcuSqlSourceInfo      sqlInfo;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // ALTER TABLE 구문의 공통적인 validation 수행
    // => 테이블에 LOCK(IS)
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_FALSE )
              != IDE_SUCCESS );

    // check existence of column
    IDE_TEST(qcmCache::getColumn(aStatement,
                                 sParseTree->tableInfo,
                                 sParseTree->columns->namePos,
                                 &sColumn) != IDE_SUCCESS);
    QDB_SET_QCM_COLUMN(sParseTree->columns, sColumn);

    // PROJ-2264 Dictionary table
    // Compression column 은 NULL/NOT NULL 변경이 불가능하다.
    if ( (sColumn->basicInfo->column.flag & SMI_COLUMN_COMPRESSION_MASK)
         == SMI_COLUMN_COMPRESSION_TRUE )
    {
        sqlInfo.setSourceInfo( aStatement,
                               &(sParseTree->columns->namePos) );
        IDE_RAISE( ERR_MODIFY_COMPRESSION_COLUMN );
    }
    else
    {
        // Nothing to do.
    }

    // check existence of not null.
    IDE_TEST_RAISE((sColumn->basicInfo->flag & MTC_COLUMN_NOTNULL_MASK)
                   == MTC_COLUMN_NOTNULL_TRUE,
                   ERR_EXIST_NOT_NULL);

    /* PROJ-1090 Function-based Index */
    if ( (sColumn->flag & QCM_COLUMN_HIDDEN_COLUMN_MASK)
         == QCM_COLUMN_HIDDEN_COLUMN_TRUE )
    {
        sqlInfo.setSourceInfo( aStatement,
                               &(sParseTree->columns->namePos) );
        IDE_RAISE( ERR_CANNOT_ALTER_HIDDEN_COLUMN );
    }
    else
    {
        /* Nothing to do */
    }

    // PROJ-1502 PARTITIONED DISK TABLE
    if( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        // 모든 파티션에 LOCK(IS)
        // 파티션 리스트를 파스트리에 달아놓는다.
        IDE_TEST( qdbCommon::checkAndSetAllPartitionInfo(
                      aStatement,
                      sParseTree->tableInfo->tableID,
                      & (sParseTree->partTable->partInfoList) )
                  != IDE_SUCCESS );
    }

    // check not null constraint.
    IDE_TEST(qdn::validateConstraints( aStatement,
                                       sParseTree->tableInfo,
                                       sParseTree->tableInfo->tableOwnerID,
                                       sParseTree->tableInfo->TBSID,
                                       sParseTree->tableInfo->TBSType,
                                       sParseTree->constraints,
                                       QDN_ON_ADD_CONSTRAINT,
                                       NULL )
             != IDE_SUCCESS);

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_EXIST_NOT_NULL);
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_EXIST_NOT_NULL));
    }
    IDE_EXCEPTION( ERR_CANNOT_ALTER_HIDDEN_COLUMN );
    {
        (void)sqlInfo.init( aStatement->qmeMem );
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_CANNOT_ALTER_HIDDEN_COLUMN,
                                  sqlInfo.getErrMessage() ) );
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION( ERR_MODIFY_COMPRESSION_COLUMN );
    {
        (void)sqlInfo.init( aStatement->qmeMem );
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_CANNOT_ALTER_COMPRESSION_COLUMN,
                                  sqlInfo.getErrMessage() ) );
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::validateNullable(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... ALTER (COL NULL) 의 validation 수행
 *
 * Implementation :
 *    1. 존재하는 테이블인지 체크
 *    2. ALTER 하려는 테이블이 메타 테이블이면 에러 반환
 *    3. ALTER TABLE 권한이 있는지 체크
 *    4. 테이블에 이중화가 걸려있으면 에러 반환
 *    5. 명시한 컬럼이 존재하는지 체크
 *    6. Compression column 이면 에러
 *    7. not null constraint 가 없다면 에러 반환
 *    8. 변경하고자 하는 컬럼이 primary key 컬럼이면 에러 반환
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::validateNullable"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY(""));

    // alter column null
    qdTableParseTree    * sParseTree;
    qcmColumn           * sColumn;
    qcuSqlSourceInfo      sqlInfo;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // ALTER TABLE 구문의 공통적인 validation 수행
    // => 테이블에 LOCK(IS)
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_FALSE )
              != IDE_SUCCESS );

    // check existence of column
    IDE_TEST(qcmCache::getColumn(aStatement,
                                 sParseTree->tableInfo,
                                 sParseTree->columns->namePos,
                                 &sColumn) != IDE_SUCCESS);
    QDB_SET_QCM_COLUMN(sParseTree->columns, sColumn);

    // PROJ-2264 Dictionary table
    // Compression column 은 NULL/NOT NULL 변경이 불가능하다.
    if ( (sColumn->basicInfo->column.flag & SMI_COLUMN_COMPRESSION_MASK)
         == SMI_COLUMN_COMPRESSION_TRUE )
    {
        sqlInfo.setSourceInfo( aStatement,
                               &(sParseTree->columns->namePos) );
        IDE_RAISE( ERR_MODIFY_COMPRESSION_COLUMN );
    }
    else
    {
        // Nothing to do.
    }

    // check existence of not null.
    IDE_TEST_RAISE((sColumn->basicInfo->flag & MTC_COLUMN_NOTNULL_MASK)
                   == MTC_COLUMN_NOTNULL_FALSE,
                   ERR_NOT_EXIST_NOT_NULL);

    // search not null constraint.

    // if this column is a primary key column, raise error.
    if (sParseTree->tableInfo->primaryKey != NULL)
    {
        IDE_TEST_RAISE(qdn::intersectColumn(
                           (UInt*) smiGetIndexColumns(sParseTree->tableInfo->primaryKey->indexHandle),
                           sParseTree->tableInfo->primaryKey->keyColCount,
                           &sColumn->basicInfo->column.id, 1) == ID_TRUE, ERR_NOT_ALLOWED_DROP_NOT_NULL);
    }

    // PROJ-1502 PARTITIONED DISK TABLE
    if( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        // 모든 파티션에 LOCK(IS)
        // 파티션 리스트를 파스트리에 달아놓는다.
        IDE_TEST( qdbCommon::checkAndSetAllPartitionInfo(
                      aStatement,
                      sParseTree->tableInfo->tableID,
                      & (sParseTree->partTable->partInfoList) )
                  != IDE_SUCCESS );
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_NOT_EXIST_NOT_NULL);
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_NOT_EXIST_NOT_NULL));
    }
    IDE_EXCEPTION(ERR_NOT_ALLOWED_DROP_NOT_NULL);
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_NOT_ALLOWED_DROP_NOT_NULL));
    }
    IDE_EXCEPTION( ERR_MODIFY_COMPRESSION_COLUMN );
    {
        (void)sqlInfo.init( aStatement->qmeMem );
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_CANNOT_ALTER_COMPRESSION_COLUMN,
                                  sqlInfo.getErrMessage() ) );
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::validateCompactTable( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... COMPACT 의 validation 수행
 *
 * Implementation :
 *    1. 테이블 존재 여부 체크
 *    2. 테이블의 소유자가 SYSTEM_ 이면 alter 불가능
 *    3. MEMORY 테이블만 수행 가능
 *    4. alter table 권한이 있는지 체크
 *
 ***********************************************************************/

    qdTableParseTree     * sParseTree    = NULL;
    UInt                   sTableType    = 0;
    qcmPartitionInfoList * sPartInfoList = NULL;
    SInt                   sCountMemType = 0;
    SInt                   sCountVolType = 0;
    qdPartitionAttribute * sPartAttr     = NULL;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    /* ALTER TABLE 구문의 공통적인 validation 수행 - 테이블에 LOCK(IS) */
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_FALSE )
              != IDE_SUCCESS );

    /* 테이블 메타 정보 select 후 MEMORY 기반 테이블이 아닐 경우 오류 발생 */
    sTableType = sParseTree->tableInfo->tableFlag & SMI_TABLE_TYPE_MASK;

    /* PROJ-2464 hybrid partitioned table 지원
     *  - HPT 인 경우에, Memory, Disk 매체를 모두 지닐 수 있다.
     *  - 따라서 Disk 매체가 포함되어도 해당 옵션을 사용할 수 있다.
     *  - Partitioned를 고려한 처리를 추가한다.
     *     1. Parser에서 할당하지 않은 PartTable를 여기서 할당한다.
     *     2. Partition List를 가져온다.
     *     3. Partition 구성을 검사한다.
     *     4. Memory 매체가 없으면 Compact를 사용할 수 없다.
     *
     *  - 관련 내용 : 테이블 메타 정보 select 후 MEMORY 기반 테이블이 아닐 경우 오류 발생
     *                To fix BUG-21965
     *                VOLATILE 기반 테이블인 경우도 수행가능하게 변경
     */
    if ( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        if ( sParseTree->partTable->partAttr == NULL )
        {
            /* 1. Partition List를 가져온다. */
            IDE_TEST( qdbCommon::checkAndSetAllPartitionInfo( aStatement,
                                                              sParseTree->tableInfo->tableID,
                                                              &( sParseTree->partTable->partInfoList ) )
                      != IDE_SUCCESS );

        }
        else
        {
            /* BUG-43060 Partition 단위 Compact */
            sPartAttr = sParseTree->partTable->partAttr;
            IDE_TEST( qdbCommon::checkPartitionInfo( aStatement,
                                                     sParseTree->tableInfo,
                                                     sPartAttr->tablePartName )
                       != IDE_SUCCESS );
        }

        sPartInfoList = sParseTree->partTable->partInfoList;
    }
    else
    {
        /* Nothing to do */
    }

    /* 3. Partition 구성을 검사한다. */
    qdbCommon::getTableTypeCountInPartInfoList( & sTableType,
                                                sPartInfoList,
                                                NULL,
                                                & sCountMemType,
                                                & sCountVolType );

    /* 4. Memory 매체가 없으면 Compact를 사용할 수 없다. */
    IDE_TEST_RAISE( ( sCountMemType + sCountVolType ) == 0,
                    ERR_NO_MEMORY_OR_VOLATILE_TABLE );

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_NO_MEMORY_OR_VOLATILE_TABLE )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_NO_MEMORY_OR_VOLATILE_TABLE ) );
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::validateAgingTable( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... DISK 의 validation 수행
 *
 * Implementation :
 *    1. 테이블 존재 여부 체크
 *    2. 테이블의 소유자가 SYSTEM_ 이면 alter 불가능
 *    3. DISK 테이블만 수행 가능
 *    4. alter table 권한이 있는지 체크
 *
 ***********************************************************************/

    qdTableParseTree     * sParseTree     = NULL;
    UInt                   sTableType     = 0;
    qcmPartitionInfoList * sPartInfoList  = NULL;
    SInt                   sCountDiskType = 0;
    qdPartitionAttribute * sPartAttr      = NULL;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    /* ALTER TABLE 구문의 공통적인 validation 수행 - 테이블에 LOCK(IS) */
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_FALSE )
              != IDE_SUCCESS );

    /* 테이블 메타 정보 select 후 DISK 기반 테이블이 아닐 경우 오류 발생 */
    sTableType = sParseTree->tableInfo->tableFlag & SMI_TABLE_TYPE_MASK;

    if ( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        if ( sParseTree->partTable->partAttr == NULL )
        {
            /* 파티션 리스트를 파스트리에 달아놓는다. */
            IDE_TEST( qdbCommon::checkAndSetAllPartitionInfo( aStatement,
                                                              sParseTree->tableInfo->tableID,
                                                              &( sParseTree->partTable->partInfoList ) )
                      != IDE_SUCCESS );

            /* PROJ-1624 non-partitioned index */
            IDE_TEST( qdx::makeAndLockIndexTableList( aStatement,
                                                      ID_FALSE,
                                                      sParseTree->tableInfo,
                                                      &( sParseTree->oldIndexTables ) )
                      != IDE_SUCCESS );
        }
        else
        {
            /* BUG-43060 Partition 단위 Aging */
            sPartAttr = sParseTree->partTable->partAttr;
            IDE_TEST( qdbCommon::checkPartitionInfo( aStatement,
                                                     sParseTree->tableInfo,
                                                     sPartAttr->tablePartName )
                       != IDE_SUCCESS );

            /* BUG-43115 AGING PARTITION Deadlock
             *  Partitioned Table에 IX Lock을 잡으면, Deadlock 회피를 위해 Index Table에는 X Lock을 잡지 않는다.
             *  그런데. Index Table을 Aging하려면, X Lock을 잡아야 한다.
             *  따라서, AGING PARTITION인 경우에는 Index Table에 Aging을 하지 않는다.
             */
        }

        /* PROJ-2464 hybrid partitioned table 지원 */
        sPartInfoList = sParseTree->partTable->partInfoList;
    }
    else
    {
        /* Nothing to do */
    }

    /* PROJ-2464 hybrid partitioned table 지원
     *  - HPT 인 경우에, Memory, Disk 매체를 모두 지닐 수 있다.
     *  - 따라서 Memory 매체가 포함되어도 해당 옵션을 사용할 수 있다.
     *  - 하지만 Disk 매체가 없으면 Aging를 사용할 수 없다.
     *
     *  - 관련 내용 : 테이블 메타 정보 select 후 DISK 기반 테이블이 아닐 경우 오류 발생
     */
    qdbCommon::getTableTypeCountInPartInfoList( & sTableType,
                                                sPartInfoList,
                                                & sCountDiskType,
                                                NULL,
                                                NULL );

    IDE_TEST_RAISE( sCountDiskType == 0, ERR_NO_DISK_TABLE );

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_NO_DISK_TABLE )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_NO_DISK_TABLE ) );
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::validateAllIndexEnable(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... ALL INDEX ENABLE/DISABLE 의 validation 수행
 *
 * Implementation :
 *    1. 테이블 존재 여부 체크
 *    2. 테이블의 소유자가 SYSTEM_ 이면 alter 불가능
 *    3. alter table 권한이 있는지 체크
 *    4. 테이블에 이중화가 걸려있으면 에러
 *    5. 테이블에 uniquekey 가 있고, 그 키를 참조하는 child 가 있으면 에러
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::validateAllIndexEnable"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY(""));

    qdTableParseTree    * sParseTree;
    UInt                  i;
    qcmIndex            * sIndexInfo;
    qcmRefChildInfo     * sChildInfo = NULL;  // BUG-28049

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // ALTER TABLE 구문의 공통적인 validation 수행
    // => 테이블에 LOCK(IS)
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_TRUE )
              != IDE_SUCCESS );

    // check referential constraint exists.
    for (i = 0; i < sParseTree->tableInfo->uniqueKeyCount; i++)
    {
        sIndexInfo = sParseTree->tableInfo->uniqueKeys[i].constraintIndex;

        IDE_TEST(qcm::getChildKeys(aStatement,
                                   sIndexInfo,
                                   sParseTree->tableInfo,
                                   &sChildInfo) != IDE_SUCCESS);

        IDE_TEST_RAISE(sChildInfo != NULL,
                       ERR_ABORT_REFERENTIAL_CONSTRAINT_EXIST);
    }

    if ( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST( qdbCommon::checkAndSetAllPartitionInfo( aStatement,
                                                          sParseTree->tableInfo->tableID,
                                                          & sParseTree->partTable->partInfoList )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_ABORT_REFERENTIAL_CONSTRAINT_EXIST);
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_REFERENTIAL_CONSTRAINT_EXIST));
    }

    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::validateAlterMaxRows(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... MAXROWS n ... 의 validation 수행
 *
 * Implementation :
 *    1. 테이블 존재 여부 체크
 *    2. 테이블의 소유자가 SYSTEM_ 이면 alter 불가능
 *    3. alter table 권한이 있는지 체크
 *    4. 테이블에 이중화가 걸려있으면 에러
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::validateAlterMaxRows"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY("qdbAlter::validateAlterMaxRows"));

    qdTableParseTree    * sParseTree;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // ALTER TABLE 구문의 공통적인 validation 수행
    // => 테이블에 LOCK(IS)
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_TRUE )
              != IDE_SUCCESS );

    IDE_TEST_RAISE( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE,
                    ERR_ALTER_MODIFY_MAXROWS_OF_PARTITION );

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_ALTER_MODIFY_MAXROWS_OF_PARTITION)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_MODIFY_MAXROWS_OF_PARTITION));
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::validateAlterTableOptions(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... LOGGING/NOLOGGING PARALLEL/NOPARALLEL 의 validation 수행
 *
 * Implementation :
 *    1. 테이블 존재 여부 체크
 *    2. 테이블의 소유자가 SYSTEM_ 이면 alter 불가능
 *    3. alter table 권한이 있는지 체크
 *    4. 테이블에 이중화가 걸려있으면 에러
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::validateAlterTableOptions"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY("qdbAlter::validateAlterTableOptions"));

    qdTableParseTree * sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // ALTER TABLE 구문의 공통적인 validation 수행
    // => 테이블에 LOCK(IS)
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_TRUE )
              != IDE_SUCCESS );

    if ( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST( qdbCommon::checkAndSetAllPartitionInfo( aStatement,
                                                          sParseTree->tableInfo->tableID,
                                                          & sParseTree->partTable->partInfoList )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::validateAlterTableSegAttr( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... PCTFREE .. PCTUSED ..
 *                    INITRANS .. MAXTRANS ..;
 *
 * Implementation :
 *    1. 테이블 존재 여부 체크
 *    2. 테이블의 소유자가 SYSTEM_ 이면 alter 불가능
 *    3. alter table 권한이 있는지 체크
 *    4. 테이블에 이중화가 걸려있으면 에러
 *
 ***********************************************************************/

    qdTableParseTree * sParseTree = NULL;
    UInt               sTableType = 0;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    /* ALTER TABLE 구문의 공통적인 validation 수행 - 테이블에 LOCK(IS) */
    IDE_TEST( validateAlterCommon( aStatement, ID_TRUE )
              != IDE_SUCCESS );

    sTableType = sParseTree->tableInfo->tableFlag & SMI_TABLE_TYPE_MASK;

    IDE_TEST_RAISE( smiIsDiskTable( sParseTree->tableInfo->tableHandle ) != ID_TRUE,
                    ERR_NO_DISK_TABLE );

    /* PROJ-2464 hybrid partitioned table 지원 */
    IDE_TEST( qdbCommon::validateAndSetSegAttr( sTableType,
                                                &( sParseTree->tableInfo->segAttr ),
                                                &( sParseTree->segAttr ),
                                                ID_TRUE )
              != IDE_SUCCESS );

    if ( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        /* 파티션 리스트를 파스트리에 달아놓는다. */
        IDE_TEST( qdbCommon::checkAndSetAllPartitionInfo(
                      aStatement,
                      sParseTree->tableInfo->tableID,
                      &( sParseTree->partTable->partInfoList ) )
                  != IDE_SUCCESS );

        /* PROJ-1624 non-partitioned index */
        IDE_TEST( qdx::makeAndLockIndexTableList(
                      aStatement,
                      ID_FALSE,
                      sParseTree->tableInfo,
                      &( sParseTree->oldIndexTables)  )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_NO_DISK_TABLE )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_NO_DISK_TABLE ) );
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::validateAlterTableSegStoAttr( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... STORAGE( INITEXTENTS ..
 *    NEXTEXTENTS .. MINEXTENTS .. MAXEXTENTS .. );
 *
 * Implementation :
 *    1. 테이블 존재 여부 체크
 *    2. 테이블의 소유자가 SYSTEM_ 이면 alter 불가능
 *    3. alter table 권한이 있는지 체크
 *    4. 테이블에 이중화가 걸려있으면 에러
 *
 ***********************************************************************/

    qdTableParseTree * sParseTree = NULL;
    UInt               sTableType = 0;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    /* ALTER TABLE 구문의 공통적인 validation 수행 - 테이블에 LOCK(IS) */
    IDE_TEST( validateAlterCommon( aStatement, ID_TRUE )
              != IDE_SUCCESS );

    sTableType = sParseTree->tableInfo->tableFlag & SMI_TABLE_TYPE_MASK;

    /* BUG-29382 memory table 에 대해서는 storage_clause 를 쓰면 안됨. */
    IDE_TEST_RAISE( smiIsDiskTable( sParseTree->tableInfo->tableHandle ) != ID_TRUE,
                    ERR_NO_DISK_TABLE );

    /* PROJ-2464 hybrid partitioned table 지원 */
    IDE_TEST( qdbCommon::validateAndSetSegStoAttr( sTableType,
                                                   &( sParseTree->tableInfo->segStoAttr ),
                                                   &( sParseTree->segStoAttr ),
                                                   &( sParseTree->existSegStoAttr ),
                                                   ID_TRUE )
              != IDE_SUCCESS );

    if( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        /* 파티션 리스트를 파스트리에 달아놓는다. */
        IDE_TEST( qdbCommon::checkAndSetAllPartitionInfo(
                      aStatement,
                      sParseTree->tableInfo->tableID,
                      &( sParseTree->partTable->partInfoList ) )
                  != IDE_SUCCESS );

        /* PROJ-1624 non-partitioned index */
        IDE_TEST( qdx::makeAndLockIndexTableList(
                      aStatement,
                      ID_FALSE,
                      sParseTree->tableInfo,
                      &( sParseTree->oldIndexTables ) )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_NO_DISK_TABLE )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_NO_DISK_TABLE ) );
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::validateAlterTableAllocExtent( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... ALLOCATE EXTENT ( SIZE .. );
 *    ALTER TABLE ... ALLOCATE EXTENT;
 *
 * Implementation :
 *    1. 테이블 존재 여부 체크
 *    2. 테이블의 소유자가 SYSTEM_ 이면 alter 불가능
 *    3. alter table 권한이 있는지 체크
 *    4. 테이블에 이중화가 걸려있으면 에러
 *    5. 테이블이 디스크 기반 테이블이 아니면 에러
 *
 ***********************************************************************/

    qdTableParseTree * sParseTree = NULL;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    /* ALTER TABLE 구문의 공통적인 validation 수행 - 테이블에 LOCK(IS) */
    IDE_TEST( validateAlterCommon( aStatement, ID_TRUE )
              != IDE_SUCCESS );

    /* BUG-29382 disk table 에만 ALLOCATE EXTENT 를 사용할 수 있다. */
    IDE_TEST_RAISE( smiIsDiskTable( sParseTree->tableInfo->tableHandle ) != ID_TRUE,
                    ERR_NO_DISK_TABLE );

    if( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        /* 파티션 리스트를 파스트리에 달아놓는다. */
        IDE_TEST( qdbCommon::checkAndSetAllPartitionInfo(
                      aStatement,
                      sParseTree->tableInfo->tableID,
                      &( sParseTree->partTable->partInfoList ) )
                  != IDE_SUCCESS );

        /* PROJ-1624 non-partitioned index */
        IDE_TEST( qdx::makeAndLockIndexTableList(
                      aStatement,
                      ID_FALSE,
                      sParseTree->tableInfo,
                      &( sParseTree->oldIndexTables ) )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do. */
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_NO_DISK_TABLE )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_NO_DISK_TABLE ) );
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::validateAlterLobAttributes(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *    PROJ-1362
 *    ALTER TABLE ... ALTER COLUMN LOB ( lob column )
 *      STORE AS ( LOGGING/NOLOGGING/BUFFER/NOBUFFER ) 의 validation 수행
 *
 * Implementation :
 *    1. 테이블 존재 여부 체크
 *    2. 테이블의 소유자가 SYSTEM_ 이면 alter 불가능
 *    3. alter table 권한이 있는지 체크
 *    4. 테이블에 이중화가 걸려있으면 에러
 *    5. alter 하고자 하는 컬럼이 존재하는지 체크
 *    6. Lob컬럼이 아니면 에러
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::validateAlterLobAttributes"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY(""));

    // alter column logging
    qdTableParseTree    * sParseTree;
    qcmColumn           * sColumn;
    qcmColumn           * sLastColumn;
    UInt                  sLobColumnCount = 0;
    qcuSqlSourceInfo      sqlInfo;
    qdPartitionAttribute* sPartAttr;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // ALTER TABLE 구문의 공통적인 validation 수행
    // => 테이블에 LOCK(IS)
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_TRUE )
              != IDE_SUCCESS );

    // check existence of column
    if (sParseTree->lobAttr->columns == NULL)
    {
        for (sLastColumn = sParseTree->tableInfo->columns;
             sLastColumn != NULL;
             sLastColumn = sLastColumn->next)
        {
            if ((sLastColumn->basicInfo->column.flag & SMI_COLUMN_TYPE_MASK)
                == SMI_COLUMN_TYPE_LOB)
            {
                sLobColumnCount++;
            }
            else
            {
                // Nothing to do.
            }
        }

        IDE_TEST_RAISE( sLobColumnCount == 0,
                        ERR_NOT_FOUND_LOB_TYPE_COLUMN );
    }
    else
    {
        for (sLastColumn = sParseTree->lobAttr->columns;
             sLastColumn != NULL;
             sLastColumn = sLastColumn->next)
        {
            IDE_TEST(qcmCache::getColumn(aStatement,
                                         sParseTree->tableInfo,
                                         sLastColumn->namePos,
                                         &sColumn) != IDE_SUCCESS);
            QDB_SET_QCM_COLUMN(sLastColumn, sColumn);

            // check lob column
            if ((sLastColumn->basicInfo->module->flag & MTD_COLUMN_TYPE_MASK)
                != MTD_COLUMN_TYPE_LOB)
            {
                sqlInfo.setSourceInfo(aStatement,
                                      & sLastColumn->namePos);
                IDE_RAISE(ERR_MISMATCHED_LOB_TYPE_COLUMN);
            }
            else
            {
                // Nothing to do.
            }
        }
    }

    // PROJ-1502 PARTITIONED DISK TABLE
    if( sParseTree->tableInfo->tablePartitionType
        == QCM_NONE_PARTITIONED_TABLE )
    {
        IDE_TEST_RAISE( sParseTree->partTable->partAttr != NULL,
                        ERR_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE );
    }
    else
    {
        // nothing to do
    }

    // 각 파티션별 지정한 LOB ATTR에 대한 validation
    for( sPartAttr = sParseTree->partTable->partAttr;
         sPartAttr != NULL;
         sPartAttr = sPartAttr->next )
    {
        // 파티션 이름 validation
        IDE_TEST( qdbCommon::checkPartitionInfo( aStatement,
                                                 sParseTree->tableInfo,
                                                 sPartAttr->tablePartName )
                  != IDE_SUCCESS );

        // check existence of column
        if (sPartAttr->lobAttr->columns == NULL)
        {
            sLobColumnCount = 0;

            for (sLastColumn = sParseTree->tableInfo->columns;
                 sLastColumn != NULL;
                 sLastColumn = sLastColumn->next)
            {
                if ((sLastColumn->basicInfo->column.flag & SMI_COLUMN_TYPE_MASK)
                    == SMI_COLUMN_TYPE_LOB)
                {
                    sLobColumnCount++;
                }
                else
                {
                    // Nothing to do.
                }
            }

            IDE_TEST_RAISE( sLobColumnCount == 0,
                            ERR_NOT_FOUND_LOB_TYPE_COLUMN );
        }
        else
        {
            for (sLastColumn = sPartAttr->lobAttr->columns;
                 sLastColumn != NULL;
                 sLastColumn = sLastColumn->next)
            {
                IDE_TEST(qcmCache::getColumn(aStatement,
                                             sParseTree->tableInfo,
                                             sLastColumn->namePos,
                                             &sColumn) != IDE_SUCCESS);
                QDB_SET_QCM_COLUMN(sLastColumn, sColumn);

                // check lob column
                if ((sLastColumn->basicInfo->module->flag & MTD_COLUMN_TYPE_MASK)
                    != MTD_COLUMN_TYPE_LOB)
                {
                    sqlInfo.setSourceInfo(aStatement,
                                          & sLastColumn->namePos);
                    IDE_RAISE(ERR_MISMATCHED_LOB_TYPE_COLUMN);
                }
                else
                {
                    // Nothing to do.
                }
            }
        }
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_NOT_FOUND_LOB_TYPE_COLUMN)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_NOT_FOUND_LOB_TYPE_COLUMN));
    }
    IDE_EXCEPTION(ERR_MISMATCHED_LOB_TYPE_COLUMN);
    {
        (void)sqlInfo.init(aStatement->qmeMem);
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_MISMATCHED_LOB_TYPE_COLUMN,
                                sqlInfo.getErrMessage()));
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION(ERR_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE));
    }

    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::validateSplitPartition( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *    PROJ-1502 PARTITIONED DISK TABLE
 *
 *    ALTER TABLE tbl_name SPLIT PARTITION src_part
 *        { AT | VALUES } ( split_cond_value, ... )
 *            INTO ( PARTITION dst_part1, PARTITION dst_part2 )
 *    구문의 validation
 *
 *
 * Implementation :
 *      1. ALTER TABLE 구문의 공통적인 validation
 *
 *      2. 파티션드 테이블인지 체크
 *
 *      3. SrcPart 파티션 이름 validation
 *
 *      4. DstPart1과 DstPart2의 테이블스페이스 validation
 *
 *      5. 범위 파티션드 테이블일 경우, 분할 기준 체크
 *          5-1. SPLIT PARTITION ... AT 인지 체크
 *          5-2. 파티션 분할 기준 값의 개수 체크
 *               ( 파티션 키의 개수보다 작거나 같아야 한다.)
 *          5-3. 파티션 분할 기준이 src_part에 속하는지 체크
 *
 *      6. 해시 파티션드 테이블일 경우 에러
 *
 *      7. 리스트 파티션드 테이블일 경우 에러
 *          7-1. SPLIT PARTITION ... VALUES 인지 체크
 *          7-2. 파티션 분할 기준이 src_part에 속하는지 체크
 *
 *      8. ACCESS 가능 테이블 타입 검사
 *
 *      9. DstPart1, DstPart2의 파티션 이름 validation
 *
 *     10. In-place Split인지 Out-place Split인지 판단
 *
 ***********************************************************************/

    qdTableParseTree        * sParseTree;
    qcmTableInfo            * sTableInfo;
    qdPartitionAttribute    * sSrcPartAttr;
    qdPartitionAttribute    * sDstPartAttr;
    qdPartitionAttribute    * sDstPartAttr2;
    qmmValueNode            * sNode;
    UInt                      sSplitCount;
    qcmTableInfo            * sPartitionInfo;
    smSCN                     sPartitionSCN;
    void                    * sPartitionHandle;
    qcuSqlSourceInfo          sqlInfo;
    qcmColumn               * sTargetColumn;
    qcmColumn               * sTableColumn;
    idBool                    sIsDefaultTBS;
    UInt                      i;

    qdIndexPartitionAttribute * sIndexPartAttr = NULL;
    qdIndexPartitionAttribute * sTempAttr = NULL;
    qdIndexPartitionAttribute * sTempAttr2 = NULL;
    qdIndexPartitionAttribute * sFirstAttr = NULL;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // ------------------------------------------------------
    // 1. ALTER TABLE 구문의 공통적인 validation
    // ------------------------------------------------------
    // 파티션드 테이블에 LOCK(IS)
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_FALSE )
              != IDE_SUCCESS );

    sTableInfo = sParseTree->tableInfo;

    // ------------------------------------------------------
    // 2. 파티션드 테이블인지 체크
    // ------------------------------------------------------
    IDE_TEST_RAISE( sTableInfo->tablePartitionType
                    == QCM_NONE_PARTITIONED_TABLE,
                    ERR_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE );

    sSrcPartAttr = sParseTree->partTable->partAttr;

    // ------------------------------------------------------
    // 3. SrcPart 파티션 이름 validation
    // ------------------------------------------------------
    IDE_TEST( qdbCommon::checkPartitionInfo( aStatement,
                                             sTableInfo,
                                             sSrcPartAttr->tablePartName )
              != IDE_SUCCESS );

    sPartitionInfo = sParseTree->partTable->partInfoList->partitionInfo;

    if ( ( QCG_GET_SESSION_LOCK_TABLE_UNTIL_NEXT_DDL( aStatement ) == ID_TRUE ) &&
         ( QCG_GET_SESSION_TABLE_ID_OF_LOCK_TABLE_UNTIL_NEXT_DDL( aStatement ) == sTableInfo->tableID ) )
    {
        if ( sPartitionInfo->replicationCount > 0 )
        {
            IDE_TEST( qci::mValidateReplicationCallback.mValidateAlterPartition( aStatement,
                                                                                 sPartitionInfo )
                      != IDE_SUCCESS );
        }
        else
        {
            /* Nothing to do */
        }
    }
    else
    {
        IDE_TEST_RAISE( sPartitionInfo->replicationCount > 0 ,
                        ERR_DDL_WITH_REPLICATED_PARTITION );
    }

    // ------------------------------------------------------
    // 3.5 non-partitioned index의 리스트를 얻는다.
    // ------------------------------------------------------
    // PROJ-1624 non-partitioned index
    IDE_TEST( qdx::makeAndLockIndexTableList( aStatement,
                                              ID_FALSE,
                                              sParseTree->tableInfo,
                                              &(sParseTree->oldIndexTables) )
              != IDE_SUCCESS );
    
    // ------------------------------------------------------
    // SrcPart의 min_value, max_value를
    // qmsPartCondValList, qmmValueNode로 만들어서 파스트리에 달아놓는다.
    // ------------------------------------------------------
    IDE_TEST( qdbCommon::makePartCondValList( aStatement,
                                              sTableInfo,
                                              sPartitionInfo->partitionID,
                                              sSrcPartAttr )
              != IDE_SUCCESS );

    // ------------------------------------------------------
    // 4. DstPart1과 DstPart2의 테이블스페이스 validation
    // ------------------------------------------------------
    for( sDstPartAttr = sSrcPartAttr->next;
         sDstPartAttr != NULL;
         sDstPartAttr = sDstPartAttr->next )
    {
        // validation of 각 파티션의 TABLESPACE
        IDE_TEST( qdbCommon::validateTBSOfPartition( aStatement, sDstPartAttr )
                  != IDE_SUCCESS );

        /* PROJ-2639 Altibase Disk Edition */
#ifdef ALTI_CFG_EDITION_DISK
        if ( sTableInfo->tableOwnerID == QC_SYSTEM_USER_ID )
        {
            /* Nothing to do */
        }
        else
        {
            IDE_TEST_RAISE( smiTableSpace::isDiskTableSpaceType( sDstPartAttr->TBSAttr.mType ) == ID_FALSE,
                            ERR_NOT_SUPPORT_MEMORY_VOLATILE_TABLESPACE_IN_DISK_EDITION );
        }
#endif

        /* PROJ-2464 hybrid partitioned table 지원 */
        IDE_TEST( validateTablespaceRestriction( sTableInfo, sDstPartAttr->TBSAttr.mType )
                  != IDE_SUCCESS );

        // IN-PLACE에서 TABLESPACE가 명시되지 않은 경우는 기존 파티션의
        // TBS를 따른다.
        // OUT-PLACE의 경우는 파티션드 테이블의 TBS를 따르며, 만약 사용자가 명시적으로
        // 지정한 TBS가 있다면 해당 TBS를 따른다.
        if( ( QC_IS_NAME_MATCHED( sDstPartAttr->tablePartName, sSrcPartAttr->tablePartName ) == ID_FALSE ) ||
            ( QC_IS_NULL_NAME( sDstPartAttr->TBSName ) == ID_FALSE ) ||
            ( sDstPartAttr->lobAttr != NULL ) )
        {
            sDstPartAttr->columns  = NULL;

            /* PROJ-2464 hybrid partitioned table 지원 */
            IDE_TEST( qdbCommon::copyAndAdjustColumnList( aStatement,
                                                          sTableInfo->TBSType,
                                                          sDstPartAttr->TBSAttr.mType,
                                                          sTableInfo->columns,
                                                          &(sDstPartAttr->columns),
                                                          sTableInfo->columnCount,
                                                          ID_FALSE /* aEnableVariableColumn */ )
                      != IDE_SUCCESS );

            for( i = 0, sTableColumn = sTableInfo->columns, sTargetColumn = sDstPartAttr->columns;
                 sTableColumn != NULL ;
                 i++, sTableColumn = sTableColumn->next, sTargetColumn = sTargetColumn->next )
            {

                if ( (sTableColumn->basicInfo->module->flag &
                      MTD_COLUMN_TYPE_MASK)
                     == MTD_COLUMN_TYPE_LOB )
                {
                    /* 파티션드 테이블의 LOB COLUMN TBS 지정 여부 */
                    IDE_TEST( qcm::getIsDefaultTBS(
                                  aStatement,
                                  sTableInfo->tableID,
                                  (sTableInfo->tableID * SMI_COLUMN_ID_MAXIMUM) + i,
                                  & sIsDefaultTBS )
                              != IDE_SUCCESS );

                    /* PROJ-2464 hybrid partitioned table 지원
                     *  - Disk Partition의 경우, Partitioned의 Lob Column TBS(Default TBS)가
                     *    지정되어 있으면 Default TBS를 사용한다.
                     *  - PROJ-2334 PMT MEMORY PARTITIONED TABLE : Memory Partition의 경우,
                     *    Partition TBS를 사용한다.
                     */
                    /* PROJ-2465 Tablespace Alteration for Table
                     *  - 부족한 Default TBS 처리를 추가한다.
                     */
                    if ( ( sIsDefaultTBS == ID_TRUE ) &&
                         ( smiTableSpace::isDiskTableSpaceType( sDstPartAttr->TBSAttr.mType ) == ID_TRUE ) &&
                         ( smiTableSpace::isDiskTableSpaceType( sTableInfo->TBSType ) == ID_TRUE ) )
                    {
                        /* Create시 ColSpace에 설정된 Default TBS를 그대로 이용한다. */
                        /* Nothing to do */
                    }
                    else
                    {
                        sTargetColumn->basicInfo->column.colSpace = sDstPartAttr->TBSAttr.mID;
                    }
                }
                else
                {
                    sTargetColumn->basicInfo->column.colSpace = sDstPartAttr->TBSAttr.mID;
                }
            } // for
        } // if
        else
        {
            // IN-PLACE SPLIT
            sDstPartAttr->columns  = NULL;
            IDE_TEST( qcm::copyQcmColumns( QC_QMP_MEM(aStatement),
                                           sPartitionInfo->columns,
                                           &(sDstPartAttr->columns ),
                                           sPartitionInfo->columnCount )
                      != IDE_SUCCESS );
        }

        IDE_TEST(qdbCommon::validateLobAttributeList( aStatement,
                                                      sTableInfo,
                                                      sDstPartAttr->columns,
                                                      &(sDstPartAttr->TBSAttr),
                                                      sDstPartAttr->lobAttr )
                 != IDE_SUCCESS);
    }

    sSrcPartAttr = sParseTree->partTable->partAttr;

    // PROJ-1579 NCHAR
    // 각 파티션의 nchar literal의 list를 만들어 놓는다.
    IDE_TEST( qdbCommon::makeNcharLiteralStr( aStatement,
                                              sParseTree->ncharList,
                                              sSrcPartAttr )
              != IDE_SUCCESS );

    // ------------------------------------------------------
    // 5. 범위 파티션드 테이블일 경우, 분할 기준 값 체크
    // ------------------------------------------------------
    if( sTableInfo->partitionMethod == QCM_PARTITION_METHOD_RANGE )
    {
        sSplitCount = 0;

        for( sNode = sSrcPartAttr->partKeyCond;
             sNode != NULL;
             sNode = sNode->next )
        {
            sSplitCount++;
        }

        // ------------------------------------------------------
        // 5-1. 범위 파티션드 테이블은
        //      SPLIT PARTITION ... AT 이어야 한다.
        // ------------------------------------------------------
        IDE_TEST_RAISE( sSrcPartAttr->alterPart->alterType !=
                        QD_SPLIT_RANGE_PARTITION,
                        ERR_SPLIT_AT_ON_RANGE_PART_TABLE );

        // ------------------------------------------------------
        // 5-2. 파티션 분할 기준 값의 개수 체크
        //      ( 파티션 키의 개수보다 작거나 같아야 한다.)
        // ------------------------------------------------------
        IDE_TEST_RAISE( sTableInfo->partKeyColCount < sSplitCount,
                        ERR_TOO_MANY_SPLIT_COND_VALUE_COUNT );

        // ------------------------------------------------------
        // 5-3. 파티션 분할 기준이 src_part에 속하는지 체크
        // ------------------------------------------------------
        IDE_TEST( qdbCommon::checkSplitCond( aStatement,
                                             sParseTree )
                  != IDE_SUCCESS );
    }
    // ------------------------------------------------------
    // 6. 해시 파티션드 테이블일 경우, 에러
    // ------------------------------------------------------
    else if( sTableInfo->partitionMethod == QCM_PARTITION_METHOD_HASH )
    {
        IDE_RAISE( ERR_SPLIT_PARTITION_ON_HASH_PART_TABLE );
    }
    // ------------------------------------------------------
    // 7. 리스트 파티션드 테이블일 경우, 분할 기준 값 체크
    // ------------------------------------------------------
    else if( sTableInfo->partitionMethod == QCM_PARTITION_METHOD_LIST )
    {
        // ------------------------------------------------------
        // 7-1. 리스트 파티션드 테이블은
        //      SPLIT PARTITION ... VALUES 이어야 한다.
        // ------------------------------------------------------
        IDE_TEST_RAISE( sSrcPartAttr->alterPart->alterType != QD_SPLIT_LIST_PARTITION,
                        ERR_SPLIT_VALUES_ON_LIST_PART_TABLE );

        // ------------------------------------------------------
        // 7-2. 파티션 분할 값이 src_part에 속하는지 체크
        // ------------------------------------------------------
        IDE_TEST( qdbCommon::checkSplitCond( aStatement,
                                             sParseTree )
                  != IDE_SUCCESS );
    }
    else
    {
        // Nothing to do
    }

    // SrcPart, DstPart 다시 가져옴
    sSrcPartAttr = sParseTree->partTable->partAttr;
    sDstPartAttr = sParseTree->partTable->partAttr->next;
    sDstPartAttr2 = sParseTree->partTable->partAttr->next->next;

    /* PROJ-2464 hybrid partitioned table 지원 */
    // qdbCommon::getTableTypeCountInPartAttrList()를 사용하기 위해, Src, Dst Partition List를 잠시 분리한다.
    sSrcPartAttr->next = NULL;
    IDE_TEST( validateTableReferenceForPartitions( aStatement,
                                                   sTableInfo,
                                                   sSrcPartAttr,
                                                   sDstPartAttr )
              != IDE_SUCCESS );
    sSrcPartAttr->next = sDstPartAttr;

    // ------------------------------------------------------
    // 8. ACCESS 가능 테이블 타입 검사
    // ------------------------------------------------------
    /* PROJ-2359 Table/Partition Access Option */
    IDE_TEST_RAISE( ( sTableInfo->tableType == QCM_MVIEW_TABLE ) &&
                    ( ( sDstPartAttr->accessOption != QCM_ACCESS_OPTION_NONE ) ||
                      ( sDstPartAttr2->accessOption != QCM_ACCESS_OPTION_NONE ) ),
                    ERR_ACCESS_NOT_SUPPORT_MVIEW );

    // ------------------------------------------------------
    // 9. DstPart1과 DstPart2의 이름 validation
    // ------------------------------------------------------
    if ( QC_IS_NAME_MATCHED( sDstPartAttr->tablePartName, sDstPartAttr2->tablePartName ) )
    {
        sqlInfo.setSourceInfo(aStatement,
                              & sDstPartAttr2->tablePartName );
        IDE_RAISE( ERR_DUPLICATE_PARTITION_NAME );
    }

    // ------------------------------------------------------
    // 10. In-place Split인지 Out-place Split인지 결정
    // ------------------------------------------------------
    if ( QC_IS_NAME_MATCHED( sSrcPartAttr->tablePartName, sDstPartAttr->tablePartName ) )
    {
        if( (QC_IS_NULL_NAME( sDstPartAttr->TBSName ) == ID_TRUE) &&
            (sDstPartAttr->lobAttr == NULL) &&
            (sDstPartAttr->alterPart->indexPartAttr == NULL) )
        {
            sSrcPartAttr->alterPart->splitMergeType =
                QD_ALTER_PARTITION_LEFT_INPLACE_TYPE;
        }
        else
        {
            sSrcPartAttr->alterPart->splitMergeType =
                QD_ALTER_PARTITION_OUTPLACE_TYPE;
        }
    }
    else if ( QC_IS_NAME_MATCHED( sSrcPartAttr->tablePartName, sDstPartAttr2->tablePartName ) )
    {
        if( (QC_IS_NULL_NAME( sDstPartAttr2->TBSName ) == ID_TRUE) &&
            (sDstPartAttr2->lobAttr == NULL) &&
            (sDstPartAttr2->alterPart->indexPartAttr == NULL) )
        {
            sSrcPartAttr->alterPart->splitMergeType =
                QD_ALTER_PARTITION_RIGHT_INPLACE_TYPE;
        }
        else
        {
            sSrcPartAttr->alterPart->splitMergeType =
                QD_ALTER_PARTITION_OUTPLACE_TYPE;
        }
    }
    else
    {
        sSrcPartAttr->alterPart->splitMergeType =
            QD_ALTER_PARTITION_OUTPLACE_TYPE;
    }

    // Left In-place 일 경우
    // DstPart2의 이름과 같은 이름의 파티션이 있는지 체크
    if( sSrcPartAttr->alterPart->splitMergeType ==
        QD_ALTER_PARTITION_LEFT_INPLACE_TYPE )
    {
        if( qcmPartition::getPartitionInfo( aStatement,
                                            sTableInfo->tableID,
                                            sDstPartAttr2->tablePartName,
                                            & sPartitionInfo,
                                            & sPartitionSCN,
                                            & sPartitionHandle )
            == IDE_SUCCESS )
        {
            sqlInfo.setSourceInfo(aStatement,
                                  & sDstPartAttr2->tablePartName );
            IDE_RAISE( ERR_ALREADY_EXIST_PARTITION_NAME );
        }
    }
    // Right In-place 일 경우
    // DstPart1의 이름과 같은 이름의 파티션이 있는지 체크
    else if( sSrcPartAttr->alterPart->splitMergeType ==
             QD_ALTER_PARTITION_RIGHT_INPLACE_TYPE )
    {
        if( qcmPartition::getPartitionInfo( aStatement,
                                            sTableInfo->tableID,
                                            sDstPartAttr->tablePartName,
                                            & sPartitionInfo,
                                            & sPartitionSCN,
                                            & sPartitionHandle )
            == IDE_SUCCESS )
        {
            sqlInfo.setSourceInfo(aStatement,
                                  & sDstPartAttr->tablePartName );
            IDE_RAISE( ERR_ALREADY_EXIST_PARTITION_NAME );
        }
    }
    // Out-place 일 경우
    // DstPart1 또는 DstPart2의 이름과 같은 이름의 파티션이 있는지 체크
    else if( sSrcPartAttr->alterPart->splitMergeType ==
             QD_ALTER_PARTITION_OUTPLACE_TYPE )
    {
        if ( QC_IS_NAME_MATCHED( sSrcPartAttr->tablePartName, sDstPartAttr->tablePartName ) == ID_FALSE )
        {
            if( qcmPartition::getPartitionInfo( aStatement,
                                                sTableInfo->tableID,
                                                sDstPartAttr->tablePartName,
                                                & sPartitionInfo,
                                                & sPartitionSCN,
                                                & sPartitionHandle )
                == IDE_SUCCESS )
            {
                sqlInfo.setSourceInfo(aStatement,
                                      & sDstPartAttr->tablePartName );
                IDE_RAISE( ERR_ALREADY_EXIST_PARTITION_NAME );
            }
        }
        else
        {
            // SrcPart와 DstPart1의 이름이 같을 때는 체크하지 않는다.
            // Nothing to do
        }

        if ( QC_IS_NAME_MATCHED( sSrcPartAttr->tablePartName, sDstPartAttr2->tablePartName ) == ID_FALSE )
        {
            if( qcmPartition::getPartitionInfo( aStatement,
                                                sTableInfo->tableID,
                                                sDstPartAttr2->tablePartName,
                                                & sPartitionInfo,
                                                & sPartitionSCN,
                                                & sPartitionHandle )
                == IDE_SUCCESS )
            {
                sqlInfo.setSourceInfo(aStatement,
                                      & sDstPartAttr2->tablePartName );
                IDE_RAISE( ERR_ALREADY_EXIST_PARTITION_NAME );
            }
        }
        else
        {
            // SrcPart와 DstPart2의 이름이 같을 때는 체크하지 않는다.
            // Nothing to do
        }
    }
    else
    {
        // Nothing to do
    }


    // ------------------------------------------------------
    // 인덱스 파티션을 지정한 경우의 validation
    // ------------------------------------------------------

    // DstPartAttr, DstPartAttr2의 IndexAttr을 같이 체크하기 위해
    // 하나의 리스트로 변경
    for( sDstPartAttr = sParseTree->partTable->partAttr->next;
         sDstPartAttr != NULL;
         sDstPartAttr = sDstPartAttr->next )
    {
        if ( sDstPartAttr->alterPart->indexPartAttr != NULL )
        {
            for ( sIndexPartAttr = sDstPartAttr->alterPart->indexPartAttr;
                  sIndexPartAttr != NULL;
                  sIndexPartAttr = sIndexPartAttr->next )
            {
                IDU_LIMITPOINT("qdbAlter::validateSplitPartition::malloc");
                IDE_TEST(STRUCT_ALLOC(QC_QMP_MEM(aStatement),
                                      qdIndexPartitionAttribute,
                                      & sTempAttr2)
                         != IDE_SUCCESS);

                idlOS::memcpy( sTempAttr2,
                               sIndexPartAttr,
                               ID_SIZEOF(qdIndexPartitionAttribute) );

                if (sFirstAttr == NULL)
                {
                    sTempAttr2->next = NULL;
                    sFirstAttr = sTempAttr2;
                }
                else
                {
                    sTempAttr2->next = sFirstAttr;
                    sFirstAttr = sTempAttr2;
                }
            }
        }
        else
        {
            /* Nothing to do */
        }
    }

    // 파티션드 인덱스, 인덱스 파티션의 이름을 모두 같게 지정한 경우 에러
    for( sTempAttr2 = sFirstAttr;
         sTempAttr2 != NULL;
         sTempAttr2 = sTempAttr2->next )
    {
        for( sTempAttr = sFirstAttr;
             sTempAttr != sTempAttr2;
             sTempAttr = sTempAttr->next )
        {
            if ( QC_IS_NAME_MATCHED( sTempAttr2->partIndexName, sTempAttr->partIndexName ) &&
                 QC_IS_NAME_MATCHED( sTempAttr2->indexPartName, sTempAttr->indexPartName ) )
            {
                sqlInfo.setSourceInfo( aStatement, &sTempAttr2->indexPartName );
                IDE_RAISE( ERR_DUPLICATE_PARTITION_NAME );
            }
            else
            {
                // Nothing to do.
            }
        }
    }

    // DstPart1, DstPart2 차례대로 validation
    for( sDstPartAttr = sParseTree->partTable->partAttr->next;
         sDstPartAttr != NULL;
         sDstPartAttr = sDstPartAttr->next )
    {
        /* PROJ-2464 hybrid partitioned table 지원 */
        IDE_TEST( validateIndexAlterationForPartition( aStatement,
                                                       sTableInfo,
                                                       sPartitionInfo,
                                                       sDstPartAttr )
                  != IDE_SUCCESS );

        if ( sDstPartAttr->alterPart->indexPartAttr != NULL )
        {
            IDE_TEST( checkIndexPartAttrList( aStatement,
                                              sTableInfo,
                                              sPartitionInfo,
                                              sSrcPartAttr,
                                              sDstPartAttr,
                                              sParseTree->userID )
                      != IDE_SUCCESS );
        }
        else
        {
            // Nothing to do
        }
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_DDL_WITH_REPLICATED_PARTITION )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_DDL_WITH_REPLICATED_PART ) );
    }
    IDE_EXCEPTION(ERR_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE));
    }
    IDE_EXCEPTION(ERR_SPLIT_AT_ON_RANGE_PART_TABLE );
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_INVALID_PART_TABLE_METHOD_FOR_SPLIT_PARTITION_AT));
    }
    IDE_EXCEPTION(ERR_SPLIT_VALUES_ON_LIST_PART_TABLE );
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_INVALID_PART_TABLE_METHOD_FOR_SPLIT_PARTITION_VALUES));
    }
    IDE_EXCEPTION(ERR_TOO_MANY_SPLIT_COND_VALUE_COUNT);
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_TOO_MANY_SPLIT_CONDITION_VALUE));
    }
    IDE_EXCEPTION(ERR_SPLIT_PARTITION_ON_HASH_PART_TABLE);
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_SPLIT_HASH_PART_TABLE));
    }
    IDE_EXCEPTION(ERR_DUPLICATE_PARTITION_NAME)
    {
        (void)sqlInfo.init(aStatement->qmeMem);
        IDE_SET(ideSetErrorCode( qpERR_ABORT_QDB_DUPLICATE_PARTITION_NAME,
                                 sqlInfo.getErrMessage()) );
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION(ERR_ALREADY_EXIST_PARTITION_NAME)
    {
        (void)sqlInfo.init(aStatement->qmeMem);
        IDE_SET(ideSetErrorCode( qpERR_ABORT_QDB_ALREADY_EXIST_PARTITION_NAME,
                                 sqlInfo.getErrMessage()) );
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION( ERR_ACCESS_NOT_SUPPORT_MVIEW );
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDM_ACCESS_NOT_SUPPORT_MVIEW ) );
    }
#ifdef ALTI_CFG_EDITION_DISK
    IDE_EXCEPTION( ERR_NOT_SUPPORT_MEMORY_VOLATILE_TABLESPACE_IN_DISK_EDITION );
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_USE_ONLY_DISK_TABLE_PARTITION_IN_DISK_EDITION ) );
    }
#endif
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::validateReorganizeCol( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description : PROJ-2264 Dictionary table
 *    ALTER TABLE ... REORGANIZE COLUMN ... 의 validation 수행
 *
 * Implementation :
 *    1. 존재하는 테이블인지 체크
 *    2. ALTER 하려는 테이블이 메타 테이블이면 에러 반환
 *    3. ALTER TABLE 권한이 있는지 체크
 *    4. 명시한 컬럼이 compression column 인지 체크
 *
 ***********************************************************************/

    qdTableParseTree    * sParseTree;
    qcmColumn           * sParseColumn;
    qcmColumn           * sColumn;
    qcmTableInfo        * sTableInfo;
    qcuSqlSourceInfo      sqlInfo;
    UInt                  sColumnCount = 0;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // ALTER TABLE 구문의 공통적인 validation 수행
    // => 테이블에 LOCK(IS)
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_FALSE )
              != IDE_SUCCESS );

    sTableInfo = sParseTree->tableInfo;

    // PROJ-2429 Dictionary based data compress for on-disk DB 
    // volatile table 은 허용하지 않는다.
    IDE_TEST_RAISE( smiTableSpace::isVolatileTableSpaceType( sTableInfo->TBSType ) == ID_TRUE,
                    ERR_NOT_SUPPORTED_TABLESPACE_TYPE );

    sParseColumn = sParseTree->columns;

    while ( sParseColumn != NULL )
    {
        // check column existence
        IDE_TEST(qcmCache::getColumn(aStatement,
                                     sTableInfo,
                                     sParseColumn->namePos,
                                     &sColumn) != IDE_SUCCESS);
        QDB_SET_QCM_COLUMN(sParseColumn, sColumn);

        // Compression column 인지 체크
        if ( ( sColumn->basicInfo->column.flag & SMI_COLUMN_COMPRESSION_MASK )
             == SMI_COLUMN_COMPRESSION_FALSE )
        {
            sqlInfo.setSourceInfo( aStatement, &(sParseColumn->namePos) );
            IDE_RAISE( ERR_REORGANIZE_COMPRESSION_COLUMN );
        }

        // column name을 설정한다.
        idlOS::strncpy( sParseColumn->name,
                        sColumn->name,
                        QC_MAX_OBJECT_NAME_LEN + 1 );
        sParseColumn->name[QC_MAX_OBJECT_NAME_LEN] = '\0';

        sColumnCount++;
        sParseColumn = sParseColumn->next;
    }

    /* BUG-42759 Meta Table Cache를 수정하면 안 됩니다.
     *  1. qcmCache::getColumn()으로 Meta Table Cach의 Column을 가져옵니다.
     *  2. QDB_SET_QCM_COLUMN()으로 Column의 Pointer를 sParseTree->columns에 복사합니다.
     *  3. qcmDictionary::recreateDictionaryTable()에서, sParseTree->columns를 통해 Meta Table Cache를 수정합니다.
     *
     *  sParseTree->columns를 복제하여, Meta Table Cache가 수정되지 않도록 합니다.
     */
    IDE_TEST( qcm::copyQcmColumns( QC_QMP_MEM( aStatement ),
                                   sParseTree->columns,
                                   &sParseColumn,
                                   sColumnCount )
              != IDE_SUCCESS );

    sParseTree->columns = sParseColumn;

    IDE_TEST_RAISE( sTableInfo->replicationCount > 0, ERR_REORGANIZE_REPL_TABLE );

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_NOT_SUPPORTED_TABLESPACE_TYPE)
    {    
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_COMPRESSION_NOT_SUPPORTED_TABLESPACE ) ); 
    }
    IDE_EXCEPTION( ERR_REORGANIZE_COMPRESSION_COLUMN );
    {
        (void)sqlInfo.init( aStatement->qmeMem );
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_CANNOT_ALTER_REORGANIZE_COMPRESSION_COLUMN,
                                  sqlInfo.getErrMessage() ) );
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION( ERR_REORGANIZE_REPL_TABLE );
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_CANNOT_ALTER_REORGANIZE_COMPRESSION_COL_WITH_REPLICATED_TBL ) );
    }

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::checkIndexPartAttrList(
    qcStatement             * aStatement,
    qcmTableInfo            * aTableInfo,
    qcmTableInfo            * aSrcPartInfo,
    qdPartitionAttribute    * aSrcPartAttr,
    qdPartitionAttribute    * aNewPartAttr,
    UInt                      aUserID)
{
/***********************************************************************
 *
 * Description :
 *    PROJ-1502
 *
 *    ALTER TABLE SPLIT PARTITION
 *                MERGE PARTITIONS
 *                ADD PARTITION 구문에서,
 *
 *    인덱스 파티션을 명시할 경우, validation하기 위해 사용된다.
 *
 * Implementation :
 *
 *
 *
 ***********************************************************************/

    qcuSqlSourceInfo          sqlInfo;
    UInt                      sIndexCount;
    UInt                      sCount = 0;
    qcmIndex                * sIndex;
    idBool                    sIsFound = ID_FALSE;
    // TASK-3876 Code Sonar, warning 제거위해 0으로 정의
    UInt                      sPartIndexIDFromName = 0;
    UInt                      sPartIndexIDFromIndexPart = 0;
    SChar                     sIndexPartName[QC_MAX_OBJECT_NAME_LEN + 1];

    qdIndexPartitionAttribute * sIndexPartAttr = NULL;
    qdIndexPartitionAttribute * sTempAttr      = NULL;

    // 해당 테이블이 지정한 인덱스를 갖고 있는지 체크
    for ( sIndexPartAttr = aNewPartAttr->alterPart->indexPartAttr;
          sIndexPartAttr != NULL;
          sIndexPartAttr = sIndexPartAttr->next )
    {
        sIsFound = ID_FALSE;

        for ( sIndexCount = 0;
              sIndexCount < aTableInfo->indexCount;
              sIndexCount++ )
        {
            sIndex = & aTableInfo->indices[sIndexCount];

            // index attribute는 partitined index만 설정할 수 있다.
            if( ( sIndex->indexPartitionType != QCM_NONE_PARTITIONED_INDEX )
                &&
                ( idlOS::strMatch(sIndex->name,
                                  idlOS::strlen(sIndex->name),
                                  sIndexPartAttr->partIndexName.stmtText +
                                  sIndexPartAttr->partIndexName.offset,
                                  sIndexPartAttr->partIndexName.size) == 0 ) )
            {
                sIsFound = ID_TRUE;
                break;
            }
        }

        if( sIsFound == ID_FALSE )
        {
            break;
        }
    }

    if( sIsFound == ID_FALSE )
    {
        sqlInfo.setSourceInfo(aStatement,
                              & sIndexPartAttr->partIndexName );
        IDE_RAISE( ERR_NOT_EXIST_PARTITIONED_INDEX );
    }

    // ------------------------------------------------------------
    // 지정한 인덱스 파티션 개수만큼 반복하며 validation
    // ------------------------------------------------------------
    for ( sIndexPartAttr = aNewPartAttr->alterPart->indexPartAttr;
          sIndexPartAttr != NULL;
          sIndexPartAttr = sIndexPartAttr->next )
    {
        // ------------------------------------------------------------
        // 이름 중복 검사
        // ------------------------------------------------------------
        for ( sTempAttr = aNewPartAttr->alterPart->indexPartAttr;
              sTempAttr != sIndexPartAttr;
              sTempAttr = sTempAttr->next )
        {
            // 파티션드 인덱스 이름 중복 검사
            if ( QC_IS_NAME_MATCHED( sIndexPartAttr->partIndexName, sTempAttr->partIndexName ) )
            {
                sqlInfo.setSourceInfo(aStatement,
                                      & sIndexPartAttr->partIndexName );
                IDE_RAISE( ERR_DUPLICATED_PARTITIONED_INDEX );
            }

            // 인덱스 파티션 이름 중복 검사
            if ( QC_IS_NAME_MATCHED( sIndexPartAttr->indexPartName, sTempAttr->indexPartName ) )
            {
                sqlInfo.setSourceInfo(aStatement,
                                      & sIndexPartAttr->indexPartName);
                IDE_RAISE( ERR_DUPLICATE_PARTITION_NAME );
            }
        }

        // ADD PARTITION일 경우 제외
        if( aSrcPartInfo != NULL )
        {
            for( sIndexCount = 0;
                 sIndexCount < aSrcPartInfo->indexCount;
                 sIndexCount++ )
            {
                sIndex = & aSrcPartInfo->indices[sIndexCount];

                // SrcPart로 파티션드 인덱스 ID 찾기
                if( idlOS::strMatch(sIndex->name,
                                    idlOS::strlen(sIndex->name),
                                    sIndexPartAttr->indexPartName.stmtText +
                                    sIndexPartAttr->indexPartName.offset,
                                    sIndexPartAttr->indexPartName.size)
                    == 0 )
                {
                    sPartIndexIDFromIndexPart = sIndex->indexId;
                    break;
                }
            }
        }

        for( sIndexCount = 0;
             sIndexCount < aTableInfo->indexCount;
             sIndexCount++ )
        {
            sIndex = & aTableInfo->indices[sIndexCount];

            // 지정한 파티션드 인덱스 이름으로 ID 찾기
            if( idlOS::strMatch(sIndex->name,
                                idlOS::strlen(sIndex->name),
                                sIndexPartAttr->partIndexName.stmtText +
                                sIndexPartAttr->partIndexName.offset,
                                sIndexPartAttr->partIndexName.size)
                == 0 )
            {
                sPartIndexIDFromName = sIndex->indexId;
                break;
            }
        }

        // 같은 이름의 인덱스 파티션이
        // 해당 테이블 파티션에 이미 있는지 체크
        // SrcPart와 DstPart의 이름이 같을 경우에만
        // 인덱스 파티션의 이름을 예전과 같게 지정할 수 있다.
        if ( ( aSrcPartAttr != NULL ) &&
             QC_IS_NAME_MATCHED( aSrcPartAttr->tablePartName, aNewPartAttr->tablePartName ) )
        {
            // 기존 인덱스 파티션과 동일한 이름을 사용한 경우에는 에러아님
            if( sPartIndexIDFromName != sPartIndexIDFromIndexPart )
            {
                sqlInfo.setSourceInfo(aStatement,
                                      & sIndexPartAttr->indexPartName);
                IDE_RAISE( ERR_INVALID_INDEX_PARTITION_NAME );
            }
        }
        // SrcPart와 DstPart의 이름이 다르다면
        // 명시한 파티션드 인덱스, 인덱스 파티션의 이름이 이미
        // SYS_INDEX_PARTITIONS_에 있으면 에러
        else
        {
            QC_STR_COPY( sIndexPartName, sIndexPartAttr->indexPartName );

            IDE_TEST( qcmPartition::getIndexPartitionCount(
                          aStatement,
                          sPartIndexIDFromName,
                          sIndexPartName,
                          idlOS::strlen( sIndexPartName ),
                          & sCount )
                      != IDE_SUCCESS );

            if( sCount != 0 )
            {
                sqlInfo.setSourceInfo(aStatement,
                                      & sIndexPartAttr->indexPartName);
                IDE_RAISE( ERR_ALREADY_EXIST_INDEX_PARTITION_NAME );
            }
        }

        // ------------------------------------------------------------
        // 테이블 스페이스 validation
        // ------------------------------------------------------------
        IDE_TEST( qdtCommon::getAndValidateTBSOfIndexPartition(
                      aStatement,
                      aNewPartAttr->TBSAttr.mID,
                      aNewPartAttr->TBSAttr.mType,
                      sIndexPartAttr->TBSName,
                      aUserID,
                      & sIndexPartAttr->TBSAttr.mID,
                      & sIndexPartAttr->TBSAttr.mType )
                  != IDE_SUCCESS );
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_DUPLICATE_PARTITION_NAME);
    {
        (void)sqlInfo.init(aStatement->qmeMem);
        IDE_SET(ideSetErrorCode( qpERR_ABORT_QDB_DUPLICATE_PARTITION_NAME,
                                 sqlInfo.getErrMessage()) );
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION(ERR_DUPLICATED_PARTITIONED_INDEX);
    {
        (void)sqlInfo.init(aStatement->qmeMem);
        IDE_SET(ideSetErrorCode( qpERR_ABORT_QDB_DUP_PARTITIONED_INDEX_NAME,
                                 sqlInfo.getErrMessage()) );
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION(ERR_NOT_EXIST_PARTITIONED_INDEX);
    {
        (void)sqlInfo.init(aStatement->qmeMem);
        IDE_SET(ideSetErrorCode( qpERR_ABORT_QDB_NOT_EXIST_PARTITIONED_INDEX,
                                 sqlInfo.getErrMessage()) );
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION(ERR_INVALID_INDEX_PARTITION_NAME);
    {
        (void)sqlInfo.init(aStatement->qmeMem);
        IDE_SET(ideSetErrorCode( qpERR_ABORT_QDB_INVALID_INDEX_PARTITION_NAME,
                                 sqlInfo.getErrMessage()) );
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION(ERR_ALREADY_EXIST_INDEX_PARTITION_NAME);
    {
        (void)sqlInfo.init(aStatement->qmeMem);
        IDE_SET(ideSetErrorCode( qpERR_ABORT_QDB_ALREADY_EXIST_INDEX_PARTITION_NAME,
                                 sqlInfo.getErrMessage()) );
        (void)sqlInfo.fini();
    }

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::validateMergePartition(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *    PROJ-1502 PARTITIONED DISK TABLE
 *    ALTER TABLE ... MERGE PARTITIONS ... 구문의 validation 수행
 *
 *    ALTER TABLE tbl_name MERGE PARTITIONS src_part1, src_part2
 *            INTO PARTITION dst_part
 *    구문의 validation
 *
 *
 * Implementation :
 *      1. ALTER TABLE 구문의 공통적인 validation 수행
 *      2. 파티션드 테이블인지 체크
 *      3. 해시 파티션드 테이블이면 에러
 *      4. ACCESS 가능 테이블 타입 검사
 *      5. 파티션 이름 validation
 *          4-1. SrcPart1과 SrcPart2의 이름이 같은지 체크
 *          4-2. SrcPart1, SrcPart2의 파티션이 존재하는지 체크
 *      6. 범위 파티션드 테이블
 *          5-1. SrcPart1과 SrcPart2가 서로 인접해있는지 체크
 *      7. DstPart의 테이블스페이스 validation
 *      8. Lob Column validation
 *      9. In-place Merge인지 Out-place Merge인지 결정
 *     10. Out-place인 경우
 *         DstPart의 이름과 같은 이름의 파티션이 있는지 체크
 *
 *          - In-place Merge
 *              - Left In-place Merge
 *                  ( src_part1 == dst_part )
 *              - Right In-place Merge
 *                  ( src_part2 == dst_part )
 *
 *          - Out-place Merge
 *              ( src_part1 != dst_part ) and ( src_part2 != dst_part )
 *
 ***********************************************************************/

    qdTableParseTree        * sParseTree;
    qcmTableInfo            * sTableInfo;
    qdPartitionAttribute    * sSrcPartAttr1;
    qdPartitionAttribute    * sSrcPartAttr2;
    qdPartitionAttribute    * sDstPartAttr;
    qcmTableInfo            * sSrcPartInfo1;
    qcmTableInfo            * sSrcPartInfo2;
    qcmTableInfo            * sDstPartInfo;
    smSCN                     sDstPartSCN;
    void                    * sDstPartHandle;
    qcuSqlSourceInfo          sqlInfo;

    qcmColumn               * sTargetColumn;
    qcmColumn               * sTableColumn;
    idBool                    sIsDefaultTBS;
    UInt                      i;


    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // ------------------------------------------------------
    // 1. ALTER TABLE 구문의 공통적인 validation
    // ------------------------------------------------------
    // 파티션드 테이블에 LOCK(IS)
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_FALSE )
              != IDE_SUCCESS );

    sTableInfo = sParseTree->tableInfo;

    // ------------------------------------------------------
    // 2. 파티션드 테이블인지 체크
    // ------------------------------------------------------
    IDE_TEST_RAISE( sTableInfo->tablePartitionType
                    == QCM_NONE_PARTITIONED_TABLE,
                    ERR_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE );

    // ------------------------------------------------------
    // 3. 해시 파티션드 테이블이면 에러
    // ------------------------------------------------------
    IDE_TEST_RAISE( sTableInfo->partitionMethod == QCM_PARTITION_METHOD_HASH,
                    ERR_MERGE_PARTITION_ON_HASH_PART_TABLE );

    sSrcPartAttr1 = sParseTree->partTable->partAttr;
    sSrcPartAttr2 = sParseTree->partTable->partAttr->next;
    sDstPartAttr = sParseTree->partTable->partAttr->next->next;

    // ------------------------------------------------------
    // 4. ACCESS 가능 테이블 타입 검사
    // ------------------------------------------------------
    /* PROJ-2359 Table/Partition Access Option */
    IDE_TEST_RAISE( ( sTableInfo->tableType == QCM_MVIEW_TABLE ) &&
                    ( sDstPartAttr->accessOption != QCM_ACCESS_OPTION_NONE ),
                    ERR_ACCESS_NOT_SUPPORT_MVIEW );

    // ------------------------------------------------------
    // 5. 파티션 이름 validation
    // ------------------------------------------------------
    // SrcPart1과 SrcPart2의 이름이 같은지 체크
    if ( QC_IS_NAME_MATCHED( sSrcPartAttr1->tablePartName, sSrcPartAttr2->tablePartName ) )
    {
        sqlInfo.setSourceInfo(aStatement,
                              & sSrcPartAttr2->tablePartName );
        IDE_RAISE( ERR_DUPLICATE_PARTITION_NAME );
    }

    // ------------------------------------------------------
    // SrcPart1 파티션 이름 validation
    // ------------------------------------------------------
    IDE_TEST( qdbCommon::checkPartitionInfo( aStatement,
                                             sTableInfo,
                                             sSrcPartAttr1->tablePartName )
              != IDE_SUCCESS );

    sSrcPartInfo1 = sParseTree->partTable->partInfoList->partitionInfo;

    // ------------------------------------------------------
    // SrcPart2 파티션 이름 validation
    // ------------------------------------------------------
    IDE_TEST( qdbCommon::checkPartitionInfo( aStatement,
                                             sTableInfo,
                                             sSrcPartAttr2->tablePartName )
              != IDE_SUCCESS );

    sSrcPartInfo2 = sParseTree->partTable->partInfoList->next->partitionInfo;
    
    
    if ( ( QCG_GET_SESSION_LOCK_TABLE_UNTIL_NEXT_DDL( aStatement ) == ID_TRUE ) &&
         ( QCG_GET_SESSION_TABLE_ID_OF_LOCK_TABLE_UNTIL_NEXT_DDL( aStatement ) == sTableInfo->tableID ) )
    {
        if ( sSrcPartInfo1->replicationCount > 0 )
        {
            IDE_TEST( qci::mValidateReplicationCallback.mValidateAlterPartition( aStatement,
                                                                                 sSrcPartInfo1 )
                      != IDE_SUCCESS );
        }
        else
        {
            /* Nothing to do */
        }

        if ( sSrcPartInfo2->replicationCount > 0 )
        {
            IDE_TEST( qci::mValidateReplicationCallback.mValidateAlterPartition( aStatement,
                                                                                 sSrcPartInfo2 )
                      != IDE_SUCCESS );
        }
        else
        {
            /* Nothing to do */
        }
    }
    else
    {
        IDE_TEST_RAISE( ( sSrcPartInfo1->replicationCount > 0 ) || ( sSrcPartInfo2->replicationCount > 0 ),
                        ERR_DDL_WITH_REPLICATED_PARTITION );
    }

    // ------------------------------------------------------
    // non-partitioned index의 리스트를 얻는다.
    // ------------------------------------------------------
    // PROJ-1624 non-partitioned index
    IDE_TEST( qdx::makeAndLockIndexTableList( aStatement,
                                              ID_FALSE,
                                              sParseTree->tableInfo,
                                              &(sParseTree->oldIndexTables) )
              != IDE_SUCCESS );
    
    // ------------------------------------------------------
    // SrcPart1의 min_value, max_value를
    // mtdCharType, qmsPartCondValList, qmmValueNode로
    // 만들어서 파스트리에 달아놓는다.
    // ------------------------------------------------------
    IDE_TEST( qdbCommon::makePartCondValList( aStatement,
                                              sTableInfo,
                                              sSrcPartInfo1->partitionID,
                                              sSrcPartAttr1 )
              != IDE_SUCCESS );

    // ------------------------------------------------------
    // SrcPart2의 min_value, max_value를
    // mtdCharType, qmsPartCondValList, qmmValueNode로
    // 만들어서 파스트리에 달아놓는다.
    // ------------------------------------------------------
    IDE_TEST( qdbCommon::makePartCondValList( aStatement,
                                              sTableInfo,
                                              sSrcPartInfo2->partitionID,
                                              sSrcPartAttr2 )
              != IDE_SUCCESS );

    // ------------------------------------------------------
    // 6. 범위 파티션드 테이블이면
    //    SrcPart1과 SrcPart2가 서로 인접해있는지 체크
    // ------------------------------------------------------
    if( sTableInfo->partitionMethod == QCM_PARTITION_METHOD_RANGE )
    {
        IDE_TEST( qdbAlter::checkAdjPartition( aStatement,
                                               sTableInfo )
                  != IDE_SUCCESS );
    }

    // ------------------------------------------------------
    // 7. DstPart의 테이블스페이스 validation
    // ------------------------------------------------------
    IDE_TEST( qdbCommon::validateTBSOfPartition( aStatement, sDstPartAttr )
              != IDE_SUCCESS );

    /* PROJ-2639 Altibase Disk Edition */
#ifdef ALTI_CFG_EDITION_DISK
    if ( sTableInfo->tableOwnerID == QC_SYSTEM_USER_ID )
    {
        /* Nothing to do */
    }
    else
    {
        IDE_TEST_RAISE( smiTableSpace::isDiskTableSpaceType( sDstPartAttr->TBSAttr.mType ) == ID_FALSE,
                        ERR_NOT_SUPPORT_MEMORY_VOLATILE_TABLESPACE_IN_DISK_EDITION );
    }
#endif

    /* PROJ-2464 hybrid partitioned table 지원 */
    IDE_TEST( validateTablespaceRestriction( sTableInfo, sDstPartAttr->TBSAttr.mType )
              != IDE_SUCCESS );

    /* PROJ-2464 hybrid partitioned table 지원 */
    // qdbCommon::getTableTypeCountInPartAttrList()를 사용하기 위해, Src, Dst Partition List를 잠시 분리한다.
    sSrcPartAttr2->next = NULL;
    IDE_TEST( validateTableReferenceForPartitions( aStatement,
                                                   sTableInfo,
                                                   sSrcPartAttr1,
                                                   sDstPartAttr )
              != IDE_SUCCESS );
    sSrcPartAttr2->next = sDstPartAttr;

    // ------------------------------------------------------
    // 8. validation of LOB column attributes
    // ------------------------------------------------------
    // 각 파티션별로 LOB 컬럼 정보를 저장하기 위해
    // 테이블 컬럼 정보를 각 테이블 파티션의 컬럼 정보로 복사한다.
    // IN-PLACE에서 TABLESPACE가 명시되지 않은 경우는 기존 파티션의
    // TBS를 따른다.( OUT-PLACE의 경우는 파티션드 테이블의 TBS를 따른다.
    sDstPartAttr->columns  = NULL;
    if ( QC_IS_NAME_MATCHED( sDstPartAttr->tablePartName, sSrcPartAttr1->tablePartName ) &&
         ( QC_IS_NULL_NAME( sDstPartAttr->TBSName ) == ID_TRUE ) &&
         ( sDstPartAttr->lobAttr == NULL ) )
    {
        IDE_TEST( qcm::copyQcmColumns( QC_QMP_MEM(aStatement),
                                       sSrcPartInfo1->columns,
                                       &(sDstPartAttr->columns ),
                                       sSrcPartInfo1->columnCount ) != IDE_SUCCESS );
    }
    else
    {
        if ( QC_IS_NAME_MATCHED( sDstPartAttr->tablePartName, sSrcPartAttr2->tablePartName ) &&
             ( QC_IS_NULL_NAME( sDstPartAttr->TBSName ) == ID_TRUE ) &&
             ( sDstPartAttr->lobAttr == NULL ) )
        {
            IDE_TEST( qcm::copyQcmColumns( QC_QMP_MEM(aStatement),
                                           sSrcPartInfo2->columns,
                                           &(sDstPartAttr->columns ),
                                           sSrcPartInfo2->columnCount ) != IDE_SUCCESS );
        }
        else
        {
            /* PROJ-2464 hybrid partitioned table 지원 */
            IDE_TEST( qdbCommon::copyAndAdjustColumnList( aStatement,
                                                          sTableInfo->TBSType,
                                                          sDstPartAttr->TBSAttr.mType,
                                                          sTableInfo->columns,
                                                          &(sDstPartAttr->columns),
                                                          sTableInfo->columnCount,
                                                          ID_FALSE /* aEnableVariableColumn */ )
                      != IDE_SUCCESS );

            for( i = 0, sTableColumn = sTableInfo->columns, sTargetColumn = sDstPartAttr->columns;
                 sTableColumn != NULL ;
                 i++, sTableColumn = sTableColumn->next, sTargetColumn = sTargetColumn->next )
            {

                if ( (sTableColumn->basicInfo->module->flag &
                      MTD_COLUMN_TYPE_MASK)
                     == MTD_COLUMN_TYPE_LOB )
                {
                    /* 파티션드 테이블의 LOB COLUMN TBS 지정 여부 */
                    IDE_TEST( qcm::getIsDefaultTBS(
                                  aStatement,
                                  sTableInfo->tableID,
                                  (sTableInfo->tableID * SMI_COLUMN_ID_MAXIMUM) + i,
                                  & sIsDefaultTBS )
                              != IDE_SUCCESS );

                    /* PROJ-2464 hybrid partitioned table 지원
                     *  - Disk Partition의 경우, Partitioned의 Lob Column TBS(Default TBS)가
                     *    지정되어 있으면 Default TBS를 사용한다.
                     *  - PROJ-2334 PMT MEMORY PARTITIONED TABLE : Memory Partition의 경우,
                     *    Partition TBS를 사용한다.
                     */
                    /* PROJ-2465 Tablespace Alteration for Table
                     *  - 부족한 Default TBS 처리를 추가한다.
                     */
                    if ( ( sIsDefaultTBS == ID_TRUE ) &&
                         ( smiTableSpace::isDiskTableSpaceType( sDstPartAttr->TBSAttr.mType ) == ID_TRUE ) &&
                         ( smiTableSpace::isDiskTableSpaceType( sTableInfo->TBSType ) == ID_TRUE ) )
                    {
                        /* Create시 ColSpace에 설정된 Default TBS를 그대로 이용한다. */
                        /* Nothing to do */
                    }
                    else
                    {
                        sTargetColumn->basicInfo->column.colSpace = sDstPartAttr->TBSAttr.mID;
                    }
                }
                else
                {
                    sTargetColumn->basicInfo->column.colSpace = sDstPartAttr->TBSAttr.mID;
                }
            } // for
        }
    }

    // LOB 컬럼의 TBS를 명시하지 않으면, 파티션의 TBS를 따른다.
    // 인자로 넣은 sTableInfo는 형식적으로 넣은 것이고,
    // 실제로 sDstPartAttr의 TBS를 따르게 된다.
    IDE_TEST(qdbCommon::validateLobAttributeList(
                 aStatement,
                 sTableInfo,
                 sDstPartAttr->columns,
                 &(sDstPartAttr->TBSAttr),
                 sDstPartAttr->lobAttr )
             != IDE_SUCCESS);

    // ------------------------------------------------------
    // 9. In-place Split인지 Out-place Split인지 결정
    // ------------------------------------------------------
    if ( QC_IS_NAME_MATCHED( sSrcPartAttr1->tablePartName, sDstPartAttr->tablePartName ) )
    {
        if( (QC_IS_NULL_NAME( sDstPartAttr->TBSName ) == ID_TRUE) &&
            (sDstPartAttr->lobAttr == NULL) &&
            (sDstPartAttr->alterPart->indexPartAttr == NULL) )
        {
            sSrcPartAttr1->alterPart->splitMergeType =
                QD_ALTER_PARTITION_LEFT_INPLACE_TYPE;
        }
        else
        {
            sSrcPartAttr1->alterPart->splitMergeType =
                QD_ALTER_PARTITION_OUTPLACE_TYPE;
        }
    }
    else if ( QC_IS_NAME_MATCHED( sSrcPartAttr2->tablePartName, sDstPartAttr->tablePartName ) )
    {
        if( (QC_IS_NULL_NAME( sDstPartAttr->TBSName ) == ID_TRUE) &&
            (sDstPartAttr->lobAttr == NULL) &&
            (sDstPartAttr->alterPart->indexPartAttr == NULL) )
        {
            sSrcPartAttr1->alterPart->splitMergeType =
                QD_ALTER_PARTITION_RIGHT_INPLACE_TYPE;
        }
        else
        {
            sSrcPartAttr1->alterPart->splitMergeType =
                QD_ALTER_PARTITION_OUTPLACE_TYPE;
        }
    }
    else
    {
        sSrcPartAttr1->alterPart->splitMergeType =
            QD_ALTER_PARTITION_OUTPLACE_TYPE;
    }

    // ------------------------------------------------------
    // 10. Out-place인 경우 DstPart의 이름과 같은 이름의 파티션이 있는지 체크
    // ------------------------------------------------------
    if( sSrcPartAttr1->alterPart->splitMergeType ==
        QD_ALTER_PARTITION_OUTPLACE_TYPE )
    {
        if ( ( QC_IS_NAME_MATCHED( sSrcPartAttr1->tablePartName, sDstPartAttr->tablePartName ) == ID_FALSE ) &&
             ( QC_IS_NAME_MATCHED( sSrcPartAttr2->tablePartName, sDstPartAttr->tablePartName ) == ID_FALSE ) )
        {
            if( qcmPartition::getPartitionInfo( aStatement,
                                                sTableInfo->tableID,
                                                sDstPartAttr->tablePartName,
                                                & sDstPartInfo,
                                                & sDstPartSCN,
                                                & sDstPartHandle )
                == IDE_SUCCESS )
            {
                sqlInfo.setSourceInfo(aStatement,
                                      & sDstPartAttr->tablePartName );
                IDE_RAISE( ERR_ALREADY_EXIST_PARTITION_NAME );
            }
        }
        else
        {
            // DstPart의 이름이 SrcPart1 또는 SrcPart2의 이름과 같더라도
            // DstPart에 TBS를 지정하면 Out-place로 분류된다.
            // (SrcPart의 TBS와 같은 TBS라고 하더라도 Out-place이다.)
            // 따라서, 이런 경우에는 DstPart의 이름을 체크할 필요없다.

            // Nothing to do
        }
    }
    else
    {
        // Nothing to do
    }

    /* PROJ-2464 hybrid partitioned table 지원 */
    IDE_TEST( validateIndexAlterationForPartition( aStatement,
                                                   sTableInfo,
                                                   sSrcPartInfo1,
                                                   sDstPartAttr )
              != IDE_SUCCESS );

    // ------------------------------------------------------
    // 인덱스 파티션을 지정한 경우의 validation
    // ------------------------------------------------------

    if ( sDstPartAttr->alterPart->indexPartAttr != NULL )
    {
        // SrcPart1과 DstPart의 이름이 같을 때
        if ( QC_IS_NAME_MATCHED( sSrcPartAttr1->tablePartName, sDstPartAttr->tablePartName ) )
        {
            // 인덱스 파티션 이름을 그대로 사용했는지 체크하기 위해
            // SrcPart를 인자로 넘져준다.
            IDE_TEST( checkIndexPartAttrList( aStatement,
                                              sTableInfo,
                                              sSrcPartInfo1,
                                              sSrcPartAttr1,
                                              sDstPartAttr,
                                              sParseTree->userID )
                      != IDE_SUCCESS );
        }
        // SrcPart2와 DstPart의 이름이 같을 때
        // SrcPart1, SrcPart2의 이름과 DstPart의 이름이 같지 않을 때
        else
        {
            // 인덱스 파티션 이름을 그대로 사용했는지 체크
            // 모두 같지 않을 경우에는 상관없음
            IDE_TEST( checkIndexPartAttrList( aStatement,
                                              sTableInfo,
                                              sSrcPartInfo2,
                                              sSrcPartAttr2,
                                              sDstPartAttr,
                                              sParseTree->userID )
                      != IDE_SUCCESS );
        }
    }
    else
    {
        /* Nothing to do */
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_DDL_WITH_REPLICATED_PARTITION )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_DDL_WITH_REPLICATED_PART ) );
    }
    IDE_EXCEPTION(ERR_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE));
    }
    IDE_EXCEPTION(ERR_MERGE_PARTITION_ON_HASH_PART_TABLE);
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_MERGE_HASH_PART_TABLE));
    }
    IDE_EXCEPTION(ERR_DUPLICATE_PARTITION_NAME)
    {
        (void)sqlInfo.init(aStatement->qmeMem);
        IDE_SET(ideSetErrorCode( qpERR_ABORT_QDB_DUPLICATE_PARTITION_NAME,
                                 sqlInfo.getErrMessage()) );
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION(ERR_ALREADY_EXIST_PARTITION_NAME)
    {
        (void)sqlInfo.init(aStatement->qmeMem);
        IDE_SET(ideSetErrorCode( qpERR_ABORT_QDB_ALREADY_EXIST_PARTITION_NAME,
                                 sqlInfo.getErrMessage()) );
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION( ERR_ACCESS_NOT_SUPPORT_MVIEW );
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDM_ACCESS_NOT_SUPPORT_MVIEW ) );
    }
#ifdef ALTI_CFG_EDITION_DISK
    IDE_EXCEPTION( ERR_NOT_SUPPORT_MEMORY_VOLATILE_TABLESPACE_IN_DISK_EDITION );
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_USE_ONLY_DISK_TABLE_PARTITION_IN_DISK_EDITION ) );
    }
#endif
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::validateDropPartition( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *    PROJ-1502 PARTITIONED DISK TABLE
 *
 *
 * Implementation :
 *
 ***********************************************************************/

    qdTableParseTree       * sParseTree;
    qcmTableInfo           * sTableInfo;
    qdPartitionAttribute   * sPartAttr;
    qcmTableInfo           * sPartitionInfo;
    UInt                     sFindPartID = 0;          // TASK-3876 Code Sonar
    UInt                     sPartitionCount = 0;
    qcmPartitionIdList     * sPartIdList = NULL;
    idBool                   sIsFound = ID_FALSE;      // TASK-3876 Code Sonar

    qmsPartCondValList     * sPartCondMaxVal;
    mtdCharType            * sPartKeyCondMinValueStr;
    mtdCharType            * sPartKeyCondMaxValueStr;

    qmsPartCondValList     * sFindPartCondMinVal;
    mtdCharType            * sFindPartKeyCondMinValueStr;
    mtdCharType            * sFindPartKeyCondMaxValueStr;

    IDU_LIMITPOINT("qdbAlter::validateDropPartition::malloc1");
    IDE_TEST( STRUCT_ALLOC( QC_QMP_MEM(aStatement),
                            qmsPartCondValList,
                            & sPartCondMaxVal )
              != IDE_SUCCESS );

    IDU_LIMITPOINT("qdbAlter::validateDropPartition::malloc2");
    IDE_TEST( STRUCT_ALLOC( QC_QMP_MEM(aStatement),
                            qmsPartCondValList,
                            & sFindPartCondMinVal )
              != IDE_SUCCESS );

    IDU_LIMITPOINT("qdbAlter::validateDropPartition::malloc3");
    IDE_TEST( STRUCT_ALLOC_WITH_SIZE(
                  QC_QMP_MEM(aStatement),
                  UChar,
                  MTD_CHAR_TYPE_STRUCT_SIZE(QC_MAX_PARTKEY_COND_VALUE_LEN),
                  (void**) & sPartKeyCondMinValueStr )
              != IDE_SUCCESS );

    IDU_LIMITPOINT("qdbAlter::validateDropPartition::malloc4");
    IDE_TEST( STRUCT_ALLOC_WITH_SIZE(
                  QC_QMP_MEM(aStatement),
                  UChar,
                  MTD_CHAR_TYPE_STRUCT_SIZE(QC_MAX_PARTKEY_COND_VALUE_LEN),
                  (void**) & sPartKeyCondMaxValueStr )
              != IDE_SUCCESS );

    IDU_LIMITPOINT("qdbAlter::validateDropPartition::malloc5");
    IDE_TEST( STRUCT_ALLOC_WITH_SIZE(
                  QC_QMP_MEM(aStatement),
                  UChar,
                  MTD_CHAR_TYPE_STRUCT_SIZE(QC_MAX_PARTKEY_COND_VALUE_LEN),
                  (void**) & sFindPartKeyCondMinValueStr )
              != IDE_SUCCESS );

    IDU_LIMITPOINT("qdbAlter::validateDropPartition::malloc6");
    IDE_TEST( STRUCT_ALLOC_WITH_SIZE(
                  QC_QMP_MEM(aStatement),
                  UChar,
                  MTD_CHAR_TYPE_STRUCT_SIZE(QC_MAX_PARTKEY_COND_VALUE_LEN),
                  (void**) & sFindPartKeyCondMaxValueStr )
              != IDE_SUCCESS );

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // ------------------------------------------------------
    // 1. ALTER TABLE 구문의 공통적인 validation
    // ------------------------------------------------------
    // 파티션드 테이블에 LOCK(IS)
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_FALSE )
              != IDE_SUCCESS );

    sTableInfo = sParseTree->tableInfo;

    // ------------------------------------------------------
    // 2. 파티션드 테이블인지 체크
    // ------------------------------------------------------
    IDE_TEST_RAISE( sTableInfo->tablePartitionType
                    == QCM_NONE_PARTITIONED_TABLE,
                    ERR_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE );

    sPartAttr = sParseTree->partTable->partAttr;

    // ------------------------------------------------------
    // 3. 삭제할 파티션 이름 validation
    // ------------------------------------------------------
    IDE_TEST( qdbCommon::checkPartitionInfo( aStatement,
                                             sTableInfo,
                                             sPartAttr->tablePartName )
              != IDE_SUCCESS );

    sPartitionInfo = sParseTree->partTable->partInfoList->partitionInfo;

    // ------------------------------------------------------
    // 3.5 non-partitioned index의 리스트를 얻는다.
    // ------------------------------------------------------
    // PROJ-1624 non-partitioned index
    IDE_TEST( qdx::makeAndLockIndexTableList( aStatement,
                                              ID_FALSE,
                                              sParseTree->tableInfo,
                                              &(sParseTree->oldIndexTables) )
              != IDE_SUCCESS );
    
    // ------------------------------------------------------
    // 해시 파티션드 테이블인지 체크
    // ------------------------------------------------------
    IDE_TEST_RAISE( sTableInfo->partitionMethod == QCM_PARTITION_METHOD_HASH,
                    ERR_DROP_PARTITION_ON_HASH_PART_TABLE );

    // ------------------------------------------------------
    // 총 파티션의 개수가 1개인지 체크
    // ------------------------------------------------------
    IDE_TEST( qcmPartition::getPartitionCount( aStatement,
                                               sTableInfo->tableID,
                                               & sPartitionCount )
              != IDE_SUCCESS );

    IDE_TEST_RAISE( sPartitionCount < 2,
                    ERR_DROP_THE_ONLY_PARTITION);

    // ------------------------------------------------------
    // default 파티션인지 체크
    // ------------------------------------------------------
    IDE_TEST( qcmPartition::getPartMinMaxValue( QC_SMI_STMT( aStatement ),
                                                sPartitionInfo->partitionID,
                                                sPartKeyCondMinValueStr,
                                                sPartKeyCondMaxValueStr )
              != IDE_SUCCESS );

    // 범위, 리스트 파티션드 테이블 모두 기본 파티션의 max_value는 '\0'이다.
    IDE_TEST_RAISE( sPartKeyCondMaxValueStr->length == 0,
                    ERR_DROP_THE_DEFAULT_PARTITION);

    // ------------------------------------------------
    // 범위 파티션드 테이블이면 오른쪽 파티션으로 인접한 파티션 찾기
    // (오른쪽 파티션의 PARTITION_MIN_VALUE 값도 변경되야 함)
    // ------------------------------------------------
    if( sTableInfo->partitionMethod == QCM_PARTITION_METHOD_RANGE )
    {
        // 삭제할 파티션의 max_value를 qmsPartCondValList로 만든다.
        IDE_TEST( qcmPartition::getPartCondVal(
                      aStatement,
                      sTableInfo->partKeyColumns,
                      sTableInfo->partitionMethod,
                      sPartCondMaxVal,
                      NULL, /* aPartCondValStmtText */
                      NULL, /* aPartCondValNode */
                      sPartKeyCondMaxValueStr )
                  != IDE_SUCCESS );

        if (sPartCondMaxVal->partCondValCount == 0)
        {
            sPartCondMaxVal->partCondValType = QMS_PARTCONDVAL_DEFAULT;
        }
        else
        {
            sPartCondMaxVal->partCondValType = QMS_PARTCONDVAL_NORMAL;
        }

        // tableID로 파티션 ID의 리스트를 가져온다.
        IDE_TEST( qcmPartition::getPartitionIdList( aStatement,
                                                    QC_SMI_STMT( aStatement ),
                                                    sTableInfo->tableID,
                                                    & sPartIdList )
                  != IDE_SUCCESS );

        for( ;
             sPartIdList != NULL;
             sPartIdList = sPartIdList->next )
        {
            sFindPartID = sPartIdList->partId;

            if( sFindPartID == sPartitionInfo->partitionID )
            {
                continue;
            }

            IDE_TEST( qcmPartition::getPartMinMaxValue( QC_SMI_STMT(aStatement),
                                                        sFindPartID,
                                                        sFindPartKeyCondMinValueStr,
                                                        sFindPartKeyCondMaxValueStr )
                      != IDE_SUCCESS );

            // 찾을 파티션의 min_value를 qmsPartCondValList로 만든다.
            IDE_TEST( qcmPartition::getPartCondVal(
                          aStatement,
                          sTableInfo->partKeyColumns,
                          sTableInfo->partitionMethod,
                          sFindPartCondMinVal,
                          NULL, /* aPartCondValStmtText */
                          NULL, /* aPartCondValNode */
                          sFindPartKeyCondMinValueStr )
                      != IDE_SUCCESS );

            if (sFindPartCondMinVal->partCondValCount == 0)
            {
                sFindPartCondMinVal->partCondValType = QMS_PARTCONDVAL_MIN;
            }
            else
            {
                sFindPartCondMinVal->partCondValType = QMS_PARTCONDVAL_NORMAL;
            }

            if ( qmoPartition::compareRangePartition( sTableInfo->partKeyColumns,
                                                      sPartCondMaxVal,
                                                      sFindPartCondMinVal ) == 0 )
            {
                sIsFound = ID_TRUE;
                break;
            }
            else
            {
                // Nothing to do
            }
        }

        IDE_DASSERT( sIsFound == ID_TRUE );

        // 변경할 파티션 정보를 파스트리에 달아놓는다.
        IDE_TEST( qdbCommon::checkPartitionInfo( aStatement,
                                                 sFindPartID )
                  != IDE_SUCCESS );
    }
    else
    {
        // Nothing to do
    }

    // check replcation 
    if ( ( QCG_GET_SESSION_LOCK_TABLE_UNTIL_NEXT_DDL( aStatement ) == ID_TRUE ) &&
         ( QCG_GET_SESSION_TABLE_ID_OF_LOCK_TABLE_UNTIL_NEXT_DDL( aStatement ) == sTableInfo->tableID ) )
    {
        if ( sPartitionInfo->replicationCount > 0 )
        {
            IDE_TEST( qci::mValidateReplicationCallback.mValidateAlterPartition( aStatement,
                                                                                 sPartitionInfo )
                      != IDE_SUCCESS );
        }
        else
        {
            /* Nothing to do */
        }
    }
    else
    {
        IDE_TEST_RAISE( sPartitionInfo->replicationCount > 0 ,
                        ERR_DDL_WITH_REPLICATED_PARTITION );
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE));
    }
    IDE_EXCEPTION(ERR_DROP_PARTITION_ON_HASH_PART_TABLE);
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_DROP_PARTITION_ON_HASH_PART_TABLE));
    }
    IDE_EXCEPTION(ERR_DROP_THE_ONLY_PARTITION)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_DROP_THE_ONLY_PARTITION));
    }
    IDE_EXCEPTION(ERR_DROP_THE_DEFAULT_PARTITION)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_DROP_THE_DEFAULT_PARTITION));
    }
    IDE_EXCEPTION( ERR_DDL_WITH_REPLICATED_PARTITION )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_DDL_WITH_REPLICATED_PART ) );
    }

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::validateRenamePartition( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *    PROJ-1502 PARTITIONED DISK TABLE
 *
 *    ALTER TABLE t1 RENAME PARTITION old_part TO new_part;
 *    구문의 validation
 *
 *
 * Implementation :
 *
 ***********************************************************************/

    qdTableParseTree        * sParseTree;
    qcmTableInfo            * sTableInfo;
    qdPartitionAttribute    * sOldPartAttr;
    qdPartitionAttribute    * sNewPartAttr;
    qcuSqlSourceInfo          sqlInfo;

    qcmTableInfo            * sPartitionInfo;
    void                    * sHandle;
    smSCN                     sSCN;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // ------------------------------------------------------
    // 1. ALTER TABLE 구문의 공통적인 validation
    // ------------------------------------------------------
    // 파티션드 테이블에 LOCK(IS)
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_FALSE )
              != IDE_SUCCESS );

    sTableInfo = sParseTree->tableInfo;

    // ------------------------------------------------------
    // 2. 파티션드 테이블인지 체크
    // ------------------------------------------------------
    IDE_TEST_RAISE( sTableInfo->tablePartitionType
                    == QCM_NONE_PARTITIONED_TABLE,
                    ERR_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE );

    sOldPartAttr = sParseTree->partTable->partAttr;
    sNewPartAttr = sParseTree->partTable->partAttr->next;

    // ------------------------------------------------------
    // 3. OldPart 파티션 이름 validation
    // ------------------------------------------------------
    IDE_TEST( qdbCommon::checkPartitionInfo( aStatement,
                                             sTableInfo,
                                             sOldPartAttr->tablePartName )
              != IDE_SUCCESS );

    // ------------------------------------------------------
    // 4. NewPart의 파티션 이름 validation
    // ------------------------------------------------------
    if( qcmPartition::getPartitionInfo( aStatement,
                                        sTableInfo->tableID,
                                        sNewPartAttr->tablePartName,
                                        & sPartitionInfo,
                                        & sSCN,
                                        & sHandle )
        == IDE_SUCCESS )
    {
        sqlInfo.setSourceInfo(aStatement,
                              & sNewPartAttr->tablePartName );
        IDE_RAISE( ERR_ALREADY_EXIST_PARTITION_NAME );
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE));
    }
    IDE_EXCEPTION(ERR_ALREADY_EXIST_PARTITION_NAME)
    {
        (void)sqlInfo.init(aStatement->qmeMem);
        IDE_SET(ideSetErrorCode( qpERR_ABORT_QDB_ALREADY_EXIST_PARTITION_NAME,
                                 sqlInfo.getErrMessage()) );
        (void)sqlInfo.fini();
    }

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::validateTruncatePartition( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *    PROJ-1502 PARTITIONED DISK TABLE
 *
 *
 * Implementation :
 *    1. ALTER TABLE 구문의 공통적인 validation
 *    2. 파티션드 테이블인지 체크
 *    3. 파티션 이름 validation
 *    4. 유니크 키 존재 && 그 키를 참조하는 child존재하는지 체크
 *    5. 테이블에 Replication이 걸려있으면, Recovery 여부를 확인
 *
 ***********************************************************************/

    qdTableParseTree        * sParseTree;
    qcmTableInfo            * sTableInfo;
    qdPartitionAttribute    * sPartAttr;
    qcmTableInfo            * sPartInfo;
    UInt                      i;
    qcmRefChildInfo         * sChildInfo;  // BUG-28049
    qcmIndex                * sIndexInfo;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // ------------------------------------------------------
    // 1. ALTER TABLE 구문의 공통적인 validation
    // ------------------------------------------------------
    // 파티션드 테이블에 LOCK(IS)
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_FALSE )
              != IDE_SUCCESS );

    sTableInfo = sParseTree->tableInfo;

    // ------------------------------------------------------
    // 2. 파티션드 테이블인지 체크
    // ------------------------------------------------------
    IDE_TEST_RAISE( sTableInfo->tablePartitionType
                    == QCM_NONE_PARTITIONED_TABLE,
                    ERR_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE );

    sPartAttr = sParseTree->partTable->partAttr;

    // ------------------------------------------------------
    // 3. 파티션 이름 validation
    // ------------------------------------------------------
    IDE_TEST( qdbCommon::checkPartitionInfo( aStatement,
                                             sTableInfo,
                                             sPartAttr->tablePartName )
              != IDE_SUCCESS );

    sPartInfo = sParseTree->partTable->partInfoList->partitionInfo;

    // ------------------------------------------------------
    // 3.5 non-partitioned index의 리스트를 얻는다.
    // ------------------------------------------------------
    // PROJ-1624 non-partitioned index
    IDE_TEST( qdx::makeAndLockIndexTableList( aStatement,
                                              ID_FALSE,
                                              sParseTree->tableInfo,
                                              &(sParseTree->oldIndexTables) )
              != IDE_SUCCESS );
    
    // ------------------------------------------------------
    // 4. 유니크 키 존재 && 그 키를 참조하는 child존재하는지 체크
    // ------------------------------------------------------
    // check referential constraint
    for (i = 0; i < sTableInfo->indexCount; i++)
    {
        sIndexInfo = &(sTableInfo->indices[i]);

        if( sIndexInfo->isUnique == ID_TRUE )
        {
            IDE_TEST(qcm::getChildKeys(aStatement,
                                       sIndexInfo,
                                       sTableInfo,
                                       & sChildInfo)
                     != IDE_SUCCESS);

            if (sChildInfo != NULL)
            {
                // BUG-28049
                while (sChildInfo->childTableRef != NULL) // foreign key exists.
                {
                    // not self
                    IDE_TEST_RAISE( sChildInfo->childTableRef->tableInfo != sPartInfo,
                                    ERR_ABORT_REFERENTIAL_CONSTRAINT_EXIST );

                    sChildInfo = sChildInfo->next;
                }
            }
        }
    }

    // ------------------------------------------------------
    // 5. Replication 가능 여부 검사
    // ------------------------------------------------------
    /* BUG-20514 (PROJ-1442) Partition에 대한 Truncate를 지원해야 합니다.
     * Recovery 기능과 같이 사용할 수 없음
     */
    if(sTableInfo->replicationCount > 0)
    {
        IDE_TEST_RAISE(sTableInfo->replicationRecoveryCount > 0,
                       ERR_CANNOT_DDL_WITH_RECOVERY);
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE));
    }
    IDE_EXCEPTION(ERR_ABORT_REFERENTIAL_CONSTRAINT_EXIST);
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_REFERENTIAL_CONSTRAINT_EXIST));
    }
    IDE_EXCEPTION(ERR_CANNOT_DDL_WITH_RECOVERY)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_DDL_WITH_RECOVERY));
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::validateRowmovement( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *    PROJ-1502 PARTITIONED DISK TABLE
 *
 *
 * Implementation :
 *
 ***********************************************************************/

    qdTableParseTree        * sParseTree;
    qcmTableInfo            * sTableInfo;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // ------------------------------------------------------
    // 1. ALTER TABLE 구문의 공통적인 validation
    // ------------------------------------------------------
    // 파티션드 테이블에 LOCK(IS)
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_TRUE )
              != IDE_SUCCESS );

    sTableInfo = sParseTree->tableInfo;

    // ------------------------------------------------------
    // 2. 파티션드 테이블인지 체크
    // ------------------------------------------------------
    IDE_TEST_RAISE( sTableInfo->tablePartitionType
                    == QCM_NONE_PARTITIONED_TABLE,
                    ERR_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE );

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE));
    }

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::validateAddPartition( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *    PROJ-1502 PARTITIONED DISK TABLE
 *
 *
 * Implementation :
 *
 ***********************************************************************/

    qcmColumn               * sTargetColumn;
    qcmColumn               * sTableColumn;
    qdTableParseTree        * sParseTree;
    qcmTableInfo            * sTableInfo;
    qdPartitionAttribute    * sDstPartAttr;
    qcmTableInfo            * sPartInfo;
    smSCN                     sSCN;
    void                    * sHandle;
    qcuSqlSourceInfo          sqlInfo;
    qcmPartitionInfoList    * sPartInfoList = NULL;
    qcmPartitionInfoList    * sTempPartInfoList = NULL;
    qcmPartitionInfoList    * sNewPartInfoList = NULL;
    UInt                      sPartOrder = 0;
    UInt                      sTotalPartCount = 0;
    UInt                      i;
    idBool                    sIsDefaultTBS;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;
    sDstPartAttr = sParseTree->partTable->partAttr;

    // ------------------------------------------------------
    // 1. ALTER TABLE 구문의 공통적인 validation
    // ------------------------------------------------------
    // 파티션드 테이블에 LOCK(IS)
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_TRUE )
              != IDE_SUCCESS );

    sTableInfo = sParseTree->tableInfo;

    // ------------------------------------------------------
    // 2. 파티션드 테이블인지 체크
    // ------------------------------------------------------
    IDE_TEST_RAISE( sTableInfo->tablePartitionType
                    == QCM_NONE_PARTITIONED_TABLE,
                    ERR_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE );

    // ------------------------------------------------------
    // 해시 파티션드 테이블인지 체크
    // ------------------------------------------------------
    IDE_TEST_RAISE( sTableInfo->partitionMethod != QCM_PARTITION_METHOD_HASH,
                    ERR_ADD_PARTITION_ON_NONE_HASH_PART_TABLE );

    // ------------------------------------------------------
    // ACCESS 가능 테이블 타입 검사
    // ------------------------------------------------------
    /* PROJ-2359 Table/Partition Access Option */
    IDE_TEST_RAISE( ( sTableInfo->tableType == QCM_MVIEW_TABLE ) &&
                    ( sDstPartAttr->accessOption != QCM_ACCESS_OPTION_NONE ),
                    ERR_ACCESS_NOT_SUPPORT_MVIEW );

    // ------------------------------------------------------------
    // 파티션 정보, Handle, SCN의 리스트를 구해서 파스트리에 달아놓는다.
    // ------------------------------------------------------------

    // 모든 파티션에 LOCK(IS)
    // 파티션 리스트를 파스트리에 달아놓는다.
    IDE_TEST( qdbCommon::checkAndSetAllPartitionInfo(
                  aStatement,
                  sParseTree->tableInfo->tableID,
                  & (sParseTree->partTable->partInfoList) )
              != IDE_SUCCESS );

    // PROJ-1624 non-partitioned index
    IDE_TEST( qdx::makeAndLockIndexTableList(
                  aStatement,
                  ID_FALSE,
                  sParseTree->tableInfo,
                  &(sParseTree->oldIndexTables) )
              != IDE_SUCCESS );
    
    sPartInfoList = sParseTree->partTable->partInfoList;

    // ------------------------------------------------------
    // DstPart의 파티션 이름 validation
    // ------------------------------------------------------
    if( qcmPartition::getPartitionInfo( aStatement,
                                        sTableInfo->tableID,
                                        sDstPartAttr->tablePartName,
                                        & sPartInfo,
                                        & sSCN,
                                        & sHandle )
        == IDE_SUCCESS )
    {
        sqlInfo.setSourceInfo(aStatement,
                              & sDstPartAttr->tablePartName );
        IDE_RAISE( ERR_ALREADY_EXIST_PARTITION_NAME );
    }

    // ------------------------------------------------------
    // DstPart의 테이블스페이스 validation
    // ------------------------------------------------------
    IDE_TEST( qdbCommon::validateTBSOfPartition( aStatement, sDstPartAttr )
              != IDE_SUCCESS );

    /* PROJ-2639 Altibase Disk Edition */
#ifdef ALTI_CFG_EDITION_DISK
    if ( sTableInfo->tableOwnerID == QC_SYSTEM_USER_ID )
    {
        /* Nothing to do */
    }
    else
    {
        IDE_TEST_RAISE( smiTableSpace::isDiskTableSpaceType( sDstPartAttr->TBSAttr.mType ) == ID_FALSE,
                        ERR_NOT_SUPPORT_MEMORY_VOLATILE_TABLESPACE_IN_DISK_EDITION );
    }
#endif

    /* PROJ-2464 hybrid partitioned table 지원 */
    IDE_TEST( validateTablespaceRestriction( sTableInfo, sDstPartAttr->TBSAttr.mType )
              != IDE_SUCCESS );

    /* PROJ-2464 hybrid partitioned table 지원 */
    IDE_TEST( validateTableReferenceForPartitions( aStatement,
                                                   sTableInfo,
                                                   NULL,
                                                   sDstPartAttr )
              != IDE_SUCCESS );

    // ------------------------------------------------------
    // validation of LOB column attributes
    // ------------------------------------------------------
    // 각 파티션별로 LOB 컬럼 정보를 저장하기 위해
    // 테이블 컬럼 정보를 각 테이블 파티션의 컬럼 정보로 복사한다.
    sDstPartAttr->columns  = NULL;

    /* PROJ-2464 hybrid partitioned table 지원 */
    IDE_TEST( qdbCommon::copyAndAdjustColumnList( aStatement,
                                                  sTableInfo->TBSType,
                                                  sDstPartAttr->TBSAttr.mType,
                                                  sTableInfo->columns,
                                                  &(sDstPartAttr->columns),
                                                  sTableInfo->columnCount,
                                                  ID_FALSE /* aEnableVariableColumn */ )
              != IDE_SUCCESS );

    // colSpace를 지정한 TBS로 변경한다.
    // 각 파티션의 TBS는 이미 validateTBSOfPartition 함수에서
    // 결정되어 있다.
    for ( i = 0, sTableColumn = sTableInfo->columns, sTargetColumn = sDstPartAttr->columns;
          sTableColumn != NULL ;
          i++, sTableColumn = sTableColumn->next, sTargetColumn = sTargetColumn->next )
    {
        if ( ( sTableColumn->basicInfo->module->flag & MTD_COLUMN_TYPE_MASK )
             == MTD_COLUMN_TYPE_LOB )
        {
            // 사용자가 파티션드 테이블에 LOB TBS를 지정하지 않은 경우
            // 파티션의 TBS를 따른다.
            IDE_TEST( qcm::getIsDefaultTBS(
                          aStatement,
                          sTableInfo->tableID,
                          (sTableInfo->tableID * SMI_COLUMN_ID_MAXIMUM) + i,
                          & sIsDefaultTBS )
                      != IDE_SUCCESS );

            /* PROJ-2464 hybrid partitioned table 지원
             *  - Disk Partition의 경우, Partitioned의 Lob Column TBS(Default TBS)가
             *    지정되어 있으면 Default TBS를 사용한다.
             *  - PROJ-2334 PMT MEMORY PARTITIONED TABLE : Memory Partition의 경우,
             *    Partition TBS를 사용한다.
             */
            /* PROJ-2465 Tablespace Alteration for Table
             *  - 부족한 Default TBS 처리를 추가한다.
             */
            if ( ( sIsDefaultTBS == ID_TRUE ) &&
                 ( smiTableSpace::isDiskTableSpaceType( sDstPartAttr->TBSAttr.mType ) == ID_TRUE ) &&
                 ( smiTableSpace::isDiskTableSpaceType( sTableInfo->TBSType ) == ID_TRUE ) )
            {
                /* Create시 ColSpace에 설정된 Default TBS를 그대로 이용한다. */
                /* Nothing to do */
            }
            else
            {
                sTargetColumn->basicInfo->column.colSpace = sDstPartAttr->TBSAttr.mID;
            }
        }
        else
        {
            sTargetColumn->basicInfo->column.colSpace = sDstPartAttr->TBSAttr.mID;
        }
    }

    // LOB 컬럼의 TBS를 명시하지 않으면, 파티션의 TBS를 따른다.
    // 인자로 넣은 sTableInfo는 형식적으로 넣은 것이고,
    // 실제로 sDstPartAttr의 TBS를 따르게 된다.
    IDE_TEST(qdbCommon::validateLobAttributeList( aStatement,
                                                  sTableInfo,
                                                  sDstPartAttr->columns,
                                                  &(sDstPartAttr->TBSAttr),
                                                  sDstPartAttr->lobAttr )
             != IDE_SUCCESS);

    IDE_TEST( qcmPartition::getPartitionCount( aStatement,
                                               sTableInfo->tableID,
                                               & sTotalPartCount )
              != IDE_SUCCESS );

    IDU_LIMITPOINT("qdbAlter::validateAddPartition::malloc");
    IDE_TEST(STRUCT_ALLOC_WITH_COUNT(QC_QMP_MEM(aStatement),
                                     qcmPartitionInfoList,
                                     sTotalPartCount,
                                     & sNewPartInfoList)
             != IDE_SUCCESS);

    // ------------------------------------------------------
    // PartInfoList를 PartOrder로 오름차순 정렬한다.
    // ------------------------------------------------------
    for( sTempPartInfoList = sPartInfoList;
         sTempPartInfoList != NULL;
         sTempPartInfoList = sTempPartInfoList->next )
    {
        sPartInfo = sTempPartInfoList->partitionInfo;

        // get Partition Order
        IDE_TEST( qcmPartition::getPartitionOrder( QC_SMI_STMT( aStatement ),
                                                   sTableInfo->tableID,
                                                   (UChar *) sPartInfo->name,
                                                   idlOS::strlen(sPartInfo->name),
                                                   & sPartOrder )
                  != IDE_SUCCESS );

        IDE_TEST( qcmPartition::getPartitionInfo( aStatement,
                                                  sTableInfo->tableID,
                                                  (UChar *)sTempPartInfoList->partitionInfo->name,
                                                  idlOS::strlen(sTempPartInfoList->partitionInfo->name),
                                                  & sNewPartInfoList[sPartOrder].partitionInfo,
                                                  & sNewPartInfoList[sPartOrder].partSCN,
                                                  & sNewPartInfoList[sPartOrder].partHandle )
                  != IDE_SUCCESS );

        sNewPartInfoList[sPartOrder].next = NULL;
    }

    for( sPartOrder = 0;
         sPartOrder < sTotalPartCount;
         sPartOrder++ )
    {
        if( sPartOrder == (sTotalPartCount - 1) )
        {
            sNewPartInfoList[sPartOrder].next = NULL;
        }
        else
        {
            sNewPartInfoList[sPartOrder].next = & sNewPartInfoList[sPartOrder+1];
        }
    }

    sParseTree->partTable->partInfoList = sNewPartInfoList;

    /* PROJ-2464 hybrid partitioned table 지원 */
    IDE_TEST( validateIndexAlterationForPartition( aStatement,
                                                   sTableInfo,
                                                   sTableInfo,
                                                   sDstPartAttr )
              != IDE_SUCCESS );

    // ------------------------------------------------------
    // 인덱스 파티션을 지정한 경우의 validation
    // ------------------------------------------------------

    if ( sDstPartAttr->alterPart->indexPartAttr != NULL )
    {
        IDE_TEST( checkIndexPartAttrList( aStatement,
                                          sTableInfo,
                                          NULL, /* sSrcPartInfo */
                                          NULL, /* sSrcPartAttr */
                                          sDstPartAttr,
                                          sParseTree->userID )
                  != IDE_SUCCESS );
    }
    else
    {
        // Nothing to do
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE));
    }
    IDE_EXCEPTION(ERR_ADD_PARTITION_ON_NONE_HASH_PART_TABLE);
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_ADD_PARTITION_ON_NONE_HASH_PART_TABLE));
    }
    IDE_EXCEPTION(ERR_ALREADY_EXIST_PARTITION_NAME)
    {
        (void)sqlInfo.init(aStatement->qmeMem);
        IDE_SET(ideSetErrorCode( qpERR_ABORT_QDB_ALREADY_EXIST_PARTITION_NAME,
                                 sqlInfo.getErrMessage()) );
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION( ERR_ACCESS_NOT_SUPPORT_MVIEW );
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDM_ACCESS_NOT_SUPPORT_MVIEW ) );
    }
#ifdef ALTI_CFG_EDITION_DISK
    IDE_EXCEPTION( ERR_NOT_SUPPORT_MEMORY_VOLATILE_TABLESPACE_IN_DISK_EDITION );
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_USE_ONLY_DISK_TABLE_PARTITION_IN_DISK_EDITION ) );
    }
#endif
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::validateCoalescePartition( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *    PROJ-1502 PARTITIONED DISK TABLE
 *
 *
 * Implementation :
 *
 ***********************************************************************/

    qdTableParseTree        * sParseTree;
    qcmTableInfo            * sTableInfo;
    qcmTableInfo            * sPartInfo;
    qcmPartitionInfoList    * sPartInfoList = NULL;
    qcmPartitionInfoList    * sTempPartInfoList = NULL;
    qcmPartitionInfoList    * sNewPartInfoList = NULL;
    UInt                      sTotalPartCount = 0;
    UInt                      sPartOrder = 0;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // ------------------------------------------------------
    // 1. ALTER TABLE 구문의 공통적인 validation
    // ------------------------------------------------------
    // 파티션드 테이블에 LOCK(IS)
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_TRUE )
              != IDE_SUCCESS );

    sTableInfo = sParseTree->tableInfo;

    // ------------------------------------------------------
    // 2. 파티션드 테이블인지 체크
    // ------------------------------------------------------
    IDE_TEST_RAISE( sTableInfo->tablePartitionType
                    == QCM_NONE_PARTITIONED_TABLE,
                    ERR_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE );

    // ------------------------------------------------------
    // 해시 파티션드 테이블인지 체크
    // ------------------------------------------------------
    IDE_TEST_RAISE( sTableInfo->partitionMethod != QCM_PARTITION_METHOD_HASH,
                    ERR_COALESCE_PARTITION_ON_NONE_HASH_PART_TABLE );

    // ------------------------------------------------------------
    // 파티션 정보, Handle, SCN의 리스트를 구해서 파스트리에 달아놓는다.
    // ------------------------------------------------------------

    // 모든 파티션에 LOCK(IS)
    // 파티션 리스트를 파스트리에 달아놓는다.
    IDE_TEST( qdbCommon::checkAndSetAllPartitionInfo(
                  aStatement,
                  sParseTree->tableInfo->tableID,
                  & (sParseTree->partTable->partInfoList) )
              != IDE_SUCCESS );

    // PROJ-1624 non-partitioned index
    IDE_TEST( qdx::makeAndLockIndexTableList(
                  aStatement,
                  ID_FALSE,
                  sParseTree->tableInfo,
                  &(sParseTree->oldIndexTables) )
              != IDE_SUCCESS );
    
    sPartInfoList = sParseTree->partTable->partInfoList;

    // ------------------------------------------------------
    // 총 파티션의 개수가 1개인지 체크
    // ------------------------------------------------------
    IDE_TEST( qcmPartition::getPartitionCount( aStatement,
                                               sTableInfo->tableID,
                                               & sTotalPartCount )
              != IDE_SUCCESS );

    IDE_TEST_RAISE( sTotalPartCount < 2,
                    ERR_COALESCE_THE_ONLY_PARTITION);

    IDU_LIMITPOINT("qdbAlter::validateCoalescePartition::malloc");
    IDE_TEST(STRUCT_ALLOC_WITH_COUNT(QC_QMP_MEM(aStatement),
                                     qcmPartitionInfoList,
                                     sTotalPartCount,
                                     & sNewPartInfoList)
             != IDE_SUCCESS);

    // ------------------------------------------------------
    // PartInfoList를 PartOrder로 오름차순 정렬한다.
    // ------------------------------------------------------
    for( sTempPartInfoList = sPartInfoList;
         sTempPartInfoList != NULL;
         sTempPartInfoList = sTempPartInfoList->next )
    {
        sPartInfo = sTempPartInfoList->partitionInfo;

        // get Partition Order
        IDE_TEST( qcmPartition::getPartitionOrder( QC_SMI_STMT( aStatement ),
                                                   sTableInfo->tableID,
                                                   (UChar *) sPartInfo->name,
                                                   idlOS::strlen(sPartInfo->name),
                                                   & sPartOrder )
                  != IDE_SUCCESS );

        IDE_TEST( qcmPartition::getPartitionInfo( aStatement,
                                                  sTableInfo->tableID,
                                                  (UChar *)sTempPartInfoList->partitionInfo->name,
                                                  idlOS::strlen(sTempPartInfoList->partitionInfo->name),
                                                  & sNewPartInfoList[sPartOrder].partitionInfo,
                                                  & sNewPartInfoList[sPartOrder].partSCN,
                                                  & sNewPartInfoList[sPartOrder].partHandle )
                  != IDE_SUCCESS );

        sNewPartInfoList[sPartOrder].next = NULL;
    }

    for( sPartOrder = 0;
         sPartOrder < sTotalPartCount;
         sPartOrder++ )
    {
        if( sPartOrder == (sTotalPartCount - 1) )
        {
            sNewPartInfoList[sPartOrder].next = NULL;
        }
        else
        {
            sNewPartInfoList[sPartOrder].next = & sNewPartInfoList[sPartOrder+1];
        }
    }

    sParseTree->partTable->partInfoList = sNewPartInfoList;

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE));
    }
    IDE_EXCEPTION(ERR_COALESCE_PARTITION_ON_NONE_HASH_PART_TABLE);
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_COALESCE_PARTITION_ON_NONE_HASH_PART_TABLE));
    }
    IDE_EXCEPTION(ERR_COALESCE_THE_ONLY_PARTITION)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_COALESCE_THE_ONLY_PARTITION));
    }

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::validateAccessPartition( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *    PROJ-2359 Table/Partition Access Option
 *
 *    ALTER TABLE table ACCESS PARTITION partition READ { ONLY | WRITE | APPEND };
 *
 * Implementation :
 *
 ***********************************************************************/

    qdTableParseTree        * sParseTree;
    qcmTableInfo            * sTableInfo;
    qdPartitionAttribute    * sPartAttr;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // ------------------------------------------------------
    // 1. ALTER TABLE 구문의 공통적인 validation
    // ------------------------------------------------------
    // 파티션드 테이블에 LOCK(IS)
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_FALSE )
              != IDE_SUCCESS );

    sTableInfo = sParseTree->tableInfo;

    // ------------------------------------------------------
    // 2. 파티션드 테이블인지 체크
    // ------------------------------------------------------
    IDE_TEST_RAISE( sTableInfo->tablePartitionType == QCM_NONE_PARTITIONED_TABLE,
                    ERR_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE );

    sPartAttr = sParseTree->partTable->partAttr;

    // ------------------------------------------------------
    // 3. ACCESS 가능 테이블 타입 검사
    // ------------------------------------------------------
    IDE_TEST_RAISE( sTableInfo->tableType == QCM_MVIEW_TABLE,
                    ERR_ACCESS_NOT_SUPPORT_MVIEW );

    // ------------------------------------------------------
    // 4. 파티션 이름 validation
    // ------------------------------------------------------
    IDE_TEST( qdbCommon::checkPartitionInfo( aStatement,
                                             sTableInfo,
                                             sPartAttr->tablePartName )
              != IDE_SUCCESS );

    // ------------------------------------------------------
    // 5. 이미 지정한 ACCESS로 지정하는지 검사
    // ------------------------------------------------------
    if ( sParseTree->partTable->partInfoList->partitionInfo->accessOption == sPartAttr->accessOption )
    {
        sParseTree->common.execute = qcc::execute;
    }
    else
    {
        /* Nothing to do */
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_CANNOT_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE ) );
    }
    IDE_EXCEPTION( ERR_ACCESS_NOT_SUPPORT_MVIEW );
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDM_ACCESS_NOT_SUPPORT_MVIEW ) );
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::validateAlterCommon( qcStatement * aStatement,
                                      idBool        aIsRepCheck )
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE 구문의 공통적인 validation
 *
 * Implementation :
 *    1. 원격 객체를 지정한 경우 체크
 *    2. 테이블 존재 여부 체크
 *    3. 테이블의 소유자가 SYSTEM_ 이면 alter 불가능
 *    4. alter table 권한이 있는지 체크
 *    5. 테이블에 이중화가 걸려있으면 에러
 *
 ***********************************************************************/

    qdTableParseTree    * sParseTree;
    qcuSqlSourceInfo      sqlInfo;
    
    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    /* BUG-30059 */
    if ( qdbCommon::containDollarInName( &(sParseTree->tableName) ) == ID_TRUE )
    {
        sqlInfo.setSourceInfo(
            aStatement,
            &(sParseTree->tableName) );

        IDE_RAISE( CANT_USE_RESERVED_WORD );
    }

    // check table exist.
    IDE_TEST( qdbCommon::checkTableInfo( aStatement,
                                         sParseTree->userName,
                                         sParseTree->tableName,
                                         &(sParseTree->userID),
                                         &(sParseTree->tableInfo),
                                         &(sParseTree->tableHandle),
                                         &(sParseTree->tableSCN))
              != IDE_SUCCESS);

    // 파티션드 테이블에 LOCK(IS)
    IDE_TEST( qcm::lockTableForDDLValidation(aStatement,
                                             sParseTree->tableHandle,
                                             sParseTree->tableSCN)
              != IDE_SUCCESS );

    if ( QCG_GET_SESSION_USER_ID(aStatement) != QC_SYSTEM_USER_ID )
    {
        // sParseTree->userID is a owner of table
        IDE_TEST_RAISE(sParseTree->userID == QC_SYSTEM_USER_ID,
                       ERR_NOT_ALTER_META);
    }
    else
    {
        if ( ( aStatement->session->mQPSpecific.mFlag
               & QC_SESSION_ALTER_META_MASK )
             == QC_SESSION_ALTER_META_DISABLE )
        {
            IDE_RAISE(ERR_NOT_ALTER_META);
        }
    }

    // PR-13725
    // CHECK OPERATABLE
    IDE_TEST( qdbAlter::checkOperatable( aStatement,
                                         sParseTree->tableInfo )
              != IDE_SUCCESS );
    
    /* PROJ-1090 Function-based Index */
    if ( sParseTree->addHiddenColumn != ID_TRUE )
    {
        // check grant
        IDE_TEST( qdpRole::checkDDLAlterTablePriv( aStatement,
                                                   sParseTree->tableInfo )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    // if specified tables is replicated, the error
    // fix BUG-19011
    if ( aIsRepCheck == ID_TRUE )
    {
        IDE_TEST_RAISE( sParseTree->tableInfo->replicationCount > 0,
                        ERR_DDL_WITH_REPLICATED_TABLE );
        //proj-1608:replicationCount가 0일 때 recovery count는 항상 0이어야 함
        IDE_DASSERT( sParseTree->tableInfo->replicationRecoveryCount == 0 );
    }
    else
    {
        // Nothing to do
    }

    /* PROJ-1723 [MDW/INTEGRATOR] Altibase Plugin 개발
       DDL Statement Text의 로깅
    */
    if (QCU_DDL_SUPPLEMENTAL_LOG == 1)
    {
        IDE_TEST( qciMisc::writeDDLStmtTextLog( aStatement,
                                                sParseTree->tableInfo->tableOwnerID,
                                                sParseTree->tableInfo->name )
                  != IDE_SUCCESS );
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_DDL_WITH_REPLICATED_TABLE )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_DDL_WITH_REPLICATED_TBL ) );
    }
    IDE_EXCEPTION(ERR_NOT_ALTER_META);
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDD_NO_DROP_META_TABLE));
    }
    IDE_EXCEPTION( CANT_USE_RESERVED_WORD );
    {
        (void)sqlInfo.init(aStatement->qmeMem);
        IDE_SET(
            ideSetErrorCode(qpERR_ABORT_QDB_RESERVED_WORD_IN_OBJECT_NAME,
                            sqlInfo.getErrMessage() ));
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::executeAddColByRecreateTable(
    qcStatement           * aStatement,          // in
    qdTableParseTree      * aParseTree,          // in
    idBool                  aIsPartitioned,      // in
    UInt                    aPartitionCount,     // in
    UInt                  * aPartitionID,        // in
    UInt                    aNewColCnt,          // in
    qcmColumn             * aNewTableColumn,     // in
    qcmColumn            ** aNewPartitionColumn, // in
    smOID                 * aNewTableOID,        // out
    smOID                ** aNewPartitionOID,    // out
    qcmTableInfo         ** aNewTableInfo,       // out
    qcmPartitionInfoList ** aNewPartInfoList )   // out
{
/***********************************************************************
 *
 * Description :
 *    ADD COL을 위하여 Recreate Table
 *
 * Implementation :
 *
 *    1. 추가되는 인덱스 정보를 새로운 영역으로 복사
 *    2. 새로운 Table 생성
 *    3. Meta에서 기존 column spec 삭제
 *    4. Meta에 새로운 column spec 삽입
 *    5. 새로운 Table에 constraint 재 생성
 *    6. 새로운 Table에 index 재 생성
 *    7. Meta Cache 재 구성
 *    8. 새로운 Column에 대한 constraint와 index 생성
 *    9. 기존 table의 record들을 새로운 table로 move
 *    10. not null constraint 생성
 *    11. Meta Cache 재 구성
 *
 ************************************************************************/

    UInt                      sTableID;
    qcmIndex                * sNewTableIndex = NULL;
    qcmIndex               ** sNewPartIndex  = NULL;
    UInt                      sNewPartIndexCount = 0;
    qcmPartitionInfoList    * sCurPartInfoList  = NULL;
    qcmTableInfo            * sPartInfo  = NULL;
    smOID                     sNewTableOID;
    smOID                   * sNewPartitionOID  = NULL;
    void                   ** sOldPartitionHandle  = NULL;
    qmsTableRef             * sOldTableRef = NULL;
    qcmTableInfo            * sOldTableInfo  = NULL;
    qcmTableInfo            * sNewTableInfo  = NULL;
    qcmTableInfo           ** sNewPartitionInfoArr  = NULL;
    qcmPartitionInfoList    * sOldPartInfoList = NULL;
    qcmPartitionInfoList    * sNewPartInfoList = NULL;
    qdConstraintSpec        * sConstraint = NULL;
    qcmColumn               * sNewColumnAdded = NULL;
    qcmPartitionInfoList    * sSrcPartInfoList = NULL;
    qcmPartitionInfoList    * sDstPartInfoList = NULL;
    qcmTableInfo            * sSrcPartInfo = NULL;
    qcmTableInfo            * sDstPartInfo = NULL;
    smSCN                     sSCN;
    void                    * sOldTableHandle = NULL;
    void                    * sNewTableHandle = NULL;
    qdIndexTableList        * sIndexTable;
    UInt                      i;

    smiSegAttr                sSegAttr;
    smiSegStorageAttr         sSegStoAttr;
    UInt                      sPartType = 0;

    /* BUG-44230 ADD, DROP, MODIFY, REORGANIZE DDL의 INDEX, CONSTRAINT 생성 순서 변경 */
    SInt                  sCountDiskType = 0;
    SInt                  sCountMemType  = 0;
    SInt                  sCountVolType  = 0;
    UInt                  sTableType     = 0;

    //-----------------
    // 지역 변수 초기화
    //-----------------

    sTableID             = aParseTree->tableInfo->tableID;
    sOldTableInfo        = aParseTree->tableInfo;
    sOldPartInfoList     = aParseTree->partTable->partInfoList;
    sOldTableHandle      = sOldTableInfo->tableHandle;

    //-----------------------------------------------------
    // 새로운 Index 정보 구축을 위한 공간 할당
    //-----------------------------------------------------

    if (sOldTableInfo->indexCount > 0)
    {
        IDU_FIT_POINT( "qdbAlter::executeAddColByRecreateTable::alloc::sNewTableIndex",
                        idERR_ABORT_InsufficientMemory );

        // for non-partitioned, partitioned index
        IDE_TEST(aStatement->qmxMem->alloc(
                ID_SIZEOF(qcmIndex) * sOldTableInfo->indexCount,
                (void**)&sNewTableIndex)
            != IDE_SUCCESS);

        idlOS::memcpy(sNewTableIndex,
                      sOldTableInfo->indices,
                      ID_SIZEOF(qcmIndex) * sOldTableInfo->indexCount);

        // for index partition
        // fix BUG-18706
        if( aIsPartitioned == ID_TRUE )
        {
            IDU_LIMITPOINT("qdbAlter::executeAddColByRecreateTable::malloc2");
            IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(qcmIndex*) *
                                               aPartitionCount,
                                               (void**)& sNewPartIndex)
                     != IDE_SUCCESS);

            for( sCurPartInfoList = sOldPartInfoList, i = 0;
                 sCurPartInfoList != NULL;
                 sCurPartInfoList = sCurPartInfoList->next, i++ )
            {
                sPartInfo = sCurPartInfoList->partitionInfo;

                if ( sPartInfo->indexCount > 0 )
                {
                    IDU_LIMITPOINT("qdbAlter::executeAddColByRecreateTable::malloc3");
                    IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(qcmIndex) *
                                                       sPartInfo->indexCount,
                                                       (void**)&sNewPartIndex[i])
                             != IDE_SUCCESS);
                    
                    if ( sNewPartIndexCount == 0 )
                    {
                        sNewPartIndexCount = sPartInfo->indexCount;
                    }
                    else
                    {
                        IDE_DASSERT( sNewPartIndexCount == sPartInfo->indexCount );
                    }
                    
                    idlOS::memcpy( sNewPartIndex[i],
                                   sPartInfo->indices,
                                   ID_SIZEOF(qcmIndex) * sPartInfo->indexCount );
                }
                else
                {
                    // 모두 non-partitioned index만 생성된 경우
                    sNewPartIndex[i] = NULL;
                }
            }
        }
        else
        {
            // Nothing to do
        }
    }
    else
    {
        // Nothing to do
    }

    //-----------------------------------------------------
    // 새로운 table 생성
    //-----------------------------------------------------

    //-------------------
    // create "new" table.
    //-------------------
    IDE_TEST(qdbCommon::createTableOnSM(aStatement,
                                        aNewTableColumn,
                                        sOldTableInfo->tableOwnerID,
                                        sTableID,
                                        sOldTableInfo->maxrows,
                                        sOldTableInfo->TBSID,
                                        sOldTableInfo->segAttr,
                                        sOldTableInfo->segStoAttr,
                                        /* 원본 Table Flag를 통째로 복사 =>
                                           MASK 비트를 를 모두 1로 설정 */
                                        QDB_TABLE_ATTR_MASK_ALL,
                                        sOldTableInfo->tableFlag, /* Flag Value */
                                        sOldTableInfo->parallelDegree,
                                        &sNewTableOID)
             != IDE_SUCCESS);

    // BUG-44814 ddl 구문 수행시 통계정보 복사를 해야함
    smiStatistics::copyTableStats( smiGetTable(sNewTableOID), sOldTableHandle, NULL, 0 );

    // update table spec (tableOID).
    IDE_TEST(qdbCommon::updateTableSpecFromMeta(
                 aStatement,
                 aParseTree->userName,
                 aParseTree->tableName,
                 sTableID,
                 sNewTableOID,
                 sOldTableInfo->columnCount + aNewColCnt,
                 sOldTableInfo->parallelDegree )
             != IDE_SUCCESS);

    //-------------------
    // create "new" partition
    //-------------------
    if( aIsPartitioned == ID_TRUE )
    {
        IDU_LIMITPOINT("qdbAlter::executeAddColByRecreateTable::malloc4");
        IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(void*) * aPartitionCount,
                                           (void**)&sOldPartitionHandle)
                 != IDE_SUCCESS);

        IDU_LIMITPOINT("qdbAlter::executeAddColByRecreateTable::malloc5");
        IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(smOID) * aPartitionCount,
                                           (void**)&sNewPartitionOID)
                 != IDE_SUCCESS);


        // 테이블 파티션 개수만큼 반복
        for( sCurPartInfoList = sOldPartInfoList, i = 0 ;
             sCurPartInfoList != NULL;
             sCurPartInfoList = sCurPartInfoList->next,i++)
        {
            sPartInfo              = sCurPartInfoList->partitionInfo;
            sOldPartitionHandle[i] = sPartInfo->tableHandle;
            sPartType              = sPartInfo->tableFlag & SMI_TABLE_TYPE_MASK;

            /* MASK-2464 hybrid partitioned table 지원
             *  - Partition Info를 구성할 때에, Table Option을 Partitioned Table의 값으로 복제한다.
             *  - 따라서, PartInfo의 정보를 이용하지 않고, TBSID에 따라 적합한 값으로 조정해서 이용한다.
             */
            qdbCommon::adjustPhysicalAttr( sPartType,
                                           sOldTableInfo->segAttr,
                                           sOldTableInfo->segStoAttr,
                                           & sSegAttr,
                                           & sSegStoAttr,
                                           ID_TRUE /* aIsTable */ );

            IDE_TEST(qdbCommon::createTableOnSM(aStatement,
                                                aNewPartitionColumn[i],
                                                sOldTableInfo->tableOwnerID,
                                                sTableID,
                                                sOldTableInfo->maxrows,
                                                sPartInfo->TBSID,
                                                sSegAttr,
                                                sSegStoAttr,
                                                /* 원본 Table Flag를
                                                   통째로 복사 */
                                                QDB_TABLE_ATTR_MASK_ALL,
                                                sOldTableInfo->tableFlag, /* Flag Value */
                                                sOldTableInfo->parallelDegree,
                                                &sNewPartitionOID[i])
                     != IDE_SUCCESS);

            // BUG-44814 ddl 구문 수행시 통계정보 복사를 해야함
            smiStatistics::copyTableStats( smiGetTable(sNewPartitionOID[i]), sPartInfo->tableHandle, NULL, 0 );

            IDE_TEST(qdbCommon::updatePartTableSpecFromMeta( aStatement,
                                                             sTableID,
                                                             aPartitionID[i],
                                                             sNewPartitionOID[i] )
                     != IDE_SUCCESS );
        }
    }

    //-----------------------------------------------------
    // Meta에서 기존 column spec 삭제
    //-----------------------------------------------------

    // delete invalidated column spec from meta.
    IDE_TEST(deleteColumnSpecFromMeta(aStatement, sTableID)
             != IDE_SUCCESS);

    // PROJ-1502 PARTITIONED DISK TABLE
    if( aIsPartitioned == ID_TRUE )
    {
        IDE_TEST(deletePartKeyColumnSpecFromMeta(aStatement,
                                                 sTableID,
                                                 QCM_TABLE_OBJECT_TYPE)
                 != IDE_SUCCESS);

        IDE_TEST(deletePartLobSpecFromMeta(aStatement, sTableID)
                 != IDE_SUCCESS);
    }

    // SYSTME User의 SYS_CONSTRAINTS_ Table 변경일때에는 Constraint 삭제를 패스한다.
    if ( ( idlOS::strMatch( QCM_CONSTRAINTS,
                            idlOS::strlen( QCM_CONSTRAINTS ),
                            sOldTableInfo->name,
                            idlOS::strlen( sOldTableInfo->name ) ) != 0 ) ||
         ( sOldTableInfo->tableOwnerID != QC_SYSTEM_USER_ID ) )
    {
        IDE_TEST(qdd::deleteConstraintsFromMeta(aStatement, sTableID)
                 != IDE_SUCCESS);
    }
    else
    {
        // Nothing to do.
    }

    IDE_TEST(deleteIndexSpecFromMeta(aStatement, sTableID)
             != IDE_SUCCESS);


    //-----------------------------------------------------
    // Meta에 새로운 column spec 삽입
    //-----------------------------------------------------

    // insert new column spec into meta.
    IDE_TEST(qdbCommon::insertColumnSpecIntoMeta(aStatement,
                                                 aParseTree->userID,
                                                 sTableID,
                                                 aNewTableColumn,
                                                 ID_FALSE /* is queue */)
             != IDE_SUCCESS);

    // PROJ-1502 PARTITIONED DISK TABLE
    if( aIsPartitioned == ID_TRUE )
    {
        IDE_TEST(qdbCommon::insertPartKeyColumnSpecIntoMeta(
                     aStatement,
                     aParseTree->userID,
                     sTableID,
                     aNewTableColumn,
                     sOldTableInfo->partKeyColumns,
                     QCM_TABLE_OBJECT_TYPE)
                 != IDE_SUCCESS);

        for( i = 0; i < aPartitionCount; i++ )
        {
            IDE_TEST(qdbCommon::insertPartLobSpecIntoMeta(
                         aStatement,
                         aParseTree->userID,
                         sTableID,
                         aPartitionID[i],
                         aNewPartitionColumn[i])
                     != IDE_SUCCESS);
        }
    }

    //-----------------------------------------------------
    // 새로운 table에 constraint와 index 재 생성 후,
    // Meta Cache 재구성
    //-----------------------------------------------------

    // PROJ-1624 non-partitioned index
    // index table은 createIndex시 다시 생성되므로 meta를 위해 미리 지운다.
    if( aIsPartitioned == ID_TRUE )
    {
        for ( sIndexTable = aParseTree->oldIndexTables;
              sIndexTable != NULL;
              sIndexTable = sIndexTable->next )
        {
            IDE_TEST( qdx::dropIndexTable( aStatement,
                                           sIndexTable,
                                           ID_FALSE /* aIsDropTablespace */ )
                      != IDE_SUCCESS );
        }
    }
    else
    {
        // Nothing to do.
    }

    /* BUG-44230 ADD, DROP, MODIFY, REORGANIZE DDL의 INDEX, CONSTRAINT 생성 순서 변경 */
    sTableType = sOldTableInfo->tableFlag & SMI_TABLE_TYPE_MASK;

    /* - Partition 구성을 검사한다. */
    qdbCommon::getTableTypeCountInPartInfoList( & sTableType,
                                                sOldPartInfoList,
                                                & sCountDiskType,
                                                & sCountMemType,
                                                & sCountVolType );

    /* - Memory 매체가 있거나, Index Table이 있다면, Index를 먼저 생성한다. */
    if ( ( ( sCountMemType + sCountVolType ) > 0 ) ||
         ( aParseTree->oldIndexTables != NULL ) )
    {
        IDE_TEST( qdbCommon::createConstraintFromInfo( aStatement,
                                                       sOldTableInfo,
                                                       sNewTableOID,
                                                       aPartitionCount,
                                                       sNewPartitionOID,
                                                       SMI_INDEX_BUILD_UNCOMMITTED_ROW_ENABLE,
                                                       sNewTableIndex,
                                                       sNewPartIndex,
                                                       sNewPartIndexCount,
                                                       aParseTree->oldIndexTables,
                                                       &( aParseTree->newIndexTables ),
                                                       NULL )
                  != IDE_SUCCESS );

        IDE_TEST( qdbCommon::createIndexFromInfo( aStatement,
                                                  sOldTableInfo,
                                                  sNewTableOID,
                                                  aPartitionCount,
                                                  sNewPartitionOID,
                                                  SMI_INDEX_BUILD_UNCOMMITTED_ROW_ENABLE,
                                                  sNewTableIndex,
                                                  sNewPartIndex,
                                                  sNewPartIndexCount,
                                                  aParseTree->oldIndexTables,
                                                  &( aParseTree->newIndexTables ),
                                                  NULL,
                                                  ID_TRUE )
                  != IDE_SUCCESS );

        /* PROJ-1624 global non-partitioned index
         *  - Index Meta에서 Index Table Id를 갱신한다.
         */
        if ( aIsPartitioned == ID_TRUE )
        {
            for ( i = 0;
                  i < sOldTableInfo->indexCount;
                  i++ )
            {
                if ( ( sOldTableInfo->indices[i].indexPartitionType == QCM_NONE_PARTITIONED_INDEX ) &&
                     ( sOldTableInfo->indices[i].indexTableID != sNewTableIndex[i].indexTableID ) )
                {
                    IDE_TEST( qdx::updateIndexSpecFromMeta( aStatement,
                                                            sOldTableInfo->indices[i].indexId,
                                                            sNewTableIndex[i].indexTableID )
                              != IDE_SUCCESS );
                }
                else
                {
                    /* Nothing to do */
                }
            }
        }
        else
        {
            /* Nothing to do */
        }
    }
    else
    {
        /* Nothing to do */
    }
    
    // Meta Cache( Table Header에 저장된 qcmTableInfo ) 재구성
    IDE_TEST(qcm::makeAndSetQcmTableInfo( QC_SMI_STMT( aStatement ),
                                          sTableID,
                                          sNewTableOID ) != IDE_SUCCESS);

    IDE_TEST(qcm::getTableInfoByID(aStatement,
                                   sTableID,
                                   &sNewTableInfo,
                                   &sSCN,
                                   &sNewTableHandle)
             != IDE_SUCCESS);

    // PROJ-1502 PARTITIONED DISK TABLE
    if( aIsPartitioned == ID_TRUE )
    {
        // 새로운 qcmPartitionInfo들의 pointer정보를 가지는 배열 생성
        IDU_LIMITPOINT("qdbAlter::executeAddColByRecreateTable::malloc6");
        IDE_TEST( aStatement->qmxMem->cralloc(
                      ID_SIZEOF(qcmTableInfo*) * aPartitionCount,
                      (void**) & sNewPartitionInfoArr )
                  != IDE_SUCCESS);

        for( i = 0; i < aPartitionCount; i++ )
        {
            IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                          QC_SMI_STMT(aStatement),
                          aPartitionID[i],
                          sNewPartitionOID[i],
                          sNewTableInfo )
                      != IDE_SUCCESS );

            IDE_TEST( smiGetTableTempInfo( smiGetTable( sNewPartitionOID[i]),
                                           (void**)&sNewPartitionInfoArr[i] )
                != IDE_SUCCESS );
        }

        IDE_TEST( qcmPartition::getPartitionInfoList( aStatement,
                                                      QC_SMI_STMT(aStatement),
                                                      aStatement->qmxMem,
                                                      sTableID,
                                                      & sNewPartInfoList )
                  != IDE_SUCCESS );

        // 모든 파티션에 LOCK(X)
        IDE_TEST( qcmPartition::validateAndLockPartitionInfoList( aStatement,
                                                                  sNewPartInfoList,
                                                                  SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                                  SMI_TABLE_LOCK_X,
                                                                  ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                                    ID_ULONG_MAX :
                                                                    smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );
    }

    //-----------------------------------------------------
    // 새로운 column에 대한 constraint와 index 생성하고,
    // 기존 table의 record들을 새로운 table로 move하고,
    // 연관된 VIEW Invalidate 시킨 후,
    //  Meta Cache( Table Header에 저장된 qcmTableInfo ) 재구성
    //-----------------------------------------------------

    // create constraint on new column.
    for (sConstraint = aParseTree->constraints;
         sConstraint != NULL;
         sConstraint = sConstraint->next)
    {
        sNewColumnAdded = aNewTableColumn;
        while (sNewColumnAdded != NULL)
        {
            if ( QC_IS_NAME_MATCHED( sNewColumnAdded->namePos, sConstraint->constraintColumns->namePos ) )
            {
                break;
            }
            else
            {
                sNewColumnAdded = sNewColumnAdded->next;
            }
        }
        IDE_ASSERT( sNewColumnAdded != NULL );

        sConstraint->constraintColumns->basicInfo = sNewColumnAdded->basicInfo;

        IDE_TEST(qdbCommon::createConstrPrimaryUnique(
                     aStatement,
                     sNewTableOID,
                     sConstraint,
                     aParseTree->userID,
                     sTableID,
                     sNewPartInfoList,
                     sOldTableInfo->maxrows )
                 != IDE_SUCCESS);

        IDE_TEST(qdbCommon::createConstrNotNull(aStatement,
                                                sConstraint,
                                                aParseTree->userID,
                                                sTableID)
                 != IDE_SUCCESS);

        IDE_TEST(qdbCommon::createConstrTimeStamp(aStatement,
                                                  sConstraint,
                                                  aParseTree->userID,
                                                  sTableID)
                 != IDE_SUCCESS);
    }

    // create constraint on new column.
    for (sConstraint = aParseTree->constraints;
         sConstraint != NULL;
         sConstraint = sConstraint->next)
    {
        IDE_TEST(qdbCommon::createConstrForeign(aStatement,
                                                sConstraint,
                                                aParseTree->userID,
                                                sTableID)
                 != IDE_SUCCESS);
    }

    /* PROJ-1090 Function-based Index */
    if ( aParseTree->addHiddenColumn == ID_TRUE )
    {
        IDE_TEST( qdbCommon::createIndexFromIndexParseTree(
                      aStatement,
                      aParseTree->createIndexParseTree,
                      sNewTableOID,
                      sNewTableInfo,
                      sTableID,
                      sNewPartInfoList )
                  != IDE_SUCCESS );

        sOldTableRef = aParseTree->createIndexParseTree->
            defaultExprFrom->tableRef;
    }
    else
    {
        // Nothing to do.
    }
    
    //  Meta Cache( Table Header에 저장된 qcmTableInfo ) 재구성
    (void)qcm::destroyQcmTableInfo(sNewTableInfo);
    sNewTableInfo = NULL;

    IDE_TEST(qcm::makeAndSetQcmTableInfo(QC_SMI_STMT( aStatement ),
                                         sTableID,
                                         sNewTableOID) != IDE_SUCCESS);

    IDE_TEST(qcm::getTableInfoByID(aStatement,
                                   sTableID,
                                   &sNewTableInfo,
                                   &sSCN,
                                   &sNewTableHandle)
             != IDE_SUCCESS);

    IDE_TEST( qcm::validateAndLockTable(aStatement,
                                        sNewTableHandle,
                                        sSCN,
                                        SMI_TABLE_LOCK_X)
              != IDE_SUCCESS );
    
    // BUG-15936
    // copy new mtcColumn
    IDE_TEST( copyColInfo(aNewTableColumn, sNewTableInfo->columns)
              != IDE_SUCCESS );

    //-----------------------------------------------------
    // 기존 table의 record들을 새로운 table로 move
    //-----------------------------------------------------

    /* BUG-20992: TC/Server/sm4/PRJ-1548/dynmem/../suites/conc_disk/dt_dt.sql에서 서버사망
     *
     * 원인: Disk Table에 대해서 Alter Table Add, Drop시 Table을 생성하고 Record를
     * Insert하다가 비정상 종료시 Alter시 만들어지 Table은 Memory Refine시 Free되지만 Insert
     * 된 Record에 대해서는 Disk Ager가 Startup 후에 계속 삭제한다. 이 때 Disk Ager는
     * 이 Table이 Drop이 되었기 때문에 Skip을 하는데 문제는 이 Free된 Table이 할당될 경우
     * Disk Ager는 Free Record연산을 합니다. 결국 이미 삭제된 Table에 대해서 Free연산을 하게
     * 됩니다.
     *
     * 해결: 이런 문제를 피하기 위해서는 어짜피 Alter가 실패하면 생성된 Table이 Drop될 것이
     * 기 때문에 Undo Log를 기록하지 않음으로써 Ager가 Record를 Free하는 일이 없도록 합니다.
     * moverow시에 undo log가 기록되지 않도록 합니다. 그런데 문제는 이렇게 하다보니 Index에
     * Key가 Insert되지 않는 문제가 있습니다. 왜냐면 Index에 Key Insert는 insert 를 수행시
     * table에 레코드를 Insert후 Insert시 사용한 Cursor를 Close시에 Insert Undo Record를
     * 읽어서 Table에 Record를 Insert합니다. 그런데 Insert Undo Record가 기록되지 않았기 때문
     * 에 Insert가 되지 않아서 Alter시에 moverows를 먼저 수행 후 Index에 Key를 Insert하는
     * 것으로 Logic을 변경하였습니다.
     *
     * 주의: Alter Table Add Column과 같이 새로운 Table을 생성하고 Insert시에 새로운 Table에
     * Record를 삽입후에 Index를 생성해야 합니다.
     * */

    // PROJ-1502 PARTITIONED DISK TABLE
    if( aIsPartitioned == ID_TRUE )
    {
        sSrcPartInfoList = sOldPartInfoList;
        sDstPartInfoList = sNewPartInfoList;

        for( i = 0; i < aPartitionCount; i++ )
        {
            // move row from old to new.
            // drop old table partitions
            sSrcPartInfo = sSrcPartInfoList->partitionInfo;
            sDstPartInfo = sDstPartInfoList->partitionInfo;

            IDE_TEST( copyColInfo(aNewPartitionColumn[i],
                                  sDstPartInfo->columns)
                      != IDE_SUCCESS );

            IDE_TEST(moveRow(aStatement,
                             sOldTableRef,
                             sOldTableInfo,
                             sOldPartitionHandle[i],
                             smiGetTable( sNewPartitionOID[i] ),
                             sSrcPartInfo->columns,
                             aNewPartitionColumn[i],
                             sNewTableInfo,
                             aParseTree->newIndexTables,
                             ID_FALSE /* No Undo Logging */)
                     != IDE_SUCCESS);

            sSrcPartInfoList = sSrcPartInfoList->next;
            sDstPartInfoList = sDstPartInfoList->next;
        }
        // drop old partitioned table
        IDE_TEST( smiTable::dropTable( QC_SMI_STMT( aStatement ),
                                       sOldTableHandle,
                                       SMI_TBSLV_DDL_DML )
                  != IDE_SUCCESS);
    }
    else
    {
        // move row from old to new.
        // drop old non-partitioned table
        IDE_TEST(moveRow(aStatement,
                         sOldTableRef,
                         sOldTableInfo,
                         sOldTableHandle,
                         smiGetTable( sNewTableOID),
                         sOldTableInfo->columns,
                         aNewTableColumn,
                         NULL,
                         NULL,
                         ID_FALSE /* No Undo Logging */)
                 != IDE_SUCCESS);
    }

    /* BUG-44230 ADD, DROP, MODIFY, REORGANIZE DDL의 INDEX, CONSTRAINT 생성 순서 변경
     *  - Memory 매체가 없고, Index Table도 없다면, Index를 나중 생성한다.
     */
    if ( ( ( sCountMemType + sCountVolType ) == 0 ) &&
         ( aParseTree->oldIndexTables == NULL ) )
    {
        IDE_TEST( qdbCommon::createConstraintFromInfo( aStatement,
                                                       sOldTableInfo,
                                                       sNewTableOID,
                                                       aPartitionCount,
                                                       sNewPartitionOID,
                                                       SMI_INDEX_BUILD_UNCOMMITTED_ROW_ENABLE,
                                                       sNewTableIndex,
                                                       sNewPartIndex,
                                                       sNewPartIndexCount,
                                                       aParseTree->oldIndexTables,
                                                       &( aParseTree->newIndexTables ),
                                                       NULL )
                  != IDE_SUCCESS );

        IDE_TEST( qdbCommon::createIndexFromInfo( aStatement,
                                                  sOldTableInfo,
                                                  sNewTableOID,
                                                  aPartitionCount,
                                                  sNewPartitionOID,
                                                  SMI_INDEX_BUILD_UNCOMMITTED_ROW_ENABLE,
                                                  sNewTableIndex,
                                                  sNewPartIndex,
                                                  sNewPartIndexCount,
                                                  aParseTree->oldIndexTables,
                                                  &( aParseTree->newIndexTables ),
                                                  NULL,
                                                  ID_TRUE )
                  != IDE_SUCCESS );

        /* PROJ-1624 global non-partitioned index
         *  - Index Meta에서 Index Table Id를 갱신한다.
         */
        if ( aIsPartitioned == ID_TRUE )
        {
            for ( i = 0;
                  i < sOldTableInfo->indexCount;
                  i++ )
            {
                if ( ( sOldTableInfo->indices[i].indexPartitionType == QCM_NONE_PARTITIONED_INDEX ) &&
                     ( sOldTableInfo->indices[i].indexTableID != sNewTableIndex[i].indexTableID ) )
                {
                    IDE_TEST( qdx::updateIndexSpecFromMeta( aStatement,
                                                            sOldTableInfo->indices[i].indexId,
                                                            sNewTableIndex[i].indexTableID )
                              != IDE_SUCCESS );
                }
                else
                {
                    /* Nothing to do */
                }
            }
        }
        else
        {
            /* Nothing to do */
        }

        IDU_FIT_POINT( "qdbAlter::executeAddColByRecreateTable::BUG-44230" );
    }
    else
    {
        /* Nothing to do */
    }

    // 연관된 VIEW Invalidate
    IDE_TEST(qcmView::setInvalidViewOfRelated(
                 aStatement,
                 aParseTree->userID,
                 sOldTableInfo->name,
                 idlOS::strlen((SChar*)sOldTableInfo->name),
                 QS_TABLE) != IDE_SUCCESS);

    //  Meta Cache( Table Header에 저장된 qcmTableInfo ) 재구성
    (void)qcm::destroyQcmTableInfo(sNewTableInfo);
    sNewTableInfo = NULL;

    IDE_TEST(qcm::makeAndSetQcmTableInfo(QC_SMI_STMT( aStatement ),
                                         sTableID,
                                         sNewTableOID) != IDE_SUCCESS);

    IDE_TEST(qcm::getTableInfoByID(aStatement,
                                   sTableID,
                                   &sNewTableInfo,
                                   &sSCN,
                                   &sNewTableHandle)
             != IDE_SUCCESS);

    IDE_TEST( qcm::validateAndLockTable(aStatement,
                                        sNewTableHandle,
                                        sSCN,
                                        SMI_TABLE_LOCK_X)
              != IDE_SUCCESS );

    //-----------------------------------------------------
    //  not null constraint 생성 후,
    //  Meta Cache( Table Header에 저장된 qcmTableInfo ) 재구성
    //-----------------------------------------------------

    if (sNewTableInfo->primaryKey != NULL)
    {
        for ( i = 0; i < sNewTableInfo->primaryKey->keyColCount; i++)
        {
            IDE_TEST(qdbCommon::makeColumnNotNull(
                         aStatement,
                         sNewTableHandle,
                         sNewTableInfo->maxrows,
                         sNewPartInfoList,
                         aIsPartitioned,
                         sNewTableInfo->primaryKey->keyColumns[i].column.id)
                     != IDE_SUCCESS);
        }
    }

    (void)qcm::destroyQcmTableInfo(sNewTableInfo);
    sNewTableInfo = NULL;

    IDE_TEST(qcm::makeAndSetQcmTableInfo(QC_SMI_STMT( aStatement ),
                                         sTableID,
                                         sNewTableOID) != IDE_SUCCESS);

    IDE_TEST(qcm::getTableInfoByID(aStatement,
                                   sTableID,
                                   &sNewTableInfo,
                                   &sSCN,
                                   &sNewTableHandle)
             != IDE_SUCCESS);

    // PROJ-1502 PARTITIONED DISK TABLE
    if( aIsPartitioned == ID_TRUE )
    {
        for( sCurPartInfoList = sNewPartInfoList, i = 0;
             sCurPartInfoList != NULL;
             sCurPartInfoList = sCurPartInfoList->next, i++ )
        {
            IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                          QC_SMI_STMT( aStatement ),
                          aPartitionID[i],
                          sNewPartitionOID[i],
                          sNewTableInfo,
                          NULL )
                      != IDE_SUCCESS );

            IDE_TEST( smiGetTableTempInfo( smiGetTable( sNewPartitionOID[i] ),
                                           (void**)&sCurPartInfoList->partitionInfo )
                      != IDE_SUCCESS );

            (void)qcmPartition::destroyQcmPartitionInfo(sNewPartitionInfoArr[i]);
            sNewPartitionInfoArr[i] = sCurPartInfoList->partitionInfo;
        }

        IDE_TEST( qcmPartition::getPartitionInfoList( aStatement,
                                                      QC_SMI_STMT(aStatement),
                                                      aStatement->qmxMem,
                                                      sTableID,
                                                      & sNewPartInfoList )
                  != IDE_SUCCESS );
    }

    IDE_TEST( qcm::validateAndLockTable(aStatement,
                                        sNewTableHandle,
                                        sSCN,
                                        SMI_TABLE_LOCK_X)
              != IDE_SUCCESS );

    //-----------------------------------------------------
    // 새로 생성한 Table과 Partition의 OID를 반환
    //-----------------------------------------------------

    *aNewTableOID     = sNewTableOID;
    *aNewPartitionOID = sNewPartitionOID;
    *aNewTableInfo    = sNewTableInfo;
    *aNewPartInfoList = sNewPartInfoList;

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    // cleanup new table info
    if( aIsPartitioned == ID_TRUE )
    {
        if ( sNewPartitionInfoArr != NULL )
        {
            for ( i = 0; i < aPartitionCount; i++ )
            {
                (void)qcmPartition::destroyQcmPartitionInfo( sNewPartitionInfoArr[i] );
            }
        }
        
        for ( sIndexTable = aParseTree->newIndexTables;
              sIndexTable != NULL;
              sIndexTable = sIndexTable->next )
        {
            (void)qcm::destroyQcmTableInfo(sIndexTable->tableInfo);
        }
    }

    (void)qcm::destroyQcmTableInfo( sNewTableInfo );

    return IDE_FAILURE;
}

IDE_RC qdbAlter::executeAddColByAlterMeta(
    qcStatement           * aStatement,              // in
    qdTableParseTree      * aParseTree,              // in
    idBool                  aIsPartitioned,          // in
    UInt                    aPartitionCount,         // in
    UInt                  * aPartitionID,            // in
    UInt                    aNewColCnt,              // in
    qcmColumn             * aNewTableColumn,         // in
    mtcColumn             * aNewTableMtcColumn,      // in
    qcmColumn            ** aNewPartitionColumn,     // in
    mtcColumn            ** aNewPartitionMtcColumn,  // in
    qcmTableInfo         ** aNewTableInfo,           // out
    qcmPartitionInfoList ** aNewPartInfoList )       // out
{
/***********************************************************************
 *
 * Description :
 *    ADD COL을 Meta 정보 변경으로 수행 ( column 정보만을 변경 )
 *
 * Implementation :
 *    1. Table Header/Partition Header의 column list 변경
 *    2  SYS_TABLES_ 에서 해당 table의 column count 변경
 *    3  SYS_COLUMNS_ 에 추가될 column 정보 추가
 *    4  새로운 column에 대한 constraint 생성
 *    5. Meta Cache( Table Header에 저장된 qcmTableInfo ) 재구성
 *
 ***********************************************************************/

    UInt                      sTableID;
    smOID                     sTableOID;
    qcmTableInfo            * sOldTableInfo = NULL;
    qcmTableInfo            * sNewTableInfo = NULL;
    void                    * sTableHandle = NULL;
    void                    * sNewTableHandle = NULL;
    smSCN                     sSCN;
    qcmPartitionInfoList    * sOldPartInfoList = NULL;
    qcmPartitionInfoList    * sNewPartInfoList = NULL;
    qcmPartitionInfoList    * sPartInfoList    = NULL;

    //-----------------
    // 지역 변수 초기화
    //-----------------

    sOldTableInfo           = aParseTree->tableInfo;
    sTableID                = sOldTableInfo->tableID;
    sTableHandle            = aParseTree->tableHandle;
    sTableOID               = smiGetTableId(sTableHandle);
    sOldPartInfoList        = aParseTree->partTable->partInfoList;

    //-----------------------------------------------------
    // column 정보 변경 ( 그 변경 내용은 아래와 같음 )
    // (1) Table Header / Partition Header의 column list 변경
    // (2) SYS_TABLES_에서 해당 table의 column count 변경
    // (3) SYS_COLUMNS_에 추가할 column의 정보를 insert
    // (4) 새로운 column에 대한 constraint 생성
    //-----------------------------------------------------

    IDE_TEST( alterColumnInfo4AddCol( aStatement,
                                      aParseTree,
                                      aNewColCnt,
                                      aIsPartitioned,
                                      aPartitionCount,
                                      aPartitionID,
                                      aNewTableColumn,
                                      aNewTableMtcColumn,
                                      aNewPartitionColumn,
                                      aNewPartitionMtcColumn )
              != IDE_SUCCESS );

    //-----------------------------------------------------
    // Meta Cache( Table Header에 저장된 qcmTableInfo ) 재구성
    //-----------------------------------------------------

    IDE_TEST(qcm::makeAndSetQcmTableInfo( QC_SMI_STMT( aStatement ),
                                          sTableID,
                                          sTableOID )
             != IDE_SUCCESS);

    IDE_TEST(qcm::getTableInfoByID( aStatement,
                                    sTableID,
                                    &sNewTableInfo,
                                    &sSCN,
                                    &sNewTableHandle )
             != IDE_SUCCESS);

    IDE_TEST( qcm::validateAndLockTable(aStatement,
                                        sNewTableHandle,
                                        sSCN,
                                        SMI_TABLE_LOCK_X)
              != IDE_SUCCESS );

    // PROJ-1502 PARTITIONED DISK TABLE
    if( aIsPartitioned == ID_TRUE )
    {
        IDE_TEST( qcmPartition::makeAndSetAndGetQcmPartitionInfoList( aStatement,
                                                                      sNewTableInfo,
                                                                      sOldPartInfoList,
                                                                      & sNewPartInfoList )
                  != IDE_SUCCESS );

        // 모든 파티션에 LOCK(X)
        IDE_TEST( qcmPartition::validateAndLockPartitionInfoList( aStatement,
                                                                  sNewPartInfoList,
                                                                  SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                                  SMI_TABLE_LOCK_X,
                                                                  ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                                    ID_ULONG_MAX :
                                                                    smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );
    }

    //-----------------------------------------------------
    // 연관된 VIEW Invalidate 시킨 후,
    //  Meta Cache( Table Header에 저장된 qcmTableInfo ) 재구성
    //-----------------------------------------------------

    // 연관된 VIEW Invalidate
    IDE_TEST(qcmView::setInvalidViewOfRelated(
                 aStatement,
                 aParseTree->userID,
                 sOldTableInfo->name,
                 idlOS::strlen((SChar*)sOldTableInfo->name),
                 QS_TABLE) != IDE_SUCCESS);

    //  Meta Cache( Table Header에 저장된 qcmTableInfo ) 재구성
    (void)qcm::destroyQcmTableInfo(sNewTableInfo);
    sNewTableInfo = NULL;

    IDE_TEST(qcm::makeAndSetQcmTableInfo(QC_SMI_STMT( aStatement ),
                                         sTableID,
                                         sTableOID) != IDE_SUCCESS);

    IDE_TEST(qcm::getTableInfoByID(aStatement,
                                   sTableID,
                                   & sNewTableInfo,
                                   & sSCN,
                                   & sNewTableHandle)
             != IDE_SUCCESS);

    IDE_TEST( qcm::touchTable( QC_SMI_STMT( aStatement ),
                               sTableID,
                               SMI_TBSLV_DDL_DML )
              != IDE_SUCCESS );

    if( aIsPartitioned == ID_TRUE )
    {
        IDE_TEST( qcmPartition::makeAndSetAndGetQcmPartitionInfoList( aStatement,
                                                                      sNewTableInfo,
                                                                      sOldPartInfoList,
                                                                      & sPartInfoList )
                  != IDE_SUCCESS );
        (void)qcmPartition::destroyQcmPartitionInfoList( sNewPartInfoList );
        sNewPartInfoList = sPartInfoList;

        IDE_TEST( qcmPartition::touchPartitionInfoList( QC_SMI_STMT( aStatement ),
                                                        sOldPartInfoList )
                  != IDE_SUCCESS );

        // 모든 파티션에 LOCK(X)
        IDE_TEST( qcmPartition::validateAndLockPartitionInfoList( aStatement,
                                                                  sNewPartInfoList,
                                                                  SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                                  SMI_TABLE_LOCK_X,
                                                                  ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                                    ID_ULONG_MAX :
                                                                    smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );
    }

    IDE_TEST( qcm::validateAndLockTable(aStatement,
                                        sNewTableHandle,
                                        sSCN,
                                        SMI_TABLE_LOCK_X)
              != IDE_SUCCESS );

    *aNewTableInfo    = sNewTableInfo;
    *aNewPartInfoList = sNewPartInfoList;

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    (void)qcm::destroyQcmTableInfo( sNewTableInfo );
    (void)qcmPartition::destroyQcmPartitionInfoList( sNewPartInfoList );

    return IDE_FAILURE;
}


IDE_RC qdbAlter::executeAddCol(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... ADD COL  수행
 *
 * Implementation :
 *    1. Lock 획득
 *       ( Table과 Partition에 대한 Lock을 획득 )
 *    2. Replication 이 걸린 경우,
 *       (a) 프로퍼티 검사
 *       (b) 관련 Receiver Thread 중지
 *    3. 추가될 column의 default value에 대한 validation
 *    4. 기존의 컬럼에 추가되는 컬럼을 포함한 새로운 컬럼 리스트를 구성
 *    5. column 정보 변경 또는 새로운 테이블 생성
 *    6. SYS_REPL_ITEMS_의 TABLE_OID 컬럼 갱신
 *    7. 예전 Meta Cache 삭제
 *    8. Table Meta Log Record 기록
 *
 ***********************************************************************/

    qdTableParseTree        * sParseTree;
    qcmTableInfo            * sOldTableInfo = NULL;
    idBool                    sIsPartitioned;
    qcmPartitionInfoList    * sOldPartInfoList = NULL;
    qcmPartitionInfoList    * sNewPartInfoList = NULL;
    qcmPartitionInfoList    * sCurPartInfoList = NULL;
    smOID                     sOldTableOID;
    UInt                    * sPartitionID  = NULL;
    smOID                   * sOldPartitionOID  = NULL;
    idBool                    sIsReplicatedTable;
    UInt                      sPartitionCount;
    SInt                      sNewColCnt;
    qcmColumn               * sNewColumn  = NULL;
    qdPartitionAttribute    * sCurPartAttr  = NULL;
    qcmColumn               * sNewTableColumn  = NULL;
    mtcColumn               * sNewTableMtcColumn  = NULL;
    qcmColumn              ** sNewPartitionColumn  = NULL;
    mtcColumn              ** sNewPartitionMtcColumn  = NULL;
    idBool                    sRecreateTable;
    smOID                     sNewTableOID;
    smOID                   * sNewPartitionOID = NULL;
    qcmTableInfo            * sNewTableInfo  = NULL;
    qdConstraintSpec        * sConstraint = NULL;
    idBool                    sIsNull;
    UInt                      i;
    qdIndexTableList        * sIndexTable;
    qcmDictionaryTable      * sDictionaryTable;
    qcmDictionaryTable      * sDicTable;
    qcmCompressionColumn    * sCompColumn = NULL;
    UInt                      sTableID;

    smOID                   * sOldTableOIDArray = NULL;
    smOID                   * sNewTableOIDArray = NULL;
    UInt                      sTableOIDCount = 0;

    UInt                      sDDLSupplementalLog = QCU_DDL_SUPPLEMENTAL_LOG;
    UInt                      sDDLRequireLevel = 0;

    //-----------------
    // 지역 변수 초기화
    //-----------------

    sParseTree         = (qdTableParseTree *)aStatement->myPlan->parseTree;
    sIsPartitioned     = ID_FALSE;
    sIsReplicatedTable = ID_FALSE;
    sPartitionCount    = 0;
    sNewColCnt         = 0;
    sRecreateTable     = ID_FALSE;
    sDictionaryTable   = NULL;

    //-----------------------------------------------------
    //  Lock을 획득
    //-----------------------------------------------------

    // BUG-43292 DDL / DDL partiton 연산시 최신 viewSCN을 보지 못함
    IDU_FIT_POINT( "qdbAlter::executeAddCol::beforeXLock" );

    // TASK-2176
    // Table에 대한 Lock을 획득한다.
    IDE_TEST( qcm::validateAndLockTable(aStatement,
                                        sParseTree->tableHandle,
                                        sParseTree->tableSCN,
                                        SMI_TABLE_LOCK_X)
              != IDE_SUCCESS);

    sTableID      = sParseTree->tableInfo->tableID; 

    // 아래 정보들은 Lock 잡은 후에 획득해야 함
    // Lock 잡기 전 tableInfo 정보가 부정확할 수 있으며
    // Lock 잡는 것을 실패하였을 경우,
    // Exception 수행시, 부정확한 tableInfo로 restore하면 문제 발생함
    sOldTableInfo = sParseTree->tableInfo;
    sOldTableOID  = smiGetTableId(sParseTree->tableHandle);
    sNewTableOID  = sOldTableOID; // Recreate Table시에 변경됨

    // PROJ-1407 Temporary table
    // session temporary table이 존재하는 경우 DDL을 할 수 없다.
    IDE_TEST_RAISE( qcuTemporaryObj::existSessionTable( sOldTableInfo ) == ID_TRUE,
                    ERR_SESSION_TEMPORARY_TABLE_EXIST );

    // PROJ-1502 PARTITIONED DISK TABLE 논파티션드 테이블 생성
    // Partition에 대한 Lock 을 획득한다.
    if( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        sIsPartitioned   = ID_TRUE;

        /* BUG-42681 valgrind split 중 add column 동시성 문제 */
        IDE_TEST( qcmPartition::checkPartitionCount4Execute( aStatement,
                                                             sParseTree->partTable->partInfoList,
                                                             sTableID )
                  != IDE_SUCCESS );

        // 모든 파티션에 LOCK(X)
        IDE_TEST( qcmPartition::validateAndLockPartitionInfoList( aStatement,
                                                                  sParseTree->partTable->partInfoList,
                                                                  SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                                  SMI_TABLE_LOCK_X,
                                                                  ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                                    ID_ULONG_MAX :
                                                                    smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );

        // 예외 처리를 위하여, Lock을 잡은 후에 Partition List를 설정한다.
        sOldPartInfoList = sParseTree->partTable->partInfoList;

        // Partition OID 리스트를  저장하기 위하여 Partition 개수도 구함
        for( sCurPartInfoList = sOldPartInfoList;
             sCurPartInfoList != NULL;
             sCurPartInfoList = sCurPartInfoList->next )
        {
            sPartitionCount++;
        }

        // PROJ-1624 non-partitioned index
        IDE_TEST( qdx::validateAndLockIndexTableList( aStatement,
                                                      sParseTree->oldIndexTables,
                                                      SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                      SMI_TABLE_LOCK_X,
                                                      ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                        ID_ULONG_MAX :
                                                        smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );
        
        IDU_FIT_POINT( "qdbAlter::executeAddCol::alloc::sNewPartitionOID",
                        idERR_ABORT_InsufficientMemory );

        IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(smOID) * sPartitionCount,
                                           (void**)&sNewPartitionOID)
                 != IDE_SUCCESS);

        IDU_FIT_POINT( "qdbAlter::executeAddCol::alloc::sOldPartitionOID",
                        idERR_ABORT_InsufficientMemory );

        IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(smOID) * sPartitionCount,
                                           (void**)&sOldPartitionOID)
                 != IDE_SUCCESS);

        IDU_FIT_POINT( "qdbAlter::executeAddCol::alloc::sPartitionID",
                        idERR_ABORT_InsufficientMemory );

        IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(UInt) * sPartitionCount,
                                           (void**)&sPartitionID)
                 != IDE_SUCCESS);

        // Parition ID와 Partition OID 획득
        for( sCurPartInfoList = sOldPartInfoList, i = 0;
             sCurPartInfoList != NULL;
             sCurPartInfoList = sCurPartInfoList->next, i++ )
        {
            sPartitionID[i] = sCurPartInfoList->partitionInfo->partitionID;

            sOldPartitionOID[i] =
                smiGetTableId(sCurPartInfoList->partitionInfo->tableHandle);

            // NewPartitionOID 초기화
            // Recreate Table 방식으로 Add Column이 수행될 경우,
            // NewPartitionOID는 새로 생긴 Partition OID 값을 가질 것임
            sNewPartitionOID[i] = sOldPartitionOID[i];
        }
    }

    // BUG-43292 DDL / DDL partiton 연산시 최신 viewSCN을 보지 못함
    IDE_TEST( smiStatement::setViewSCNOfAllStmt( QC_SMI_STMT( aStatement ) )
              != IDE_SUCCESS );

    //------------------------------------------
    // sequence를 처리하기 위한 기본 값 획득
    //------------------------------------------

    // check session cache SEQUENCE.CURRVAL
    if (aStatement->myPlan->parseTree->currValSeqs != NULL)
    {
        IDE_TEST(qmx::findSessionSeqCaches(aStatement,
                                           aStatement->myPlan->parseTree)
                 != IDE_SUCCESS);
    }
    else
    {
        // Nothing to do
    }

    // get SEQUENCE.NEXTVAL
    if (aStatement->myPlan->parseTree->nextValSeqs != NULL)
    {
        IDE_TEST(qmx::addSessionSeqCaches(aStatement,
                                          aStatement->myPlan->parseTree)
                 != IDE_SUCCESS);
    }
    else
    {
        // Nothing to do
    }
    
    //-----------------------------------------------------
    // 추가될 칼럼의 default value에 대한 validate
    //-----------------------------------------------------

    // Table의 default value에 대한 validate
    sNewColCnt = 0;
    sNewColumn = sParseTree->columns;
    while (sNewColumn != NULL)
    {
        idlOS::strncpy(sNewColumn->name,
                       sNewColumn->namePos.stmtText +
                       sNewColumn->namePos.offset,
                       sNewColumn->namePos.size);

        // fix BUG-32700
        sNewColumn->name[sNewColumn->namePos.size] = '\0';

        if (sNewColumn->defaultValue != NULL)
        {
            if ( ( sNewColumn->flag & QCM_COLUMN_HIDDEN_COLUMN_MASK)
                 == QCM_COLUMN_HIDDEN_COLUMN_TRUE )
            {
                // hidden column이 add될때 default expression은 미리 계산할 수 없고
                // null 일 수 있다.

                sIsNull = ID_TRUE;
            }
            else
            {
                IDE_TEST(qdbCommon::convertDefaultValueType(
                             aStatement,
                             & sNewColumn->basicInfo->type,
                             sNewColumn->defaultValue,
                             & sIsNull)
                         != IDE_SUCCESS);
            }

            // BUG-26151
            // primary key, not null constraint를 추가할 경우
            // NULL default value를 설정할 수 없다.
            if ( sIsNull == ID_TRUE )
            {
                for (sConstraint = sParseTree->constraints;
                     sConstraint != NULL;
                     sConstraint = sConstraint->next)
                {
                    if ( QC_IS_NAME_MATCHED( sNewColumn->namePos, sConstraint->constraintColumns->namePos ) )
                    {
                        break;
                    }
                    else
                    {
                        // Nothing to do.
                    }
                }

                if ( sConstraint != NULL )
                {
                    IDE_TEST_RAISE(
                        ( sConstraint->constrType == QD_PRIMARYKEY )  ||
                        ( sConstraint->constrType == QD_NOT_NULL ),
                        ERR_CANNOT_SET_NULL_DEFAULT_VALUE );
                }
                else
                {
                    // Nothing to do.
                }
            }
            else
            {
                //BUG-32071
                //default값이 NULL이 아닐때는, ENCRYPT을 사용할 수 없다
                if ( ( sNewColumn->basicInfo->module->flag & MTD_ENCRYPT_TYPE_MASK)
                     == MTD_ENCRYPT_TYPE_TRUE)
                {
                    IDE_RAISE( ERR_CANNOT_SET_DEFAULT_VALUE_WITH_ENCRYPT );
                }
                else
                {
                    // Nothing to do
                }
            }
        }
        else
        {
            // Nothing to do.
        }

        sNewColumn = sNewColumn->next;
        sNewColCnt++;
    }

    //-----------------------------------------------------
    // PROJ-1442 Replication Online 중 DDL 허용을 위한 처리
    //-----------------------------------------------------

    //  Validate와 Execute는 다른 Transaction이므로,
    // 프라퍼티 검사는 Execute에서 한다.
    if(sOldTableInfo->replicationCount > 0)
    {
		sDDLRequireLevel = 0;

        for ( sNewColumn = sParseTree->columns;
              sNewColumn != NULL; 
              sNewColumn = sNewColumn->next )
        {
            if ( ( sNewColumn->flag & QCM_COLUMN_HIDDEN_COLUMN_MASK)
                 == QCM_COLUMN_HIDDEN_COLUMN_TRUE )
            {
                sDDLRequireLevel = 1;
                break;
            }
            else
            {
                /* do nothing */
            }
        }

        for ( sConstraint = ((qdTableParseTree *)aStatement->myPlan->parseTree)->constraints;
              sConstraint != NULL;
              sConstraint = sConstraint->next )
        {
            if ( ( sConstraint->constrType == QD_UNIQUE )     ||
                 ( sConstraint->constrType == QD_LOCAL_UNIQUE ) ||
                 ( sConstraint->constrType == QD_NOT_NULL ) )
            {
                sDDLRequireLevel = 1;
                break;
            }
            else
            {
                /* do nothing */
            }
        }

        IDE_TEST( qci::mManageReplicationCallback.mIsDDLEnableOnReplicatedTable( sDDLRequireLevel,
                                                                                 sOldTableInfo )
                  != IDE_SUCCESS );

        IDE_TEST_RAISE(
            QC_SMI_STMT(aStatement)->getTrans()->getReplicationMode()
            == SMI_TRANSACTION_REPL_NONE,
            ERR_CANNOT_WRITE_REPL_INFO);

        // 관련 Receiver Thread 중지
        if ( sIsPartitioned == ID_TRUE )
        {
            sOldTableOIDArray = sOldPartitionOID;
            sTableOIDCount = sPartitionCount;
        }
        else
        {
            sOldTableOIDArray = &sOldTableOID;
            sTableOIDCount = 1;
        }

        IDE_TEST( qciMisc::checkRunningEagerReplicationByTableOID( aStatement,
                                                                   sOldTableOIDArray,
                                                                   sTableOIDCount )
                  != IDE_SUCCESS );

        // BUG-22703 : Begin Statement를 수행한 후에 Hang이 걸리지
        // 않아야 합니다.
        // mStatistics 통계 정보를 전달 합니다.
        IDE_TEST( qci::mManageReplicationCallback.mStopReceiverThreads( QC_SMI_STMT(aStatement),
                                                                        aStatement->mStatistics,
                                                                        sOldTableOIDArray,
                                                                        sTableOIDCount )
                  != IDE_SUCCESS );

        sIsReplicatedTable = ID_TRUE;
    }

    // 수행 시점의 system time을 획득하여 template에 기록
    IDE_TEST( qtc::setDatePseudoColumn( QC_PRIVATE_TMPLATE( aStatement ) ) != IDE_SUCCESS );

    //-----------------------------------------------------
    // 새로운 column list 구성
    //-----------------------------------------------------

    // 새로운 table 생성에 필요한 column list 생성
    // ( 추가될 칼럼과 기존 칼럼을 합쳐 column list 구성 )
    IDU_FIT_POINT( "qdbAlter::executeAddCol::alloc::sNewTableColumn",
                    idERR_ABORT_InsufficientMemory );

    IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(qcmColumn) *
                                       (sNewColCnt +
                                        sOldTableInfo->columnCount),
                                       (void**)&sNewTableColumn)
             != IDE_SUCCESS);

    IDU_FIT_POINT( "qdbAlter::executeAddCol::alloc::sNewTableMtcColumn",
                    idERR_ABORT_InsufficientMemory );

    IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(mtcColumn) *
                                       (sNewColCnt +
                                        sOldTableInfo->columnCount),
                                       (void**)&sNewTableMtcColumn)
             != IDE_SUCCESS);

    IDE_TEST( addColInfoIntoParseTree(aStatement,
                                      sOldTableInfo,
                                      sParseTree->columns,
                                      sNewTableColumn,
                                      sNewTableMtcColumn)
              != IDE_SUCCESS );

    // 새로운 partition 생성에 필요한 column list 생성
    // ( 추가될 칼럼과 기존 칼럼을 합쳐 column list 구성 )
    if( sIsPartitioned == ID_TRUE )
    {

        IDU_LIMITPOINT("qdbAlter::executeAddCol::malloc6");
        IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(qcmColumn*) *
                                           sPartitionCount,
                                           (void**)& sNewPartitionColumn)
                 != IDE_SUCCESS);

        IDU_LIMITPOINT("qdbAlter::executeAddCol::malloc7");
        IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(mtcColumn*) *
                                           sPartitionCount,
                                           (void**)& sNewPartitionMtcColumn)
                 != IDE_SUCCESS);

        // 테이블 파티션 개수만큼 반복
        // ( sPartAttr의 리스트 개수는 파티션 개수와 동일하다. )
        for( sCurPartInfoList = sOldPartInfoList,
                 sCurPartAttr = sParseTree->partTable->partAttr,
                 i = 0;
             sCurPartInfoList != NULL;
             sCurPartInfoList = sCurPartInfoList->next,
                 sCurPartAttr = sCurPartAttr->next,
                 i++ )
        {
            IDU_LIMITPOINT("qdbAlter::executeAddCol::malloc8");
            IDE_TEST(aStatement->qmxMem->alloc(
                         ID_SIZEOF(qcmColumn) *
                         (sNewColCnt + sOldTableInfo->columnCount),
                         (void**)&sNewPartitionColumn[i])
                     != IDE_SUCCESS);

            IDU_LIMITPOINT("qdbAlter::executeAddCol::malloc9");
            IDE_TEST(aStatement->qmxMem->alloc(
                         ID_SIZEOF(mtcColumn) *
                         (sNewColCnt + sOldTableInfo->columnCount),
                         (void**)&sNewPartitionMtcColumn[i])
                     != IDE_SUCCESS);

            IDE_TEST( addColInfoIntoParseTree(aStatement,
                                              sCurPartInfoList->partitionInfo,
                                              sCurPartAttr->columns,
                                              sNewPartitionColumn[i],
                                              sNewPartitionMtcColumn[i])
                      != IDE_SUCCESS );

        }
    }
    else
    {
        // nothing to do
    }

    // PROJ-2264 Dictionary Table
    for ( sCompColumn = sParseTree->compressionColumn;
          sCompColumn != NULL;
          sCompColumn = sCompColumn->next )
    {
        IDE_TEST( qcmDictionary::makeDictionaryTable(
                      aStatement,
                      sOldTableInfo->TBSID,
                      sNewTableColumn,
                      sCompColumn,
                      &sDictionaryTable )
                  != IDE_SUCCESS );
    }

    //-----------------------------------------------------
    // Add Column 수행
    // (1) ( drop table & create new table )로 수행할 것인지
    //     column 정보만을 변경하도록 수행할 것인지 결정함
    // (2) (1)에서 선택된 방법대로 Add Column 수행
    //-----------------------------------------------------

    IDE_TEST( decideAddColExeMethod( aStatement, sParseTree, &sRecreateTable )
              != IDE_SUCCESS );

    if ( sRecreateTable == ID_TRUE )
    {
        IDE_TEST( executeAddColByRecreateTable( aStatement,
                                                sParseTree,
                                                sIsPartitioned,
                                                sPartitionCount,
                                                sPartitionID,
                                                sNewColCnt,
                                                sNewTableColumn,
                                                sNewPartitionColumn,
                                                & sNewTableOID,
                                                & sNewPartitionOID,
                                                & sNewTableInfo,
                                                & sNewPartInfoList )
                  != IDE_SUCCESS );
    }
    else
    {
        IDE_TEST( executeAddColByAlterMeta( aStatement,
                                            sParseTree,
                                            sIsPartitioned,
                                            sPartitionCount,
                                            sPartitionID,
                                            sNewColCnt,
                                            sNewTableColumn,
                                            sNewTableMtcColumn,
                                            sNewPartitionColumn,
                                            sNewPartitionMtcColumn,
                                            & sNewTableInfo,
                                            & sNewPartInfoList )
                  != IDE_SUCCESS );
    }

    // PROJ-2264 Dictionary Table
    for ( sDicTable = sDictionaryTable;
          sDicTable != NULL;
          sDicTable = sDicTable->next )
    {
        IDE_TEST( qdbCommon::insertCompressionTableSpecIntoMeta(
                     aStatement,
                     sTableID,                                    // data table id
                     sDicTable->dataColumn->basicInfo->column.id, // data table's column id
                     sDicTable->dictionaryTableInfo->tableID,     // dictionary table id
                     sDicTable->dictionaryTableInfo->maxrows )    // dictionary table's max rows
                  != IDE_SUCCESS);
    }

    //-----------------------------------------------------
    // 연관된 view를 찾아, recompile
    //-----------------------------------------------------

    // BUG-11266
    IDE_TEST(qcmView::recompileAndSetValidViewOfRelated(
                 aStatement,
                 sParseTree->userID,
                 sNewTableInfo->name,
                 idlOS::strlen((SChar*)sNewTableInfo->name),
                 QS_TABLE)
             != IDE_SUCCESS);

    // BUG-16543
    IDE_TEST(qdnTrigger::setInvalidTriggerCache4Table( sNewTableInfo )
             != IDE_SUCCESS);

    if ( ( sIsReplicatedTable == ID_TRUE ) ||
         ( sDDLSupplementalLog == 1 ) )
    {
        if ( sIsPartitioned == ID_TRUE )
        {
            sOldTableOIDArray = sOldPartitionOID;
            sNewTableOIDArray = sNewPartitionOID;
            sTableOIDCount = sPartitionCount;
        }
        else
        {
            sOldTableOIDArray = &sOldTableOID;
            sNewTableOIDArray = &sNewTableOID;
            sTableOIDCount = 1;
        }

        //-----------------------------------------------------
        // PROJ-1442 Replication Online 중 DDL 허용
        // SYS_REPL_ITEMS_의 TABLE_OID 컬럼 갱신
        //-----------------------------------------------------
        if ( sIsReplicatedTable == ID_TRUE )
        {
            for ( i = 0; i < sTableOIDCount; i++ )
            {
                IDE_TEST( qci::mCatalogReplicationCallback.mUpdateReplItemsTableOID( QC_SMI_STMT( aStatement ),
                                                                                     sOldTableOIDArray[i],
                                                                                     sNewTableOIDArray[i] )
                          != IDE_SUCCESS );
            }
        }
        else
        {
            /* do nothing */
        }

        //-----------------------------------------------------
        //  PROJ-1442 Replication Online 중 DDL 허용
        //  Table Meta Log Record 기록
        //-----------------------------------------------------
        IDE_TEST( qciMisc::writeTableMetaLogForReplication( aStatement,
                                                            sOldTableOIDArray,
                                                            sNewTableOIDArray,
                                                            sTableOIDCount )
                  != IDE_SUCCESS );
    }
    else
    {
        /* do nothing */
    }

    /* PROJ-2197 PSM Renewal */
    // related PSM
    IDE_TEST(qcmProc::relSetInvalidProcOfRelated(
        aStatement,
        sParseTree->userID,
        sParseTree->tableInfo->name,
        idlOS::strlen((SChar*)sParseTree->tableInfo->name),
        QS_TABLE) != IDE_SUCCESS);

    // PROJ-1073 Package
    IDE_TEST(qcmPkg::relSetInvalidPkgOfRelated(
            aStatement,
            sParseTree->userID,
            sParseTree->tableInfo->name,
            idlOS::strlen((SChar*)sParseTree->tableInfo->name),
            QS_TABLE) != IDE_SUCCESS);

    /* BUG-44230 ADD, DROP, MODIFY, REORGANIZE DDL의 INDEX, CONSTRAINT 생성 순서 변경 */
    IDU_FIT_POINT( "qdbAlter::executeAddCol::BUG-44230" );

    // PROJ-2002 Column Security
    // 보안 컬럼 추가시 보안 모듈에 알린다.
    sNewColumn = sParseTree->columns;

    while (sNewColumn != NULL)
    {
        if ( (sNewColumn->basicInfo->module->flag & MTD_ENCRYPT_TYPE_MASK)
             == MTD_ENCRYPT_TYPE_TRUE )
        {
            (void) qcsModule::setColumnPolicy(
                sOldTableInfo->tableOwnerName,
                sOldTableInfo->name,
                sNewColumn->name,
                sNewColumn->basicInfo->policy );
        }
        else
        {
            // Nothing to do.
        }

        sNewColumn = sNewColumn->next;
    }

    //-----------------------------------------------------
    // 예전 Meta Cache 삭제
    //-----------------------------------------------------

    (void)qcm::destroyQcmTableInfo(sOldTableInfo);

    if( sIsPartitioned == ID_TRUE )
    {
        (void)qcmPartition::destroyQcmPartitionInfoList( sOldPartInfoList );

        // old index table tableinfo 삭제
        if ( sRecreateTable == ID_TRUE )
        {
            for ( sIndexTable = sParseTree->oldIndexTables;
                  sIndexTable != NULL;
                  sIndexTable = sIndexTable->next )
            {
                (void)qcm::destroyQcmTableInfo(sIndexTable->tableInfo);
            }
        }
        else
        {
            // Nothing to do.
        }
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_SESSION_TEMPORARY_TABLE_EXIST )
    {
        IDE_SET(ideSetErrorCode( qpERR_ABORT_QDB_TEMPORARY_TABLE_DDL_DISABLE ));
    }
    IDE_EXCEPTION(ERR_CANNOT_WRITE_REPL_INFO)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_WRITE_REPL_INFO));
    }
    IDE_EXCEPTION(ERR_CANNOT_SET_NULL_DEFAULT_VALUE)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_SET_NULL_DEFAULT_VALUE));
    }
    IDE_EXCEPTION(ERR_CANNOT_SET_DEFAULT_VALUE_WITH_ENCRYPT)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_SET_DEFAULT_VALUE_WITH_ENCRYPT));
    }
    IDE_EXCEPTION_END;

    // PROJ-2264 Dictionary Table
    // DDL 실패시 dictionary table 을 삭제한다.
    for ( sDicTable = sDictionaryTable;
          sDicTable != NULL;
          sDicTable = sDicTable->next )
    {
        // BUG-36719
        // Dictionary table 과 메타테이블은 롤백되어 사라질 것이다.
        // 여기서는 table info 만 해제한다.
        (void)qcm::destroyQcmTableInfo( sDicTable->dictionaryTableInfo );
    }

    (void)qcm::destroyQcmTableInfo( sNewTableInfo );
    (void)qcmPartition::destroyQcmPartitionInfoList( sNewPartInfoList );

    // on fail, must restore old table info.
    qcmPartition::restoreTempInfo( sOldTableInfo,
                                   sOldPartInfoList,
                                   NULL );

    return IDE_FAILURE;
}

// for qdbAlter::executeAddCol.
IDE_RC qdbAlter::addColInfoIntoParseTree(qcStatement    * aStatement,
                                         qcmTableInfo   * aTableInfo,
                                         qcmColumn      * aAddedColumn,
                                         qcmColumn      * aNewTableColumns,
                                         mtcColumn      * aMtcColumns)
{
/***********************************************************************
 *
 * Description :
 *      executeAddCol 로부터 호출, 추가되는 컬럼을 포함한 새로운
 *         컬럼 리스트를 구성
 *
 * Implementation :
 *      1. 기존의 컬럼을 aNewTableColumns 으로 카피
 *      2. 추가되는 컬럼을 aNewTableColumns 으로 1번에 이어서 카피
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::addColInfoIntoParseTree"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY(""));

    qcmColumn  *sColumns;
    SInt        i;
    SInt        sTableID;
    SInt        sCurrentOffset;

    sTableID = aTableInfo->columns->basicInfo->column.id /
        SMI_COLUMN_ID_MAXIMUM;
    if ( smiTableSpace::isMemTableSpaceType( aTableInfo->TBSType ) == ID_TRUE )
    {
        sCurrentOffset = smiGetRowHeaderSize(SMI_TABLE_MEMORY);
    }
    else if ( smiTableSpace::isVolatileTableSpaceType( aTableInfo->TBSType ) == ID_TRUE )
    {
        sCurrentOffset = smiGetRowHeaderSize(SMI_TABLE_VOLATILE);
    }
    else
    {
        IDE_DASSERT( smiTableSpace::isDiskTableSpaceType( aTableInfo->TBSType ) == ID_TRUE );

        sCurrentOffset = 0;
    }

    // copy orgional columns.
    for ( sColumns = aTableInfo->columns,
              i = 0;
          sColumns != NULL;
          sColumns = sColumns->next,
              i++ )
    {
        idlOS::memcpy(&aNewTableColumns[i], sColumns, ID_SIZEOF(qcmColumn));
        idlOS::memcpy(&aMtcColumns[i], sColumns->basicInfo, ID_SIZEOF(mtcColumn));
        aNewTableColumns[i].basicInfo = &aMtcColumns[i];
        aNewTableColumns[i].next = &aNewTableColumns[i+1];

        if ( sColumns->defaultValueStr != NULL )
        {
            IDU_FIT_POINT( "qdbAlter::addColInfoIntoParseTree::alloc::defaultValue",
                            idERR_ABORT_InsufficientMemory );

            IDE_TEST( STRUCT_ALLOC(aStatement->qmxMem,
                                   qtcNode,
                                   &(aNewTableColumns[i].defaultValue))
                      != IDE_SUCCESS);
        }

        // PROJ-1579 NCHAR
        // old column의 default value는 이미 메타 테이블에 저장되어 있음
        aNewTableColumns[i].ncharLiteralPos = NULL;
    }

    // copy added columns
    sColumns = aAddedColumn;

    while (sColumns != NULL)
    {
        idlOS::memcpy(&aNewTableColumns[i], sColumns, ID_SIZEOF(qcmColumn));
        idlOS::memcpy(&aMtcColumns[i], sColumns->basicInfo, ID_SIZEOF(mtcColumn));
        aNewTableColumns[i].basicInfo = &aMtcColumns[i];
        aMtcColumns[i].column.id = sTableID * SMI_COLUMN_ID_MAXIMUM + i;

        sColumns = sColumns->next;
        if (sColumns != NULL)
        {
            aNewTableColumns[i].next = &aNewTableColumns[i+1];
        }
        else
        {
            aNewTableColumns[i].next = NULL;
        }
        i++;
    }

    IDE_TEST( qdbCommon::setColListOffset( aStatement->qmxMem,
                                           aNewTableColumns,
                                           sCurrentOffset )
              != IDE_SUCCESS );

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::copyColInfo(qcmColumn * aNewTableColumns,
                             qcmColumn * aTableColumns)
{
/***********************************************************************
 *
 * Description :
 *      BUG-15936
 *      executeAddCol 로부터 호출, aNewTableColumns의 mtcColumn을
 *      새로 create한 table의 mtcColumn으로 복사한다.
 *
 * Implementation :
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::setColInfoByTableInfo"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY(""));

    qcmColumn  * sSrcColumn;
    qcmColumn  * sDstColumn;

    sSrcColumn = aTableColumns;
    sDstColumn = aNewTableColumns;

    while ( (sSrcColumn != NULL) && (sDstColumn != NULL) )
    {
        IDE_ASSERT(
            (sDstColumn->basicInfo->column.id & SMI_COLUMN_ID_MASK) ==
            (sSrcColumn->basicInfo->column.id & SMI_COLUMN_ID_MASK) );

        // copy basicInfo
        idlOS::memcpy( sDstColumn->basicInfo,
                       sSrcColumn->basicInfo,
                       ID_SIZEOF(mtcColumn) );

        sSrcColumn = sSrcColumn->next;
        sDstColumn = sDstColumn->next;
    }

    IDE_ASSERT( (sSrcColumn == NULL) && (sDstColumn == NULL) );

    return IDE_SUCCESS;

#undef IDE_FN
}

IDE_RC qdbAlter::executeDropCol(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... DROP COLUMN ... 의 execution 수행
 *
 * Implementation :
 *    1. 캐쉬되어 있는 qcmTableInfo 와 테이블 핸들, 테이블 ID 구해두기
 *    2. 컬럼 삭제 후의 컬럼 개수만큼 qcmColumn,mtcColumn 할당받기
 *    3. 삭제 되지 않는 컬럼들의 정보를 1 에서 할당받은 버퍼에 부여
 *    4. 테이블의 인덱스 개수만큼 qcmIndex 버퍼 할당받아서
 *       이전의 인덱스 정보 복사
 *    5. 테이블 새로 생성하여 tableOID 부여받기
 *    6. 1 에서 구해둔 테이블 ID 값으로 메타 테이블에서 인덱스 정보 삭제
 *    7. SYS_TABLES_ 의 tableOID 를 5 에서 구한 값으로 변경
 *    8. 1 에서 구해둔 테이블 ID 값으로 메타 테이블에서 컬럼 정보 삭제
 *    9. 새로운 컬럼 정보를 메타 테이블에 입력
 *    10. 1 에서 구해둔 테이블 ID 값으로 메타 테이블에서 constraint 정보 삭제
 *    11. constraint 새로 생성
 *    12. 인덱스 새로 생성
 *    13. Constraint와 관련된 Procedure에 대한 정보를 삭제
 *    14. Index와 관련된 Procedure에 대한 정보를 삭제
 *    15. 이전 테이블에서 새로 생성된 테이블로 데이터 옮기기 => moveRow 호출
 *    16. related PSM 을 invalid 상태로 변경
 *    17. related VIEW 을 invalid 상태로 변경
 *    18. 메타 캐쉬 재구성
 *
 * Replication이 걸린 Table에 대한 DDL인 경우, 추가적으로 아래의 작업을 한다.
 *    1. Validate와 Execute는 다른 Transaction이므로, 프라퍼티 검사는 Execute에서 한다.
 *    2. Not Null 제약 조건, Function-based Index, Unique Index, Unique Key 제약 조건
 *       check 제약 조건 확인 
 *    3. 관련 Receiver Thread 중지
 *    4. SYS_REPL_ITEMS_의 TABLE_OID 컬럼 갱신
 *    5. Table Meta Log Record 기록
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::executeDropCol"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY(""));

    qdTableParseTree        * sParseTree;
    qcmColumn               * sColumn;
    const void              * sOldTableHandle;
    void                   ** sOldPartitionHandle;
    qcmTableInfo            * sOldTableInfo = NULL;
    qcmColumn               * sNewTableColumn;
    mtcColumn               * sNewMtcColumn;
    SInt                      sColumnCount;
    UInt                      sTableID;
    UInt                    * sPartitionID;
    smSCN                     sSCN;
    qcmTableInfo            * sTempTableInfo = NULL;
    smOID                     sNewTableOID;
    smOID                   * sNewPartitionOID = NULL;
    smOID                     sOldTableOID;
    smOID                   * sOldPartitionOID = NULL;
    qcmIndex                * sNewTableIndex;
    qcmIndex               ** sNewPartIndex    = NULL;
    UInt                      sNewPartIndexCount = 0;
    void                    * sTableHandle;
    idBool                    sIsPartitioned = ID_FALSE;
    qcmPartitionInfoList    * sPartInfoList = NULL;
    qcmPartitionInfoList    * sDstPartInfoList = NULL;
    qcmPartitionInfoList    * sSrcPartInfoList = NULL;
    qcmPartitionInfoList    * sOldPartInfoList = NULL;
    qcmPartitionInfoList    * sNewPartInfoList = NULL;
    qcmTableInfo            * sPartInfo = NULL;
    qcmTableInfo            * sSrcPartInfo = NULL;
    qcmTableInfo            * sDstPartInfo = NULL;
    UInt                      i;
    UInt                      j;
    UInt                      sPartitionCount = 0;
    UInt                      sDelColumnCnt;
    UInt                    * sDelColumnID;
    qcmColumn              ** sNewPartitionColumn = NULL;
    mtcColumn              ** sNewPartitionMtcColumn = NULL;
    idBool                    sIsReplicatedTable = ID_FALSE;
    qcmTableInfo           ** sNewPartitionInfoArr = NULL;
    qdIndexTableList        * sIndexTable;
    qcmTableInfo            * sDicInfo;
    UInt                      sDicTableID;
    qcmCheck                * sCheckConstr;

    smiSegAttr                sSegAttr;
    smiSegStorageAttr         sSegStoAttr;
    UInt                      sPartType = 0;

    smOID                   * sOldTableOIDArray = NULL;
    smOID                   * sNewTableOIDArray = NULL;
    UInt                      sTableOIDCount = 0;

    /* BUG-44230 ADD, DROP, MODIFY, REORGANIZE DDL의 INDEX, CONSTRAINT 생성 순서 변경 */
    SInt                      sCountDiskType = 0;
    SInt                      sCountMemType  = 0;
    SInt                      sCountVolType  = 0;
    UInt                      sTableType     = 0;

    qcmIndex                * sIndexInfo = NULL;
    qcmCheck                * sCheck = NULL;
    UInt                      sDDLRequireLevel = 0;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // BUG-43292 DDL / DDL partiton 연산시 최신 viewSCN을 보지 못함
    IDU_FIT_POINT( "qdbAlter::executeDropCol::beforeXLock" );

    // TASK-2176
    // Table에 대한 Lock을 획득한다.
    IDE_TEST( qcm::validateAndLockTable(aStatement,
                                        sParseTree->tableHandle,
                                        sParseTree->tableSCN,
                                        SMI_TABLE_LOCK_X)
              != IDE_SUCCESS);

    sOldTableInfo = sParseTree->tableInfo;
    sOldTableHandle = sParseTree->tableInfo->tableHandle;
    sOldTableOID = smiGetTableId(sOldTableHandle);

    // PROJ-1407 Temporary table
    // session temporary table이 존재하는 경우 DDL을 할 수 없다.
    IDE_TEST_RAISE( qcuTemporaryObj::existSessionTable( sOldTableInfo ) == ID_TRUE,
                    ERR_SESSION_TEMPORARY_TABLE_EXIST );

    // PROJ-1502 PARTITIONED DISK TABLE
    // 논파티션드 테이블 생성
    if( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        sIsPartitioned = ID_TRUE;

        // -----------------------------------------------------
        // Partition OID 리스트를  저장하기 위한 메모리 크기 계산
        // -----------------------------------------------------

        /* BUG-42681 valgrind split 중 add column 동시성 문제 */
        IDE_TEST( qcmPartition::checkPartitionCount4Execute( aStatement,
                                                             sParseTree->partTable->partInfoList,
                                                             sOldTableInfo->tableID )
                  != IDE_SUCCESS );

        // 모든 파티션에 LOCK(X)
        IDE_TEST( qcmPartition::validateAndLockPartitionInfoList( aStatement,
                                                                  sParseTree->partTable->partInfoList,
                                                                  SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                                  SMI_TABLE_LOCK_X,
                                                                  ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                                    ID_ULONG_MAX :
                                                                    smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );        

        // 예외 처리를 위하여, Lock을 잡은 후에 Partition List를 설정한다.
        sOldPartInfoList = sParseTree->partTable->partInfoList;

        for ( sPartInfoList = sOldPartInfoList;
              sPartInfoList != NULL;
              sPartInfoList = sPartInfoList->next )
        {
            sPartitionCount++;
        }

        // PROJ-1624 non-partitioned index
        IDE_TEST( qdx::validateAndLockIndexTableList( aStatement,
                                                      sParseTree->oldIndexTables,
                                                      SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                      SMI_TABLE_LOCK_X,
                                                      ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                        ID_ULONG_MAX :
                                                        smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );
        
        // OID할당 및 초기화
        IDU_LIMITPOINT("qdbAlter::executeDropCol::malloc1");
        IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(smOID) *
                                           sPartitionCount,
                                           (void**)&sOldPartitionOID)
                 != IDE_SUCCESS);

        for(sPartInfoList = sOldPartInfoList, i = 0;
            sPartInfoList != NULL;
            sPartInfoList = sPartInfoList->next, i++)
        {

            sPartInfo = sPartInfoList->partitionInfo;
            sOldPartitionOID[i] = smiGetTableId(sPartInfo->tableHandle);
        }
    }

    // BUG-43292 DDL / DDL partiton 연산시 최신 viewSCN을 보지 못함
    IDE_TEST( smiStatement::setViewSCNOfAllStmt( QC_SMI_STMT( aStatement ) )
              != IDE_SUCCESS );

    /* PROJ-1442 Replication Online 중 DDL 허용
     * Validate와 Execute는 다른 Transaction이므로, 프라퍼티 검사는 Execute에서 한다.
     */
    if(sOldTableInfo->replicationCount > 0)
    {
        sDDLRequireLevel = 0;

        for ( sColumn = sParseTree->columns;
              sColumn != NULL;
              sColumn = sColumn->next )
        {
            if ( ( sColumn->basicInfo->flag & MTC_COLUMN_NOTNULL_MASK ) ==
                 MTC_COLUMN_NOTNULL_TRUE )
            {
                sDDLRequireLevel = 1;
                break;
            }
            else
            {
                /* do nothing */
            }

            if ( ( sColumn->flag & QCM_COLUMN_HIDDEN_COLUMN_MASK )
                 == QCM_COLUMN_HIDDEN_COLUMN_TRUE )
            {
                sDDLRequireLevel = 1;
                break;
            }
            else
            {
                /* do nothing */
            }

            /* Unique Index */
            for ( i = 0; i < sOldTableInfo->indexCount; i++ )
            {
                sIndexInfo = &sOldTableInfo->indices[i];
                if ( ( sIndexInfo->isUnique == ID_TRUE ) || ( sIndexInfo->isLocalUnique == ID_TRUE ) )
                {
                    if ( qdn::intersectColumn( (UInt*)smiGetIndexColumns( sIndexInfo->indexHandle ),
                                               sIndexInfo->keyColCount,
                                               &(sColumn->basicInfo->column.id), 1 ) == ID_TRUE )
                    {
                        sDDLRequireLevel = 1;
                        break;
                    }
                    else
                    {
                        /* do nothing */
                    }
                }
                else
                {
                    /* do nothing */
                }
            }

            /* Unique Key */
            for ( i = 0; i < sOldTableInfo->uniqueKeyCount; i++ )
            {
                sIndexInfo = sOldTableInfo->uniqueKeys[i].constraintIndex;

                if ( qdn::intersectColumn( (UInt*)smiGetIndexColumns( sIndexInfo->indexHandle ),
                                           sIndexInfo->keyColCount,
                                           &(sColumn->basicInfo->column.id), 1 ) == ID_TRUE )
                {
                    sDDLRequireLevel = 1;
                    break;
                }
                else
                {
                    /* do nothing */
                }
            }

            /* check constraint */
            for ( i = 0; i < sOldTableInfo->checkCount; i++ )
            {
                sCheck = &(sOldTableInfo->checks[i]);
                if ( qdn::intersectColumn( sCheck->constraintColumn,
                                           sCheck->constraintColumnCount,
                                           &(sColumn->basicInfo->column.id),
                                           1 )
                     == ID_TRUE )
                {
                    sDDLRequireLevel = 1;
                    break;
                }
                else
                {
                    /* do nothing */
                }
            }
        }

        IDE_TEST( qci::mManageReplicationCallback.mIsDDLEnableOnReplicatedTable( sDDLRequireLevel,
                                                                                 sOldTableInfo )
                  != IDE_SUCCESS );

        IDE_TEST_RAISE(QC_SMI_STMT(aStatement)->getTrans()->getReplicationMode()
                       == SMI_TRANSACTION_REPL_NONE,
                       ERR_CANNOT_WRITE_REPL_INFO);

        /* PROJ-1442 Replication Online 중 DDL 허용
         * 관련 Receiver Thread 중지
         */
        if ( sIsPartitioned == ID_TRUE )
        {
            sOldTableOIDArray = sOldPartitionOID;
            sTableOIDCount = sPartitionCount;
        }
        else
        {
            sOldTableOIDArray = &sOldTableOID;
            sTableOIDCount = 1;
        }

        IDE_TEST( qciMisc::checkRunningEagerReplicationByTableOID( aStatement,
                                                                   sOldTableOIDArray,
                                                                   sTableOIDCount )
                  != IDE_SUCCESS );

        // BUG-22703 : Begin Statement를 수행한 후에 Hang이 걸리지
        // 않아야 합니다.
        // mStatistics 통계 정보를 전달 합니다.
        IDE_TEST( qci::mManageReplicationCallback.mStopReceiverThreads( QC_SMI_STMT(aStatement),
                                                                        aStatement->mStatistics,
                                                                        sOldTableOIDArray,
                                                                        sTableOIDCount )
                  != IDE_SUCCESS );

        sIsReplicatedTable = ID_TRUE;
    }

    sTableID = sParseTree->tableInfo->tableID;
    sColumnCount = 0;

    sColumn = sParseTree->columns;
    while (sColumn != NULL)
    {
        sColumn = sColumn->next;
        sColumnCount ++;
    }

    sDelColumnCnt = sColumnCount;
    sColumnCount = sParseTree->tableInfo->columnCount - sColumnCount;

    IDU_FIT_POINT( "qdbAlter::executeDropCol::alloc::sNewTableColumn",
                    idERR_ABORT_InsufficientMemory );

    IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(qcmColumn) * sColumnCount,
                                       (void**)&sNewTableColumn)
             != IDE_SUCCESS);

    IDU_FIT_POINT( "qdbAlter::executeDropCol::alloc::sNewMtcColumn",
                    idERR_ABORT_InsufficientMemory );

    IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(mtcColumn) * sColumnCount,
                                       (void**)&sNewMtcColumn)
             != IDE_SUCCESS);

    IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(UInt) * sDelColumnCnt,
                                       (void**)&sDelColumnID)
             != IDE_SUCCESS);
    
    IDE_TEST(deleteColInfo(aStatement,
                           sParseTree,
                           sParseTree->tableInfo,
                           sNewTableColumn,
                           sNewMtcColumn,
                           sDelColumnID,
                           sColumnCount) != IDE_SUCCESS);

    if (sParseTree->tableInfo->indexCount > 0)
    {
        IDU_FIT_POINT( "qdbAlter::executeDropCol::alloc::sNewTableIndex",
                        idERR_ABORT_InsufficientMemory );

        // for non-partitioned, partitioned index
        IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(qcmIndex)*
                                           sParseTree->tableInfo->indexCount,
                                           (void**)&sNewTableIndex)
                 != IDE_SUCCESS);

        idlOS::memcpy(sNewTableIndex,
                      sParseTree->tableInfo->indices,
                      ID_SIZEOF(qcmIndex) *
                        sParseTree->tableInfo->indexCount);

        // for index partition
        // fix BUG-18706
        if( sIsPartitioned == ID_TRUE )
        {
            IDU_LIMITPOINT("qdbAlter::executeDropCol::malloc5");
            IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(qcmIndex*) *
                                               sPartitionCount,
                                               (void**)& sNewPartIndex)
                     != IDE_SUCCESS);

            for( sPartInfoList = sOldPartInfoList, i = 0;
                 sPartInfoList != NULL;
                 sPartInfoList = sPartInfoList->next, i++ )
            {
                sPartInfo = sPartInfoList->partitionInfo;

                if ( sPartInfo->indexCount > 0 )
                {
                    IDU_LIMITPOINT("qdbAlter::executeDropCol::malloc6");
                    IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(qcmIndex) *
                                                       sPartInfo->indexCount,
                                                       (void**)&sNewPartIndex[i])
                             != IDE_SUCCESS);
                    
                    if ( sNewPartIndexCount == 0 )
                    {
                        sNewPartIndexCount = sPartInfo->indexCount;
                    }
                    else
                    {
                        IDE_DASSERT( sNewPartIndexCount == sPartInfo->indexCount );
                    }
                    
                    idlOS::memcpy( sNewPartIndex[i],
                                   sPartInfo->indices,
                                   ID_SIZEOF(qcmIndex) * sPartInfo->indexCount );
                }
                else
                {
                    // 모두 non-partitioned index만 생성된 경우
                    sNewPartIndex[i] = NULL;
                }
            }
        }
        else
        {
            // Nothing to do
        }
    }
    else
    {
        sNewTableIndex = NULL;
    }

    IDE_TEST(qdbCommon::createTableOnSM(aStatement,
                                        sNewTableColumn,
                                        sParseTree->tableInfo->tableOwnerID,
                                        sParseTree->tableInfo->tableID,
                                        sParseTree->tableInfo->maxrows,
                                        sParseTree->tableInfo->TBSID,
                                        sParseTree->tableInfo->segAttr,
                                        sParseTree->tableInfo->segStoAttr,
                                        /* 원본 Table Flag를 통째로 복사 =>
                                           MASK 비트를 를 모두 1로 설정 */
                                        QDB_TABLE_ATTR_MASK_ALL,
                                        sParseTree->tableInfo->tableFlag, /* Flag Value */
                                        sParseTree->tableInfo->parallelDegree,
                                        &sNewTableOID)
             != IDE_SUCCESS);

    // BUG-44814 ddl 구문 수행시 통계정보 복사를 해야함
    smiStatistics::copyTableStats( smiGetTable(sNewTableOID), sOldTableHandle, sDelColumnID, sDelColumnCnt );

    IDE_TEST(deleteIndexSpecFromMeta(aStatement,
                                     sTableID)
             != IDE_SUCCESS);

    IDE_TEST(qdbCommon::updateTableSpecFromMeta(
                 aStatement,
                 sParseTree->userName,
                 sParseTree->tableName,
                 sParseTree->tableInfo->tableID,
                 sNewTableOID,
                 sColumnCount,
                 sParseTree->tableInfo->parallelDegree)
             != IDE_SUCCESS);

    // PROJ-1502 PARTITIONED DISK TABLE
    if( sIsPartitioned == ID_TRUE )
    {
        IDU_LIMITPOINT("qdbAlter::executeDropCol::malloc7");
        IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(smOID) * sPartitionCount,
                                           (void**)&sNewPartitionOID)
                 != IDE_SUCCESS);
        IDU_LIMITPOINT("qdbAlter::executeDropCol::malloc8");
        IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(void*) * sPartitionCount,
                                           (void**)&sOldPartitionHandle)
                 != IDE_SUCCESS);
        IDU_LIMITPOINT("qdbAlter::executeDropCol::malloc9");
        IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(UInt) * sPartitionCount,
                                           (void**)&sPartitionID)
                 != IDE_SUCCESS);

        IDU_LIMITPOINT("qdbAlter::executeDropCol::malloc10");
        IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(qcmColumn*) * sPartitionCount,
                                           (void**)& sNewPartitionColumn)
                 != IDE_SUCCESS);
        IDU_LIMITPOINT("qdbAlter::executeDropCol::malloc11");
        IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(mtcColumn*) * sPartitionCount,
                                           (void**)& sNewPartitionMtcColumn)
                 != IDE_SUCCESS);

        // -----------------------------------------------------
        // 테이블 파티션 개수만큼 반복
        // -----------------------------------------------------
        for( sPartInfoList = sOldPartInfoList, i = 0;
             sPartInfoList != NULL;
             sPartInfoList = sPartInfoList->next, i++ )
        {
            sPartInfo = sPartInfoList->partitionInfo;
            sPartType = sPartInfo->tableFlag & SMI_TABLE_TYPE_MASK;

            IDU_LIMITPOINT("qdbAlter::executeDropCol::malloc12");
            IDE_TEST(aStatement->qmxMem->alloc(
                         ID_SIZEOF(qcmColumn) * sColumnCount,
                         (void**)&sNewPartitionColumn[i])
                     != IDE_SUCCESS);


            IDU_LIMITPOINT("qdbAlter::executeDropCol::malloc13");
            IDE_TEST(aStatement->qmxMem->alloc(
                         ID_SIZEOF(mtcColumn) * sColumnCount,
                         (void**)&sNewPartitionMtcColumn[i])
                     != IDE_SUCCESS);

            IDE_TEST(deleteColInfo(aStatement,
                                   sParseTree,
                                   sPartInfo,
                                   sNewPartitionColumn[i],
                                   sNewPartitionMtcColumn[i],
                                   sDelColumnID,
                                   sColumnCount) != IDE_SUCCESS);

            /* PROJ-2464 hybrid partitioned table 지원
             *  - Partition Info를 구성할 때에, Table Option을 Partitioned Table의 값으로 복제한다.
             *  - 따라서, PartInfo의 정보를 이용하지 않고, TBSID에 따라 적합한 값으로 조정해서 이용한다.
             */
            qdbCommon::adjustPhysicalAttr( sPartType,
                                           sParseTree->tableInfo->segAttr,
                                           sParseTree->tableInfo->segStoAttr,
                                           & sSegAttr,
                                           & sSegStoAttr,
                                           ID_TRUE /* aIsTable */ );

            IDE_TEST(qdbCommon::createTableOnSM(aStatement,
                                                sNewPartitionColumn[i],
                                                sParseTree->tableInfo->tableOwnerID,
                                                sTableID,
                                                sParseTree->tableInfo->maxrows,
                                                sPartInfo->TBSID,
                                                sSegAttr,
                                                sSegStoAttr,
                                                /* 원본 Table Flag를
                                                   통째로 복사 =>
                                                   MASK 비트를 모두 1로설정*/
                                                QDB_TABLE_ATTR_MASK_ALL,
                                                sParseTree->tableInfo->tableFlag, /* Flag Value */
                                                sParseTree->tableInfo->parallelDegree,
                                                &sNewPartitionOID[i])
                     != IDE_SUCCESS);

            // BUG-44814 ddl 구문 수행시 통계정보 복사를 해야함
            smiStatistics::copyTableStats( smiGetTable(sNewPartitionOID[i]), sPartInfo->tableHandle, sDelColumnID, sDelColumnCnt );

            sOldPartitionHandle[i] = sPartInfo->tableHandle;
            sPartitionID[i] = sPartInfo->partitionID;

            IDE_TEST(qdbCommon::updatePartTableSpecFromMeta( aStatement,
                                                             sTableID,
                                                             sPartitionID[i],
                                                             sNewPartitionOID[i] )
                     != IDE_SUCCESS );
        }
    }

    IDE_TEST(deleteColumnSpecFromMeta(aStatement, sTableID)
             != IDE_SUCCESS);

    // PROJ-1502 PARTITIONED DISK TABLE
    if( sIsPartitioned == ID_TRUE )
    {
        IDE_TEST(deletePartKeyColumnSpecFromMeta(aStatement,
                                                 sTableID,
                                                 QCM_TABLE_OBJECT_TYPE)
                 != IDE_SUCCESS);

        IDE_TEST(deletePartLobSpecFromMeta(aStatement,
                                           sTableID)
                 != IDE_SUCCESS);
    }

    // insert new column spec into meta.
    IDE_TEST(qdbCommon::insertColumnSpecIntoMeta(aStatement,
                                                 sParseTree->userID,
                                                 sTableID,
                                                 sNewTableColumn,
                                                 ID_FALSE /* is queue */)
             != IDE_SUCCESS);

    IDE_TEST(qdd::deleteConstraintsFromMeta(aStatement, sTableID)
             != IDE_SUCCESS);

    // PROJ-1502 PARTITIONED DISK TABLE
    if( sIsPartitioned == ID_TRUE )
    {
        IDE_TEST(qdbCommon::insertPartKeyColumnSpecIntoMeta(aStatement,
                                                            sParseTree->userID,
                                                            sTableID,
                                                            sNewTableColumn,
                                                            sParseTree->tableInfo->partKeyColumns,
                                                            QCM_TABLE_OBJECT_TYPE)
                 != IDE_SUCCESS);

        for( i = 0; i < sPartitionCount; i++ )
        {
            IDE_TEST(qdbCommon::insertPartLobSpecIntoMeta(
                         aStatement,
                         sParseTree->userID,
                         sTableID,
                         sPartitionID[i],
                         sNewPartitionColumn[i])
                     != IDE_SUCCESS);
        }

        IDE_TEST( findDelIndexAndDelMeta( aStatement,
                                          sOldTableInfo,
                                          sParseTree->columns )
                  != IDE_SUCCESS );
        
        // PROJ-1624 non-partitioned index
        // index table은 createIndex시 다시 생성되므로 meta를 위해 미리 지운다.
        for ( sIndexTable = sParseTree->oldIndexTables;
              sIndexTable != NULL;
              sIndexTable = sIndexTable->next )
        {
            IDE_TEST( qdx::dropIndexTable( aStatement,
                                           sIndexTable,
                                           ID_FALSE /* aIsDropTablespace */ )
                      != IDE_SUCCESS );
        }
    }

    /* BUG-44230 ADD, DROP, MODIFY, REORGANIZE DDL의 INDEX, CONSTRAINT 생성 순서 변경 */
    sTableType = sOldTableInfo->tableFlag & SMI_TABLE_TYPE_MASK;

    /* - Partition 구성을 검사한다. */
    qdbCommon::getTableTypeCountInPartInfoList( & sTableType,
                                                sOldPartInfoList,
                                                & sCountDiskType,
                                                & sCountMemType,
                                                & sCountVolType );

    /* - Memory 매체가 있거나, Index Table이 있다면, Index를 먼저 생성한다. */
    if ( ( ( sCountMemType + sCountVolType ) > 0 ) ||
         ( sParseTree->oldIndexTables != NULL ) )
    {
        IDE_TEST( qdbCommon::createConstraintFromInfo( aStatement,
                                                       sOldTableInfo,
                                                       sNewTableOID,
                                                       sPartitionCount,
                                                       sNewPartitionOID,
                                                       SMI_INDEX_BUILD_UNCOMMITTED_ROW_ENABLE,
                                                       sNewTableIndex,
                                                       sNewPartIndex,
                                                       sNewPartIndexCount,
                                                       sParseTree->oldIndexTables,
                                                       &( sParseTree->newIndexTables ),
                                                       sParseTree->columns )
                  != IDE_SUCCESS );

        IDE_TEST( qdbCommon::createIndexFromInfo( aStatement,
                                                  sOldTableInfo,
                                                  sNewTableOID,
                                                  sPartitionCount,
                                                  sNewPartitionOID,
                                                  SMI_INDEX_BUILD_UNCOMMITTED_ROW_ENABLE,
                                                  sNewTableIndex,
                                                  sNewPartIndex,
                                                  sNewPartIndexCount,
                                                  sParseTree->oldIndexTables,
                                                  &( sParseTree->newIndexTables ),
                                                  sParseTree->columns,
                                                  ID_TRUE )
                  != IDE_SUCCESS );

        /* PROJ-1624 global non-partitioned index
         *  - Index Meta에서 Index Table Id를 갱신한다.
         */
        if ( sIsPartitioned == ID_TRUE )
        {
            for ( i = 0;
                  i < sOldTableInfo->indexCount;
                  i++ )
            {
                if ( ( sOldTableInfo->indices[i].indexPartitionType == QCM_NONE_PARTITIONED_INDEX ) &&
                     ( sOldTableInfo->indices[i].indexTableID != sNewTableIndex[i].indexTableID ) )
                {
                    IDE_TEST( qdx::updateIndexSpecFromMeta( aStatement,
                                                            sOldTableInfo->indices[i].indexId,
                                                            sNewTableIndex[i].indexTableID )
                              != IDE_SUCCESS );
                }
                else
                {
                    /* Nothing to do */
                }
            }
        }
        else
        {
            /* Nothing to do */
        }
    }
    else
    {
        /* Nothing to do */
    }
    
    /* PROJ-2197 PSM Renewal */
    // related PSM
    IDE_TEST(qcmProc::relSetInvalidProcOfRelated(
        aStatement,
        sParseTree->userID,
        sParseTree->tableInfo->name,
        idlOS::strlen((SChar*)sParseTree->tableInfo->name),
        QS_TABLE) != IDE_SUCCESS);

    // PROJ-1073 Package
    IDE_TEST(qcmPkg::relSetInvalidPkgOfRelated(
        aStatement,
        sParseTree->userID,
        sParseTree->tableInfo->name,
        idlOS::strlen((SChar*)sParseTree->tableInfo->name),
        QS_TABLE) != IDE_SUCCESS);

    /* BUG-35445 Check Constraint, Function-Based Index에서 사용 중인 Function을 변경/제거 방지 */
    for ( i = 0; i < sParseTree->tableInfo->checkCount; i++ )
    {
        sCheckConstr = &(sParseTree->tableInfo->checks[i]);

        for ( j = 0; j < sCheckConstr->constraintColumnCount; j++ )
        {
            if ( qdbCommon::findColumnIDInColumnList( sParseTree->columns,
                                                      sCheckConstr->constraintColumn[j] )
                 == ID_TRUE )
            {
                IDE_TEST( qcmProc::relRemoveRelatedToConstraintByConstraintID(
                                aStatement,
                                sCheckConstr->constraintID )
                          != IDE_SUCCESS );

                break;
            }
            else
            {
                /* Nothing to do */
            }
        }
    }

    for ( i = 0; i < sOldTableInfo->indexCount; i++ )
    {
        for ( j = 0; j < sOldTableInfo->indices[i].keyColCount; j++ )
        {
            if ( qdbCommon::findColumnIDInColumnList( sParseTree->columns,
                                                      sOldTableInfo->indices[i].keyColumns[j].column.id )
                 == ID_TRUE )
            {
                IDE_TEST( qcmProc::relRemoveRelatedToIndexByIndexID(
                                aStatement,
                                sOldTableInfo->indices[i].indexId )
                          != IDE_SUCCESS );
                break;
            }
            else
            {
                /* Nothing to do */
            }
        }
    }

    IDE_TEST(qcm::makeAndSetQcmTableInfo(
                 QC_SMI_STMT( aStatement ),
                 sTableID,
                 sNewTableOID) != IDE_SUCCESS);

    IDE_TEST(qcm::getTableInfoByID(aStatement,
                                   sTableID,
                                   &sTempTableInfo,
                                   &sSCN,
                                   &sTableHandle)
             != IDE_SUCCESS);

    IDE_TEST( qcm::validateAndLockTable(aStatement,
                                        sTableHandle,
                                        sSCN,
                                        SMI_TABLE_LOCK_X)

              != IDE_SUCCESS );

    // PROJ-1502 PARTITIONED DISK TABLE
    if( sIsPartitioned == ID_TRUE )
    {
        // 새로운 qcmPartitionInfo들의 pointer를 가지는 array 생성
        IDU_LIMITPOINT("qdbAlter::executeDropCol::malloc14");
        IDE_TEST( aStatement->qmxMem->cralloc(
                      ID_SIZEOF(qcmTableInfo*) * sPartitionCount,
                      (void**) & sNewPartitionInfoArr )
                  != IDE_SUCCESS);

        for( i = 0; i < sPartitionCount; i++ )
        {
            IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                          QC_SMI_STMT(aStatement),
                          sPartitionID[i],
                          sNewPartitionOID[i],
                          sTempTableInfo ) != IDE_SUCCESS );

            IDE_TEST( smiGetTableTempInfo( smiGetTable( sNewPartitionOID[i]),
                                           (void**)&sNewPartitionInfoArr[i] )
                      != IDE_SUCCESS );
        }

        IDE_TEST( qcmPartition::getPartitionInfoList(
                      aStatement,
                      QC_SMI_STMT( aStatement ),
                      aStatement->qmxMem,
                      sTableID,
                      & sNewPartInfoList )
                  != IDE_SUCCESS );
    }

    // BUG-15936
    // copy new mtcColumn
    IDE_TEST( copyColInfo(sNewTableColumn,
                          sTempTableInfo->columns)
              != IDE_SUCCESS );

    /* PROJ-1442 Replication Online 중 DDL 허용
     * SYS_REPL_ITEMS_의 TABLE_OID 컬럼 갱신
     */
    if(sIsReplicatedTable == ID_TRUE)
    {
        if(sIsPartitioned == ID_TRUE)
        {
            for(i = 0; i < sPartitionCount; i++)
            {
                IDE_TEST(qci::mCatalogReplicationCallback.mUpdateReplItemsTableOID(
                                    QC_SMI_STMT(aStatement),
                                    sOldPartitionOID[i],
                                    sNewPartitionOID[i])
                         != IDE_SUCCESS);
            }
        }
        else
        {
            IDE_TEST(qci::mCatalogReplicationCallback.mUpdateReplItemsTableOID(
                                QC_SMI_STMT(aStatement),
                                sOldTableOID,
                                sNewTableOID)
                     != IDE_SUCCESS);
        }
    }

    // PROJ-1502 PARTITIONED DISK TABLE
    if( sIsPartitioned == ID_TRUE )
    {
        sSrcPartInfoList = sOldPartInfoList;
        sDstPartInfoList = sNewPartInfoList;

        for( i = 0; i < sPartitionCount; i++ )
        {
            // move row from old to new.
            // drop old table partitions
            sSrcPartInfo = sSrcPartInfoList->partitionInfo;
            sDstPartInfo = sDstPartInfoList->partitionInfo;

            IDE_TEST( copyColInfo(sNewPartitionColumn[i],
                                  sDstPartInfo->columns)
                      != IDE_SUCCESS );

            IDE_TEST(moveRow(aStatement,
                             NULL,
                             sOldTableInfo,
                             sOldPartitionHandle[i],
                             smiGetTable( sNewPartitionOID[i]),
                             sSrcPartInfo->columns,
                             sNewPartitionColumn[i],
                             sTempTableInfo,
                             sParseTree->newIndexTables,
                             ID_FALSE /* No Undo Logging */)
                     != IDE_SUCCESS);

            sSrcPartInfoList = sSrcPartInfoList->next;
            sDstPartInfoList = sDstPartInfoList->next;
        }
        // drop old partitioned table
        IDE_TEST( smiTable::dropTable( QC_SMI_STMT( aStatement ),
                                       sOldTableHandle,
                                       SMI_TBSLV_DDL_DML )
                  != IDE_SUCCESS );
    }
    else
    {
        // move row from old to new.
        // drop old non-partitioned table
        IDE_TEST(moveRow(aStatement,
                         NULL,
                         sOldTableInfo,
                         sOldTableHandle,
                         smiGetTable( sNewTableOID),
                         sParseTree->tableInfo->columns,
                         sNewTableColumn,
                         NULL,
                         NULL,
                         ID_FALSE /* No Undo Logging */)
                 != IDE_SUCCESS);
    }

    /* BUG-44230 ADD, DROP, MODIFY, REORGANIZE DDL의 INDEX, CONSTRAINT 생성 순서 변경
     *  - Memory 매체가 없고, Index Table도 없다면, Index를 나중 생성한다.
     */
    if ( ( ( sCountMemType + sCountVolType ) == 0 ) &&
         ( sParseTree->oldIndexTables == NULL ) )
    {
        IDE_TEST( qdbCommon::createConstraintFromInfo( aStatement,
                                                       sOldTableInfo,
                                                       sNewTableOID,
                                                       sPartitionCount,
                                                       sNewPartitionOID,
                                                       SMI_INDEX_BUILD_UNCOMMITTED_ROW_ENABLE,
                                                       sNewTableIndex,
                                                       sNewPartIndex,
                                                       sNewPartIndexCount,
                                                       sParseTree->oldIndexTables,
                                                       &( sParseTree->newIndexTables ),
                                                       sParseTree->columns )
                  != IDE_SUCCESS );

        IDE_TEST( qdbCommon::createIndexFromInfo( aStatement,
                                                  sOldTableInfo,
                                                  sNewTableOID,
                                                  sPartitionCount,
                                                  sNewPartitionOID,
                                                  SMI_INDEX_BUILD_UNCOMMITTED_ROW_ENABLE,
                                                  sNewTableIndex,
                                                  sNewPartIndex,
                                                  sNewPartIndexCount,
                                                  sParseTree->oldIndexTables,
                                                  &( sParseTree->newIndexTables ),
                                                  sParseTree->columns,
                                                  ID_TRUE )
                  != IDE_SUCCESS );

        /* PROJ-1624 global non-partitioned index
         *  - Index Meta에서 Index Table Id를 갱신한다.
         */
        if ( sIsPartitioned == ID_TRUE )
        {
            for ( i = 0;
                  i < sOldTableInfo->indexCount;
                  i++ )
            {
                if ( ( sOldTableInfo->indices[i].indexPartitionType == QCM_NONE_PARTITIONED_INDEX ) &&
                     ( sOldTableInfo->indices[i].indexTableID != sNewTableIndex[i].indexTableID ) )
                {
                    IDE_TEST( qdx::updateIndexSpecFromMeta( aStatement,
                                                            sOldTableInfo->indices[i].indexId,
                                                            sNewTableIndex[i].indexTableID )
                              != IDE_SUCCESS );
                }
                else
                {
                    /* Nothing to do */
                }
            }
        }
        else
        {
            /* Nothing to do */
        }

        /* - Meta Cache Recreate */
        (void)qcm::destroyQcmTableInfo( sTempTableInfo );

        sTempTableInfo = NULL;

        IDE_TEST( qcm::makeAndSetQcmTableInfo( QC_SMI_STMT( aStatement ),
                                               sTableID,
                                               sNewTableOID )
                  != IDE_SUCCESS );

        IDE_TEST( qcm::getTableInfoByID( aStatement,
                                         sTableID,
                                         & sTempTableInfo,
                                         & sSCN,
                                         & sTableHandle)
                  != IDE_SUCCESS );

        IDE_TEST( qcm::validateAndLockTable( aStatement,
                                             sTableHandle,
                                             sSCN,
                                             SMI_TABLE_LOCK_X )
                  != IDE_SUCCESS );

        /* PROJ-1502 PARTITIONED DISK TABLE */
        if ( sIsPartitioned == ID_TRUE )
        {
            for ( sPartInfoList  = sNewPartInfoList, i = 0;
                  sPartInfoList != NULL;
                  sPartInfoList  = sPartInfoList->next, i++ )
            {
                IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo( QC_SMI_STMT( aStatement ),
                                                                    sPartitionID[i],
                                                                    sNewPartitionOID[i],
                                                                    sTempTableInfo,
                                                                    NULL )
                          != IDE_SUCCESS );

                IDE_TEST( smiGetTableTempInfo( smiGetTable( sNewPartitionOID[i] ),
                                               (void**)& sPartInfoList->partitionInfo )
                          != IDE_SUCCESS );

                (void)qcmPartition::destroyQcmPartitionInfo( sNewPartitionInfoArr[i] );

                sNewPartitionInfoArr[i] = sPartInfoList->partitionInfo;
            }

            IDE_TEST( qcmPartition::getPartitionInfoList( aStatement,
                                                          QC_SMI_STMT(aStatement),
                                                          aStatement->qmxMem,
                                                          sTableID,
                                                          & sNewPartInfoList )
                      != IDE_SUCCESS );
        }
        else
        {
            /* Nothing to do */            
        }

        IDU_FIT_POINT( "qdbAlter::executeDropCol::BUG-44230-1" );
    }
    else
    {
        /* Nothing to do */
    }
    
    // PROJ-2264 Dictionary table
    for( sColumn  = sParseTree->columns;
         sColumn != NULL;
         sColumn  = sColumn->next )
    {
        if( (sColumn->basicInfo->column.flag & SMI_COLUMN_COMPRESSION_MASK)
            == SMI_COLUMN_COMPRESSION_TRUE )
        {
            sDicInfo = (qcmTableInfo *)smiGetTableRuntimeInfoFromTableOID(
                sColumn->basicInfo->column.mDictionaryTableOID );
            sDicTableID = sDicInfo->tableID;

            // SYS_COMPRESSION_TABLES_ 에서 삭제된 컬럼 관련 레코드를 삭제한다.
            IDE_TEST( qdd::deleteCompressionTableSpecFromMetaByDicTableID(
                                        aStatement,
                                        sDicTableID )
                      != IDE_SUCCESS );
        }
        else
        {
            // uncompression column
            // Nothing to do.
        }
    }

    // Drop column 후 남는 컬럼들은 column id 가 변할 수 있으므로
    // 관련 메타를 갱신해야 한다.
    for( sColumn  = sNewTableColumn;
         sColumn != NULL;
         sColumn  = sColumn->next )
    {
        if( (sColumn->basicInfo->column.flag & SMI_COLUMN_COMPRESSION_MASK)
            == SMI_COLUMN_COMPRESSION_TRUE )
        {
            sDicInfo = (qcmTableInfo *)smiGetTableRuntimeInfoFromTableOID(
                sColumn->basicInfo->column.mDictionaryTableOID );

            // SYS_COMPRESSION_TABLES_ 메타의 column id 를 갱신한다.
            IDE_TEST( qcmDictionary::updateColumnIDInCompressionTableSpecMeta(
                                        aStatement,
                                        sDicInfo->tableID,
                                        sColumn->basicInfo->column.id)
                      != IDE_SUCCESS );
        }
        else
        {
            // uncompression column
            // Nothing to do.
        }
    }

    // BUG-21387 COMMENT
    //   Column들의 Comment를 모두 지운다.
    for (sColumn = sParseTree->columns;
         sColumn != NULL;
         sColumn = sColumn->next)
    {
        IDE_TEST(qdbComment::deleteCommentColumn(
                     aStatement,
                     sParseTree->tableInfo->tableOwnerName,
                     sParseTree->tableInfo->name,
                     sColumn->name)
                 != IDE_SUCCESS);
    }

    // related VIEW
    IDE_TEST(qcmView::setInvalidViewOfRelated(
                 aStatement,
                 sParseTree->userID,
                 sTempTableInfo->name,
                 idlOS::strlen((SChar*)sTempTableInfo->name),
                 QS_TABLE) != IDE_SUCCESS);

    // BUG-11266
    IDE_TEST(qcmView::recompileAndSetValidViewOfRelated(
                 aStatement,
                 sParseTree->userID,
                 sTempTableInfo->name,
                 idlOS::strlen((SChar*)sTempTableInfo->name),
                 QS_TABLE)
             != IDE_SUCCESS);

    // BUG-16543
    IDE_TEST(qdnTrigger::setInvalidTriggerCache4Table(
                 sTempTableInfo)
             != IDE_SUCCESS);

    /* PROJ-1442 Replication Online 중 DDL 허용
     * Table Meta Log Record 기록
     */
    if ( ( sIsReplicatedTable == ID_TRUE ) ||
         ( QCU_DDL_SUPPLEMENTAL_LOG == 1 ) )
    {
        if ( sPartitionCount > 0 )
        {
            sOldTableOIDArray = sOldPartitionOID;
            sNewTableOIDArray = sNewPartitionOID;
            sTableOIDCount = sPartitionCount;
        }
        else
        {
            sOldTableOIDArray = &sOldTableOID;
            sNewTableOIDArray = &sNewTableOID;
            sTableOIDCount = 1;
        }

        //-----------------------------------------------------
        // PROJ-1442 Replication Online 중 DDL 허용
        // SYS_REPL_ITEMS_의 TABLE_OID 컬럼 갱신
        //-----------------------------------------------------
        if ( sIsReplicatedTable == ID_TRUE )
        {
            for ( i = 0; i < sTableOIDCount; i++ )
            {
                IDE_TEST( qci::mCatalogReplicationCallback.mUpdateReplItemsTableOID( QC_SMI_STMT( aStatement ),
                                                                                     sOldTableOIDArray[i],
                                                                                     sNewTableOIDArray[i] )
                          != IDE_SUCCESS );
            }
        }
        else
        {
            /* do nothing */
        }

        //-----------------------------------------------------
        //  PROJ-1442 Replication Online 중 DDL 허용
        //  Table Meta Log Record 기록
        //-----------------------------------------------------
        IDE_TEST( qciMisc::writeTableMetaLogForReplication( aStatement,
                                                            sOldTableOIDArray,
                                                            sNewTableOIDArray,
                                                            sTableOIDCount )
                  != IDE_SUCCESS );
    }
    else
    {
        /* do nothing */
    }

    // PROJ-2002 Column Security
    // 보안 컬럼 삭제시 보안 모듈에 알린다.
    sColumn = sParseTree->columns;

    while (sColumn != NULL)
    {
        if ( (sColumn->basicInfo->module->flag & MTD_ENCRYPT_TYPE_MASK)
             == MTD_ENCRYPT_TYPE_TRUE )
        {
            idlOS::strncpy(sColumn->name,
                           sColumn->namePos.stmtText +
                           sColumn->namePos.offset,
                           sColumn->namePos.size);

            // fix BUG-32700
            sColumn->name[sColumn->namePos.size] = '\0';

            (void) qcsModule::unsetColumnPolicy(
                sOldTableInfo->tableOwnerName,
                sOldTableInfo->name,
                sColumn->name );
        }
        else
        {
            // Nothing to do.
        }

        sColumn = sColumn->next;
    }

    /* BUG-44230 ADD, DROP, MODIFY, REORGANIZE DDL의 INDEX, CONSTRAINT 생성 순서 변경 */
    IDU_FIT_POINT( "qdbAlter::executeDropCol::BUG-44230-2" );

    // PROJ-2264 Dictionary table
    for( sColumn  = sParseTree->columns;
         sColumn != NULL;
         sColumn  = sColumn->next )
    {
        if( (sColumn->basicInfo->column.flag & SMI_COLUMN_COMPRESSION_MASK)
            == SMI_COLUMN_COMPRESSION_TRUE )
        {
            sDicInfo = (qcmTableInfo *) smiGetTableRuntimeInfoFromTableOID(
                sColumn->basicInfo->column.mDictionaryTableOID );

            // Dictionary table 삭제
            // BUG-36719
            // 여기서 실패하면 되돌릴 수 없다.
            // 실패하더라도 dictionary table 이 남을 뿐이고,
            // Drop column 작업 자체는 성공했기 때문에 dictionary table 삭제는
            // 별도 에러 처리를 하지 않는다.
            (void) qcmDictionary::dropDictionaryTable( aStatement,
                                                       sDicInfo );
        }
        else
        {
            // uncompression column
            // Nothing to do.
        }
    }

    (void)qcm::destroyQcmTableInfo(sOldTableInfo);

    if( sIsPartitioned == ID_TRUE )
    {
        (void)qcmPartition::destroyQcmPartitionInfoList( sOldPartInfoList );

        // old index table tableinfo 삭제
        for ( sIndexTable = sParseTree->oldIndexTables;
              sIndexTable != NULL;
              sIndexTable = sIndexTable->next )
        {
            (void)qcm::destroyQcmTableInfo(sIndexTable->tableInfo);
        }
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_SESSION_TEMPORARY_TABLE_EXIST )
    {
        IDE_SET(ideSetErrorCode( qpERR_ABORT_QDB_TEMPORARY_TABLE_DDL_DISABLE ));
    }
    IDE_EXCEPTION(ERR_CANNOT_WRITE_REPL_INFO)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_WRITE_REPL_INFO));
    }
    IDE_EXCEPTION_END;

    if( sIsPartitioned == ID_TRUE )
    {
        if ( sNewPartitionInfoArr != NULL )
        {
            for ( i = 0; i < sPartitionCount; i++ )
            {
                (void)qcmPartition::destroyQcmPartitionInfo( sNewPartitionInfoArr[i] );
            }
        }

        for ( sIndexTable = sParseTree->newIndexTables;
              sIndexTable != NULL;
              sIndexTable = sIndexTable->next )
        {
            (void)qcm::destroyQcmTableInfo(sIndexTable->tableInfo);
        }
    }

    (void)qcm::destroyQcmTableInfo( sTempTableInfo );

    // on failure, restore tempinfo.
    qcmPartition::restoreTempInfo( sOldTableInfo,
                                   sOldPartInfoList,
                                   NULL );

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::executeRenameCol(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... RENAME COLUMN ... 의 execution 수행
 *
 * Implementation :
 *    1. SYS_COLUMNS_ 에서 컬럼 이름 변경 => updateColumnName
 *    2. 테이블 ID, OID 구해두기
 *    3. 해당 Column을 포함한 Check Constraint의 Check Condition을 수정
 *    4. related PSM 을 invalid 상태로 변경
 *    5. related VIEW 을 invalid 상태로 변경
 *    6. qcm::touchTable
 *    7. 메타 캐쉬 재구성
 *
 ***********************************************************************/

    qdTableParseTree      * sParseTree;
    smSCN                   sSCN;
    UInt                    sTableID = 0;
    smOID                   sTableOID;
    qcmTableInfo          * sOldTableInfo = NULL;
    qcmTableInfo          * sNewTableInfo = NULL;
    void                  * sTableHandle;
    qcmPartitionInfoList  * sOldPartInfoList      = NULL;
    qcmPartitionInfoList  * sNewPartInfoList      = NULL;
    idBool                  sIsPartitioned        = ID_FALSE;
    qcmTableInfo         ** sNewIndexTableInfoArr = NULL;
    SChar                   sNewColumnName[ QC_MAX_OBJECT_NAME_LEN + 1 ];
    UInt                    sIndexTableCount = 0;
    qdIndexTableList      * sOldIndexTableList    = NULL;
    qdIndexTableList      * sIndexTable;
    qcmTableInfo          * sIndexTableInfo;
    qcmIndex              * sIndex;
    UInt                    i;
    UInt                    j;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // TASK-2176
    // Table에 대한 Lock을 획득한다.
    IDE_TEST( qcm::validateAndLockTable(aStatement,
                                        sParseTree->tableHandle,
                                        sParseTree->tableSCN,
                                        SMI_TABLE_LOCK_X)
              != IDE_SUCCESS);

    /* PROJ-2197 PSM Renewal */
    // related PSM
    IDE_TEST(qcmProc::relSetInvalidProcOfRelated(
        aStatement,
        sParseTree->tableInfo->tableOwnerID,
        sParseTree->tableInfo->name,
        idlOS::strlen((SChar*)sParseTree->tableInfo->name),
        QS_TABLE) != IDE_SUCCESS);

    // PROJ-1073 Package
    IDE_TEST(qcmPkg::relSetInvalidPkgOfRelated(
        aStatement,
        sParseTree->tableInfo->tableOwnerID,
        sParseTree->tableInfo->name,
        idlOS::strlen((SChar*)sParseTree->tableInfo->name),
        QS_TABLE) != IDE_SUCCESS);

    sOldTableInfo = sParseTree->tableInfo;

    // PROJ-1502 PARTITIONED DISK TABLE
    if( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        sIsPartitioned = ID_TRUE;

        // 모든 파티션에 LOCK(X)
        IDE_TEST( qcmPartition::validateAndLockPartitionInfoList( aStatement,
                                                                  sParseTree->partTable->partInfoList,
                                                                  SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                                  SMI_TABLE_LOCK_X,
                                                                  ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                                    ID_ULONG_MAX :
                                                                    smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );
        
        // 예외 처리를 위하여, Lock을 잡은 후에 Partition List를 설정한다.
        sOldPartInfoList = sParseTree->partTable->partInfoList;

        // PROJ-1624 non-partitioned index
        IDE_TEST( qdx::validateAndLockIndexTableList( aStatement,
                                                      sParseTree->oldIndexTables,
                                                      SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                      SMI_TABLE_LOCK_X,
                                                      ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                        ID_ULONG_MAX :
                                                        smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );

        // 예외 처리를 위하여, Lock을 잡은 후에 Index Table List를 설정한다.
        sOldIndexTableList = sParseTree->oldIndexTables;

        for ( sIndexTable = sOldIndexTableList;
              sIndexTable != NULL;
              sIndexTable = sIndexTable->next )
        {
            sIndexTableCount++;
        }
    }
    else
    {
        // Nothing to do.
    }

    IDE_TEST(updateColumnName( aStatement,
                               sParseTree->columns,        // old column
                               sParseTree->columns->next ) // new column
             != IDE_SUCCESS);

    // PROJ-1624 non-partitioned index
    // index table의 컬럼이름도 변경한다.
    if( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        for ( i = 0; i < sOldTableInfo->indexCount; i++ )
        {
            sIndex = &(sOldTableInfo->indices[i]);

            if ( sIndex->indexPartitionType == QCM_NONE_PARTITIONED_INDEX )
            {
                for ( j = 0; j < sIndex->keyColCount; j++ )
                {
                    if ( sParseTree->columns->basicInfo->column.id ==
                         sIndex->keyColumns[j].column.id )
                    {
                        IDE_TEST( qdx::findIndexTableInList(
                                      sOldIndexTableList,
                                      sIndex->indexTableID,
                                      & sIndexTable )
                                  != IDE_SUCCESS );
                        
                        // oid, rid까지 적어도 2컬럼이상 존재해야한다.
                        IDE_TEST_RAISE( j + 2 >= sIndexTable->tableInfo->columnCount,
                                        ERR_META_CRASH );
                        
                        IDE_TEST( updateColumnName(
                                      aStatement,
                                      &(sIndexTable->tableInfo->columns[j]), // old column
                                      sParseTree->columns->next ) // new column
                                  != IDE_SUCCESS);
                        
                        break;
                    }
                    else
                    {
                        // Nothing to do.
                    }
                }
            }
            else
            {
                // Nothing to do.
            }
        }
    }
    else
    {
        // Nothing to do.
    }
        
    sTableID = sParseTree->tableInfo->tableID;
    sTableOID = smiGetTableId(sParseTree->tableInfo->tableHandle);

    // fix BUG-14394
    IDE_TEST(qdbCommon::updateTableSpecFromMeta(
                 aStatement,
                 sParseTree->userName,
                 sParseTree->tableName,
                 sTableID,
                 sTableOID,
                 sParseTree->tableInfo->columnCount,
                 sParseTree->tableInfo->parallelDegree )
             != IDE_SUCCESS);

    // BUG-21387 COMMENT
    QC_STR_COPY( sNewColumnName, sParseTree->columns->next->namePos );

    IDE_TEST(qdbComment::updateCommentColumn(
                 aStatement,
                 sParseTree->tableInfo->tableOwnerName,
                 sParseTree->tableInfo->name,
                 sParseTree->columns->name,
                 sNewColumnName )
             != IDE_SUCCESS);

    /* PROJ-1107 Check Constraint 지원 */
    IDE_TEST( qdnCheck::renameColumnInCheckConstraint(
                        aStatement,
                        sParseTree->constraints,
                        sOldTableInfo,
                        sParseTree->columns,
                        sParseTree->columns->next )
              != IDE_SUCCESS );

    /* PROJ-1090 Function-based Index */
    IDE_TEST( renameColumnInDefaultExpression(
                  aStatement,
                  sParseTree->defaultExprColumns,
                  sParseTree->columns,
                  sParseTree->columns->next )
              != IDE_SUCCESS );
        
    // related VIEW
    IDE_TEST(qcmView::setInvalidViewOfRelated(
                 aStatement,
                 sParseTree->tableInfo->tableOwnerID,
                 sParseTree->tableInfo->name,
                 idlOS::strlen((SChar*)sParseTree->tableInfo->name),
                 QS_TABLE) != IDE_SUCCESS);

    IDE_TEST(qcm::touchTable(QC_SMI_STMT( aStatement ),
                             sTableID,
                             SMI_TBSLV_DDL_DML )
             != IDE_SUCCESS);

    IDE_TEST(qcm::makeAndSetQcmTableInfo( QC_SMI_STMT( aStatement ),
                                          sTableID,
                                          sTableOID) != IDE_SUCCESS);

    IDE_TEST(qcm::getTableInfoByID(aStatement,
                                   sTableID,
                                   &sNewTableInfo,
                                   &sSCN,
                                   &sTableHandle)
             != IDE_SUCCESS);

    // BUG-11266
    IDE_TEST(qcmView::recompileAndSetValidViewOfRelated(
                 aStatement,
                 sNewTableInfo->tableOwnerID,
                 sNewTableInfo->name,
                 idlOS::strlen((SChar*)sNewTableInfo->name),
                 QS_TABLE)
             != IDE_SUCCESS);

    // BUG-16543
    IDE_TEST(qdnTrigger::setInvalidTriggerCache4Table( sNewTableInfo )
             != IDE_SUCCESS);

    // PROJ-1502 PARTITIONED DISK TABLE
    if( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST( qcmPartition::touchPartitionInfoList( QC_SMI_STMT( aStatement ),
                                                        sOldPartInfoList )
                  != IDE_SUCCESS );

        IDE_TEST( qcmPartition::makeAndSetAndGetQcmPartitionInfoList( aStatement,
                                                                      sNewTableInfo,
                                                                      sOldPartInfoList,
                                                                      & sNewPartInfoList )
                  != IDE_SUCCESS );
        
        // PROJ-1624 non-partitioned index
        if ( sIndexTableCount > 0 )
        {
            IDE_TEST( aStatement->qmxMem->cralloc(
                          ID_SIZEOF(qcmTableInfo *) * sIndexTableCount,
                          (void **) & sNewIndexTableInfoArr )
                      != IDE_SUCCESS );
        }
        else
        {
            // Nothing to do.
        }

        // PROJ-1624 non-partitioned index
        for ( sIndexTable = sOldIndexTableList, i = 0;
              sIndexTable != NULL;
              sIndexTable = sIndexTable->next, i++ )
        {
            sIndexTableInfo = sIndexTable->tableInfo;
            
            IDE_TEST( qcm::touchTable( QC_SMI_STMT( aStatement ),
                                       sIndexTable->tableID,
                                       SMI_TBSLV_DDL_DML )
                      != IDE_SUCCESS );

            IDE_TEST(qcm::makeAndSetQcmTableInfo(QC_SMI_STMT(aStatement),
                                                 sIndexTable->tableID,
                                                 sIndexTable->tableOID)
                     != IDE_SUCCESS);
            
            IDE_TEST(qcm::getTableInfoByID(aStatement,
                                           sIndexTable->tableID,
                                           &(sNewIndexTableInfoArr[i]),
                                           &sSCN,
                                           &sTableHandle)
                     != IDE_SUCCESS);
        }
    }
    else
    {
        // Nothing to do.
    }

    // PROJ-1442 Table Meta Log Record 기록
    if(QCU_DDL_SUPPLEMENTAL_LOG == 1)
    {
        IDE_TEST(qci::mManageReplicationCallback.mWriteTableMetaLog(
                     aStatement,
                     sTableOID,
                     sTableOID)
                 != IDE_SUCCESS);
    }

    if( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        (void)qcmPartition::destroyQcmPartitionInfoList( sOldPartInfoList );
        
        // PROJ-1624 non-partitioned index
        for ( sIndexTable = sOldIndexTableList;
              sIndexTable != NULL;
              sIndexTable = sIndexTable->next )
        {
            sIndexTableInfo = sIndexTable->tableInfo;
            (void)qcm::destroyQcmTableInfo(sIndexTableInfo);
        }
    }
    else
    {
        // Nothing to do.
    }

    // BUG-26464 Table Info, Partition Info의 destroy 순서 변경
    (void)qcm::destroyQcmTableInfo(sOldTableInfo);

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_META_CRASH)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QCM_META_CRASH));
    }
    IDE_EXCEPTION_END;

    (void)qcm::destroyQcmTableInfo( sNewTableInfo );
    (void)qcmPartition::destroyQcmPartitionInfoList( sNewPartInfoList );

    if ( sIsPartitioned == ID_TRUE )
    {
        if ( sNewIndexTableInfoArr != NULL )
        {
            for ( i = 0; i < sIndexTableCount; i++ )
            {
                (void)qcm::destroyQcmTableInfo( sNewIndexTableInfoArr[i] );
            }
        }
    }

    // on failure, restore tempinfo.
    qcmPartition::restoreTempInfo( sOldTableInfo,
                                   sOldPartInfoList,
                                   sOldIndexTableList );

    return IDE_FAILURE;
}

IDE_RC qdbAlter::updateColumnName(
    qcStatement * aStatement,
    qcmColumn   * aOldColumn,
    qcmColumn   * aNewColumn)
{
/***********************************************************************
 *
 * Description :
 *      ALTER TABLE ... RENAME COL 관련 executeRenameCol 로부터 호출,
 *                 SYS_COLUMNS_ 메타 테이블 변경 수행
 *
 * Implementation :
 *      1. SYS_COLUMNS_ 메타 테이블의 정보 변경
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::executeRenameCol"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY(""));

    SChar     * sSqlStr;
    SChar       sColumnName[ QC_MAX_OBJECT_NAME_LEN + 1 ];
    vSLong      sRowCnt;

    QC_STR_COPY( sColumnName, aNewColumn->namePos );

    IDU_FIT_POINT( "qdbAlter::updateColumnName::alloc::sSqlStr",
                    idERR_ABORT_InsufficientMemory );

    IDE_TEST(STRUCT_ALLOC_WITH_SIZE(aStatement->qmxMem,
                                    SChar,
                                    QD_MAX_SQL_LENGTH,
                                    &sSqlStr)
             != IDE_SUCCESS);

    idlOS::snprintf( sSqlStr, QD_MAX_SQL_LENGTH,
                     "UPDATE SYS_COLUMNS_ SET COLUMN_NAME = '%s' "
                     "WHERE COLUMN_ID = INTEGER'%"ID_INT32_FMT"'",
                     sColumnName,
                     aOldColumn->basicInfo->column.id);

    IDE_TEST(qcg::runDMLforDDL( QC_SMI_STMT( aStatement ),
                                sSqlStr,
                                & sRowCnt ) != IDE_SUCCESS);

    IDE_TEST_RAISE(sRowCnt != 1, ERR_META_CRASH);

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_META_CRASH)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QCM_META_CRASH));
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::updateCheckCondition(
    qcStatement * aStatement,
    UInt          aConstraintID,
    SChar       * aCheckCondition )
{
/***********************************************************************
 *
 * Description :
 *  ALTER TABLE ... RENAME COLUMN 관련 함수.
 *  SYS_CONSTRAINTS_ 메타 테이블의 CHECK_CONDITION 컬럼을 변경한다.
 *
 * Implementation :
 *  1. 문자열을 Meta에 넣기 위해 변환
 *  2. CONSTRAINT_ID에 해당하는 Check Constraint의 CHECK_CONDITION 컬럼을 변경
 *
 ***********************************************************************/

    SChar     * sStrForMeta = NULL;
    SChar     * sSqlStr     = NULL;
    vSLong      sRowCnt;

    IDE_TEST( qdbCommon::getStrForMeta( aStatement,
                                        aCheckCondition,
                                        idlOS::strlen( aCheckCondition ),
                                        &sStrForMeta )
              != IDE_SUCCESS );

    IDE_TEST( STRUCT_ALLOC_WITH_SIZE( aStatement->qmxMem,
                                      SChar,
                                      QD_MAX_SQL_LENGTH,
                                      &sSqlStr )
              != IDE_SUCCESS);

    idlOS::snprintf( sSqlStr, QD_MAX_SQL_LENGTH,
                     "UPDATE SYS_CONSTRAINTS_ SET CHECK_CONDITION = '%s' "
                     "WHERE CONSTRAINT_ID = INTEGER'%"ID_INT32_FMT"'",
                     sStrForMeta,
                     aConstraintID );

    IDE_TEST( qcg::runDMLforDDL( QC_SMI_STMT( aStatement ),
                                 sSqlStr,
                                 &sRowCnt )
              != IDE_SUCCESS );

    IDE_TEST_RAISE( sRowCnt != 1, ERR_META_CRASH );

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_META_CRASH )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QCM_META_CRASH ) );
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::findDelIndexAndDelMeta(
    qcStatement  * aStatement,
    qcmTableInfo * aTableInfo,
    qcmColumn    * aDelColumn )
/***********************************************************************
 *
 * Description :
 *       Drop하려는 컬럼을 키컬럼으로 갖고 있는 인덱스는
 *       삭제되기 때문에 그 인덱스를 메타 테이블에서 삭제한다.
 *
 * Implementation :
 *
 ***********************************************************************/
{
    qcmIndex * sIndexInfo;
    UInt       sDelIndexID = 0;
    UInt       i, j;

    for (i = 0; i < aTableInfo->indexCount; i++)
    {
        sIndexInfo = &(aTableInfo->indices[i]);

        for (j = 0; j < sIndexInfo->keyColCount; j++)
        {
            if ( qdbCommon::findColumnIDInColumnList(
                     aDelColumn,
                     sIndexInfo->keyColumns[j].column.id ) == ID_TRUE )
            {
                sDelIndexID = sIndexInfo->indexId;
                
                // SYS_PART_INDICES_
                // SYS_INDEX_PARTITIONS_
                // SYS_PART_KEY_COLUMNS_
                IDE_TEST( deletePartIndexFromMeta( aStatement,
                                                   sDelIndexID )
                          != IDE_SUCCESS );
                
                break;
            }
            else
            {
                // Nothing to do.
            }
        }
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::deleteColInfo( qcStatement      * aStatement,
                                qdTableParseTree * aParseTree,
                                qcmTableInfo     * aTableInfo,
                                qcmColumn        * aNewTableColumns,
                                mtcColumn        * aMtcColumns,
                                UInt             * aDelColumnID,
                                SInt               aColumnCount )
{
/***********************************************************************
 *
 * Description :
 *      ALTER TABLE ... DROP COL 관련 executeDropCol 함수로부터 호출
 *
 * Implementation :
 *      1. drop 되지 않는 컬럼들로만 aNewTableColumns 구성
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::deleteColInfo"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY(""));

    qcmColumn * sSrcColumn;
    qcmColumn * sDstColumn;

    SInt        i,j;
    UInt        sRemoveID   = 0;
    SInt        sTableID;
    SInt        sCurrentOffset;

    i = j = 0;
    sSrcColumn = aTableInfo->columns;

    sTableID = aTableInfo->columns->basicInfo->column.id /
        SMI_COLUMN_ID_MAXIMUM;

    if ( smiTableSpace::isMemTableSpaceType( aTableInfo->TBSType ) == ID_TRUE )
    {
        sCurrentOffset = smiGetRowHeaderSize(SMI_TABLE_MEMORY);
    }
    else if ( smiTableSpace::isVolatileTableSpaceType( aTableInfo->TBSType ) == ID_TRUE )
    {
        sCurrentOffset = smiGetRowHeaderSize(SMI_TABLE_VOLATILE);
    }
    else
    {
        IDE_DASSERT( smiTableSpace::isDiskTableSpaceType( aTableInfo->TBSType ) == ID_TRUE );

        sCurrentOffset = 0;
    }

    while (sSrcColumn != NULL)
    {
        // columns to be excluded.
        sDstColumn = aParseTree->columns;
        while ( sDstColumn != NULL)
        {
            if ( idlOS::strMatch( sSrcColumn->name,
                                  (SInt) idlOS::strlen(sSrcColumn->name),
                                  sDstColumn->namePos.stmtText + sDstColumn->namePos.offset,
                                  sDstColumn->namePos.size ) == 0 )
            {
                break;
            }

            sDstColumn = sDstColumn->next;
        }

        if (sDstColumn != NULL)
        { // this column has to be excluded.
            
            // BUG-44814 제거된 컬럼의 id를 알아낸다.
            aDelColumnID[j] = sRemoveID;
            ++j;

            ++sRemoveID;
            sSrcColumn = sSrcColumn->next;
            continue;
        }
        else
        {
            idlOS::memcpy(&aNewTableColumns[i], sSrcColumn,
                          ID_SIZEOF(qcmColumn));
            idlOS::memcpy(&aMtcColumns[i],
                          sSrcColumn->basicInfo, ID_SIZEOF(mtcColumn));
            aNewTableColumns[i].basicInfo = &aMtcColumns[i];
            aMtcColumns[i].column.id = sTableID * SMI_COLUMN_ID_MAXIMUM + i;

            // fix BUG-14204
            if( sSrcColumn->defaultValueStr != NULL )
            {
                IDU_FIT_POINT( "qdbAlter::deleteColInfo::alloc::defaultValue",
                                idERR_ABORT_InsufficientMemory );

                IDE_TEST( STRUCT_ALLOC( aStatement->qmxMem,
                                        qtcNode,
                                        &(aNewTableColumns[i].defaultValue))
                          != IDE_SUCCESS);
            }
            else
            {
                // Nothing To Do
            }

            // PROJ-1579 NCHAR
            // old column의 default value는 이미 메타 테이블에 저장되어 있음
            aNewTableColumns[i].ncharLiteralPos = NULL;

            sSrcColumn = sSrcColumn->next;
            if (i == aColumnCount -1)
            {
                aNewTableColumns[i].next = NULL;
            }
            else
            {
                aNewTableColumns[i].next = &aNewTableColumns[i+1];
            }
            i++;
            ++sRemoveID;
        }
    }

    IDE_TEST( qdbCommon::setColListOffset( aStatement->qmxMem,
                                           aNewTableColumns,
                                           sCurrentOffset )
              != IDE_SUCCESS );

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::executeRenameTable(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... RENAME TO ..., RENAME ... TO ... 의 execution 수행
 *
 * Implementation :
 *    1. SYS_TABLES_ 에서 테이블 이름 변경 => qdbCommon::updateTableSpecFromMeta
 *    2. 테이블 ID, OID 구해두기
 *    3. related PSM 을 invalid 상태로 변경
 *    4. related VIEW 을 invalid 상태로 변경
 *    5. qcm::touchTable
 *    6. 메타 캐쉬 재구성
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::executeRenameTable"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY(""));

    qdTableParseTree     * sParseTree       = NULL;
    UInt                   sTableID         = 0;
    smOID                  sTableOID        = SM_OID_NULL;
    qcmTableInfo         * sOldTableInfo    = NULL;
    qcmTableInfo         * sTempTableInfo   = NULL;
    void                 * sTableHandle     = NULL;
    smSCN                  sSCN             = SM_SCN_INIT;
    SChar                  sNewTableName[ QC_MAX_OBJECT_NAME_LEN + 1 ];

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // TASK-2176
    // Table에 대한 Lock을 획득한다.
    IDE_TEST( qcm::validateAndLockTable(aStatement,
                                        sParseTree->tableHandle,
                                        sParseTree->tableSCN,
                                        SMI_TABLE_LOCK_X)
              != IDE_SUCCESS);

    sOldTableInfo = sParseTree->tableInfo;

    IDE_TEST(qdbCommon::updateTableSpecFromMeta(
                 aStatement,
                 sParseTree->userName,
                 sParseTree->newTableName,
                 sParseTree->tableInfo->tableID,
                 smiGetTableId(sParseTree->tableInfo->tableHandle),
                 sParseTree->tableInfo->columnCount,
                 sParseTree->tableInfo->parallelDegree )
             != IDE_SUCCESS);

    sTableID = sParseTree->tableInfo->tableID;
    sTableOID = smiGetTableId(sParseTree->tableInfo->tableHandle);

    // BUG-21387 COMMENT
    QC_STR_COPY( sNewTableName, sParseTree->newTableName );

    IDE_TEST(qdbComment::updateCommentTable(
                 aStatement,
                 sParseTree->tableInfo->tableOwnerName,
                 sParseTree->tableInfo->name,
                 sNewTableName )
             != IDE_SUCCESS);

    // PROJ-2223 audit
    IDE_TEST( qcmAudit::updateObjectName(
                  aStatement,
                  sParseTree->tableInfo->tableOwnerID,
                  sParseTree->tableInfo->name,
                  sNewTableName )
              != IDE_SUCCESS );
    
    /* PROJ-2197 PSM Renewal */
    // related PSM
    IDE_TEST(qcmProc::relSetInvalidProcOfRelated(
        aStatement,
        sParseTree->tableInfo->tableOwnerID,
        sParseTree->tableInfo->name,
        idlOS::strlen((SChar*)sParseTree->tableInfo->name),
        QS_TABLE) != IDE_SUCCESS);

    // PROJ-1073 Package
    IDE_TEST( qcmPkg::relSetInvalidPkgOfRelated(
            aStatement,
            sParseTree->tableInfo->tableOwnerID,
            sParseTree->tableInfo->name,
            idlOS::strlen((SChar*)sParseTree->tableInfo->name),
            QS_TABLE ) != IDE_SUCCESS );

    // related VIEW
    IDE_TEST(qcmView::setInvalidViewOfRelated(
                 aStatement,
                 sParseTree->tableInfo->tableOwnerID,
                 sParseTree->tableInfo->name,
                 idlOS::strlen((SChar*)sParseTree->tableInfo->name),
                 QS_TABLE) != IDE_SUCCESS);

    IDE_TEST(qcm::touchTable( QC_SMI_STMT( aStatement ),
                              sTableID,
                              SMI_TBSLV_DDL_DML )
             != IDE_SUCCESS);

    IDE_TEST(qcm::makeAndSetQcmTableInfo( QC_SMI_STMT( aStatement ),
                                          sTableID,
                                          sTableOID)
             != IDE_SUCCESS);

    IDE_TEST(qcm::getTableInfoByID(aStatement,
                                   sTableID,
                                   &sTempTableInfo,
                                   &sSCN,
                                   &sTableHandle)
             != IDE_SUCCESS);

    // BUG-11266
    IDE_TEST(qcmView::recompileAndSetValidViewOfRelated(
                 aStatement,
                 sTempTableInfo->tableOwnerID,
                 sTempTableInfo->name,
                 idlOS::strlen((SChar*)sTempTableInfo->name),
                 QS_TABLE)
             != IDE_SUCCESS);

    // PROJ-1442 Table Meta Log Record 기록
    if(QCU_DDL_SUPPLEMENTAL_LOG == 1)
    {
        IDE_TEST(qci::mManageReplicationCallback.mWriteTableMetaLog(
                                                                aStatement,
                                                                sTableOID,
                                                                sTableOID)
                 != IDE_SUCCESS);
    }
    
    IDE_TEST(qdnTrigger::executeRenameTable( aStatement, sTempTableInfo )
             != IDE_SUCCESS);

    (void)qcm::destroyQcmTableInfo(sOldTableInfo);

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    (void)qcm::destroyQcmTableInfo( sTempTableInfo );

    // on failure, restore tempinfo.
    qcmPartition::restoreTempInfo( sOldTableInfo,
                                   NULL,
                                   NULL );

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::executeSetDefault(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... ALTER COLUMN (... SET DEFAULT ...) 의 execution 수행
 *
 * Implementation :
 *    1. set SYSDATE => qtc::sysdate
 *    2. 명시된 값을 해당 컬럼의 데이터  타입으로 변환할 수 있는 지
 *       체크한 후, 변환 => qdbCommon::convertDefaultValueType
 *    3. SYS_COLUMNS_ 에서 디폴트 값 변경 => updateColumnSpecDefault
 *    4. related PSM 을 invalid 상태로 변경
 *    5. qcm::touchTable
 *    6. 메타 캐쉬 재구성
 *
 * Replication이 걸린 Table에 대한 DDL인 경우, 추가적으로 아래의 작업을 한다.
 *    1. Validate와 Execute는 다른 Transaction이므로, 프라퍼티 검사는 Execute에서 한다.
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::executeSetDefault"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY(""));

    qdTableParseTree    * sParseTree;
    UInt                  sTableID;
    smOID                 sTableOID;
    qcmTableInfo        * sOldTableInfo = NULL;
    SChar               * sDefaultValueStr;

    // PROJ-1579 NCHAR
    UInt              sAddSize = 0;
    SChar           * sDefValBuffer = NULL;
    qcNamePosList   * sNcharList = NULL;
    qcNamePosition    sNamePos;
    UInt              sBufferSize = 0;

    qcmPartitionInfoList * sOldPartInfoList = NULL;
    qcmPartitionInfoList * sNewPartInfoList = NULL;
    qcmTableInfo         * sNewTableInfo    = NULL;
    smSCN                  sNewSCN          = SM_SCN_INIT;
    void                 * sNewTableHandle  = NULL;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // TASK-2176
    // Table에 대한 Lock을 획득한다.
    IDE_TEST( qcm::validateAndLockTable(aStatement,
                                        sParseTree->tableHandle,
                                        sParseTree->tableSCN,
                                        SMI_TABLE_LOCK_X)
              != IDE_SUCCESS);

    sOldTableInfo = sParseTree->tableInfo;

    // PROJ-1502 PARTITIONED DISK TABLE
    if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST( qcmPartition::validateAndLockPartitionInfoList( aStatement,
                                                                  sParseTree->partTable->partInfoList,
                                                                  SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                                  SMI_TABLE_LOCK_X,
                                                                  ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                                    ID_ULONG_MAX :
                                                                    smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );

        // 예외 처리를 위하여, Lock을 잡은 후에 Partition List를 설정한다.
        sOldPartInfoList = sParseTree->partTable->partInfoList;
    }
    else
    {
        /* Nothing to do */
    }

    IDE_TEST( qtc::setDatePseudoColumn( QC_PRIVATE_TMPLATE( aStatement ) ) != IDE_SUCCESS );

    // PROJ-1407 Temporary table
    // session temporary table이 존재하는 경우 DDL을 할 수 없다.
    IDE_TEST_RAISE( qcuTemporaryObj::existSessionTable( sOldTableInfo ) == ID_TRUE,
                    ERR_SESSION_TEMPORARY_TABLE_EXIST );

    /* PROJ-1442 Replication Online 중 DDL 허용
     * Validate와 Execute는 다른 Transaction이므로, 프라퍼티 검사는 Execute에서 한다.
     */
    if(sOldTableInfo->replicationCount > 0)
    {
        IDE_TEST( qci::mManageReplicationCallback.mIsDDLEnableOnReplicatedTable( 0, 
                                                                                 sOldTableInfo )
                  != IDE_SUCCESS );
    }

    IDE_TEST(qdbCommon::convertDefaultValueType(
                 aStatement,
                 &sParseTree->columns->basicInfo->type,
                 sParseTree->columns->defaultValue,
                 NULL)
             != IDE_SUCCESS);

    // PROJ-1579 NCHAR
    // NCHAR LITERAL => UNICODE LITERAL 부분의 처리
    if( sParseTree->ncharList != NULL )
    {
        for( sNcharList = sParseTree->ncharList;
             sNcharList != NULL;
             sNcharList = sNcharList->next )
        {
            sNamePos = sNcharList->namePos;

            // U 타입으로 변환하면서 늘어나는 사이즈 계산
            sAddSize += (sNamePos.size - 3) * 2;
        }

        sBufferSize = sParseTree->columns->defaultValue->position.size +
                      sAddSize;

        IDU_LIMITPOINT("qdbAlter::executeSetDefault::malloc");
        IDE_TEST(STRUCT_ALLOC_WITH_SIZE(aStatement->qmxMem,
                                        SChar,
                                        sBufferSize,
                                        & sDefValBuffer)
                 != IDE_SUCCESS);

        IDE_TEST( qdbCommon::convertToUTypeString(
                      aStatement,
                      sParseTree->columns->defaultValue->position.offset,
                      sParseTree->columns->defaultValue->position.size,
                      sParseTree->ncharList,
                      sDefValBuffer,
                      sBufferSize )
                  != IDE_SUCCESS );

        IDE_TEST(qdbCommon::getStrForMeta(
                     aStatement,
                     sDefValBuffer,
                     idlOS::strlen( sDefValBuffer ),
                     &sDefaultValueStr)
                 != IDE_SUCCESS);
    }
    else
    {
        IDE_TEST(qdbCommon::getStrForMeta(
                     aStatement,
                     sParseTree->columns->defaultValue->position.stmtText +
                     sParseTree->columns->defaultValue->position.offset,
                     sParseTree->columns->defaultValue->position.size,
                     &sDefaultValueStr)
                 != IDE_SUCCESS);
    }

    sParseTree->columns->defaultValueStr = (UChar*)sDefaultValueStr;

    IDE_TEST(updateColumnSpecDefault(aStatement,
                                     sParseTree->columns)
             != IDE_SUCCESS);
    sTableID = sParseTree->tableInfo->tableID;
    sTableOID = smiGetTableId(sParseTree->tableInfo->tableHandle);

    // fix BUG-14394
    IDE_TEST(qdbCommon::updateTableSpecFromMeta(
                 aStatement,
                 sParseTree->userName,
                 sParseTree->tableName,
                 sTableID,
                 sTableOID,
                 sParseTree->tableInfo->columnCount,
                 sParseTree->tableInfo->parallelDegree )
             != IDE_SUCCESS);

    IDE_TEST(qcm::touchTable(QC_SMI_STMT( aStatement ),
                             sTableID,
                             SMI_TBSLV_DDL_DML )
             != IDE_SUCCESS);

    IDE_TEST(qcm::makeAndSetQcmTableInfo(
                 QC_SMI_STMT( aStatement ),
                 sTableID,
                 sTableOID) != IDE_SUCCESS);

    IDE_TEST( qcm::getTableInfoByID( aStatement,
                                     sTableID,
                                     & sNewTableInfo,
                                     & sNewSCN,
                                     & sNewTableHandle )
              != IDE_SUCCESS );

    if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST( qcmPartition::touchPartitionInfoList( QC_SMI_STMT( aStatement ),
                                                        sOldPartInfoList )
                  != IDE_SUCCESS );

        IDE_TEST( qcmPartition::makeAndSetAndGetQcmPartitionInfoList( aStatement,
                                                                      sNewTableInfo,
                                                                      sOldPartInfoList,
                                                                      & sNewPartInfoList )
                  != IDE_SUCCESS );

        (void)qcmPartition::destroyQcmPartitionInfoList( sOldPartInfoList );
    }
    else
    {
        /* Nothing to do */
    }

    (void)qcm::destroyQcmTableInfo(sOldTableInfo);

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_SESSION_TEMPORARY_TABLE_EXIST )
    {
        IDE_SET(ideSetErrorCode( qpERR_ABORT_QDB_TEMPORARY_TABLE_DDL_DISABLE ));
    }
    IDE_EXCEPTION_END;

    (void)qcm::destroyQcmTableInfo( sNewTableInfo );
    (void)qcmPartition::destroyQcmPartitionInfoList( sNewPartInfoList );

    qcmPartition::restoreTempInfo( sOldTableInfo,
                                   sOldPartInfoList,
                                   NULL );

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::moveRow( qcStatement      * aStatement,
                          qmsTableRef      * aTableRef,
                          qcmTableInfo     * aTableInfo,
                          const void       * aSrcTable,
                          const void       * aDstTable,
                          qcmColumn        * aSrcTblColumn,
                          qcmColumn        * aDstTblColumn,
                          qcmTableInfo     * aNewTableInfo,
                          qdIndexTableList * aNewIndexTables,
                          idBool             aIsNeedUndoLog )
{
/***********************************************************************
 *
 * Description :
 *    aSrcTable 에 데이터를 aDstTable 로 옮긴다
 *
 *    아래함수에서 호출됨.
 *    qdbAlter::executeAddCol()
 *    qdbAlter::executeDropCol()
 *
 * Implementation :
 *    1. smiTable::backupTableForAlterTable
 *    2. ...
 *    3. smiTable::restoreTableForAlterTable
 *    4. smiTable::dropTable
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::moveRow()"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY("qdbAlter::moveRow()"));

    SChar             * sNullRowValue;
    const void        * sOldRow;
    smiValue          * sNewRow;
    smiValue          * sNullRow;
    smiColumnList     * sSrcColumnList      = NULL;
    smiColumnList     * sBothColumnList     = NULL;
    smiColumnList     * sColumnPtr          = NULL;
    qdbConvertContext * sConvertContextList = NULL;
    qdbConvertContext * sConvertContextPtr  = NULL;
    SInt                sColumnCount = 0;
    UInt                sColumnOrder;
    UInt                sArguCount;
    mtcColumn         * sValueColumn;
    mtvConvert        * sConvert;
    qcmColumn         * sDestCol;
    qcmColumn         * sSrcCol;
    qcmColumn         * sLastCol;
    void              * sValue;
    void              * sCanonizedValue;
    smOID               sTableOID = SMI_NULL_OID;
    UInt                sTableType;
    SInt                sStage = 0;
    smiTableCursor      sSrcTblCursor;
    smiTableCursor      sDstTblCursor;
    smiTableCursor      sDictionaryDstTblCursor;
    mtcEncryptInfo      sEncryptInfo;

    iduMemoryStatus     sQmxMemStatus;

    UInt                sPartitionedTupleRowOffset = 0;
    UInt                sDiskRowSize               = 0;
    scGRID              sRowGRID;
    smiCursorProperties sSrcCursorProperty;
    smiCursorProperties sDstCursorProperty;

    qmxLobInfo        * sLobInfo = NULL;
    void              * sInsRow;
    scGRID              sInsGRID;

    UInt                sLastColumnSize;
    UInt                sSrcColCount = 0;
    UInt                sSrcLobColCount = 0;
    smiFetchColumnList *sSrcFetchColumnList = NULL;
    UInt                sStoringSize = 0;
    void               *sStoringValue;
    void              * sValueTemp;

    qdIndexTableCursors sIndexTableCursorInfo;
    idBool              sInitedCursorInfo = ID_FALSE;
    smOID               sPartOID          = SMI_NULL_OID;

    /* PROJ-1090 Function-based Index */
    idBool              sHasDefaultExpr = ID_FALSE;
    qcmColumn         * sNewColumns = NULL;

    // PROJ-2264 Dictionary table
    const void        * sDicTableHandle;
    void              * sRow;
    smOID             * sRowOID;

    // PROJ-2429 Dictionary based data compress for on-disk DB
    UInt     sNonStoringSize;
    smiValue sValue4Disk;

    qcmTableInfo      * sSrcTableInfo = NULL;

    qdbCallBackInfo     sCallBackInfo = {
        & sQmxMemStatus,
        aStatement->qmxMem,
        QC_PRIVATE_TMPLATE(aStatement),
        aTableInfo,
        NULL,
        NULL,
        NULL,
        ID_FALSE,
        NULL,
        NULL,
        NULL,
        aStatement,
        aSrcTblColumn,
        aDstTblColumn,
        NULL,
        0
    };

    smiAlterTableCallBack sCallBack = {
        (void*) & sCallBackInfo,
        qdbAlter::initializeConvert,
        qdbAlter::finalizeConvert,
        qdbAlter::convertSmiValue,
        qdbAlter::calculateSmiValueArray,
        qdbAlter::printProgressLog
    };

    /* PROJ-2464 hybrid partitioned table 지원
     *  - Move 대상인 SrcTable 기준으로 Move Row를 수행하기 위해서, sSrcTableInfo->tableFlag 를 이용한다.
     */
    IDE_TEST( smiGetTableTempInfo( aSrcTable,
                                   (void**)&( sSrcTableInfo ) )
              != IDE_SUCCESS );

    sTableType = sSrcTableInfo->tableFlag & SMI_TABLE_TYPE_MASK;

    // BUG-42920 DDL display data move progress
    if( aTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        sCallBackInfo.partitionInfo = sSrcTableInfo;
    }
    else
    {
        // nothing to do
    }
    
    //-----------------------------------------
    // src table에 대한 smiColumnList 생성
    //-----------------------------------------

    for( sSrcCol = aSrcTblColumn; sSrcCol != NULL; sSrcCol = sSrcCol->next )
    {
        sSrcColCount++;

        if ( (sSrcCol->basicInfo->column.flag & SMI_COLUMN_TYPE_MASK)
             == SMI_COLUMN_TYPE_LOB )
        {
            sSrcLobColCount++;
        }
    }

    if ( ( sTableType == SMI_TABLE_MEMORY ) ||
         ( sTableType == SMI_TABLE_VOLATILE ) )
    {
        /* ------------------------------------------------
         * create OLD table(*.TBL) file
         * free OLD table fixed/variable pagelist only
         * ----------------------------------------------*/

        sTableOID = smiGetTableId(aSrcTable);

        IDE_TEST(smiTable::backupTableForAlterTable(
                     QC_SMI_STMT( aStatement ),
                     aSrcTable,
                     aDstTable,
                     aStatement->mStatistics) != IDE_SUCCESS);
    }
    else
    {
        //-----------------------------
        // 디스크 테이블
        //-----------------------------

        // PROJ-1362
        // lob-locator를 저장할 공간을 할당한다.
        IDE_TEST( qmx::initializeLobInfo(
                      aStatement,
                      & sLobInfo,
                      (UShort) sSrcLobColCount )
                  != IDE_SUCCESS );

        // Disk Table인 경우
        // Record Read를 위한 공간을 할당한다.

        // PROJ-1877
        // aSrcTable의 tableInfo는 이미 변경된 경우가 있어
        // aSrcTblColumn을 이용하여 row size를 얻는다.
        IDE_TEST( qdbCommon::getDiskRowSize( aSrcTblColumn,
                                             & sDiskRowSize )
                  != IDE_SUCCESS );

        // To fix BUG-14820
        // Disk-variable 컬럼의 rid비교를 위해 초기화 해야 함.
        IDU_LIMITPOINT("qdbAlter::moveRow::malloc1");
        IDE_TEST( aStatement->qmxMem->cralloc( sDiskRowSize,
                                               (void **) & sOldRow )
                  != IDE_SUCCESS );
        sSrcTblCursor.initialize();
        sDstTblCursor.initialize();

        //-------------------------------------------
        // open src table. ( select )
        // cursor property 설정.
        //
        // PROJ-1705
        // fetch column list 정보를 구성해서 sm으로 내린다.
        //-------------------------------------------

        SMI_CURSOR_PROP_INIT_FOR_FULL_SCAN( &sSrcCursorProperty, aStatement->mStatistics );
        sSrcCursorProperty.mLockWaitMicroSec = 0;

        IDE_TEST( qdbCommon::makeFetchColumnList( QC_PRIVATE_TMPLATE(aStatement),
                                                  sSrcColCount,
                                                  aSrcTblColumn,
                                                  ID_TRUE,   // alloc smiColumnList
                                                  & sSrcFetchColumnList )
              != IDE_SUCCESS );

        sSrcCursorProperty.mFetchColumnList = sSrcFetchColumnList;

        IDE_TEST(
            sSrcTblCursor.open(
                QC_SMI_STMT( aStatement ),
                aSrcTable,
                NULL,
                smiGetRowSCN(aSrcTable),
                NULL,
                smiGetDefaultKeyRange(),
                smiGetDefaultKeyRange(),
                smiGetDefaultFilter(),
                SMI_LOCK_READ|
                SMI_TRAVERSE_FORWARD|
                SMI_PREVIOUS_DISABLE,
                SMI_SELECT_CURSOR,
                & sSrcCursorProperty )
            != IDE_SUCCESS);
        sStage = 1;

        //-------------------------------------------
        // open destination table. ( insert )
        // cursor property 설정.
        //-------------------------------------------

        SMI_CURSOR_PROP_INIT_FOR_FULL_SCAN( &sDstCursorProperty, aStatement->mStatistics );

        sDstCursorProperty.mIsUndoLogging = aIsNeedUndoLog;

        IDE_TEST(
            sDstTblCursor.open(
                QC_SMI_STMT( aStatement ),
                aDstTable,
                NULL,
                smiGetRowSCN(aDstTable),
                NULL,
                smiGetDefaultKeyRange(),
                smiGetDefaultKeyRange(),
                smiGetDefaultFilter(),
                SMI_LOCK_WRITE|
                SMI_TRAVERSE_FORWARD|
                SMI_PREVIOUS_DISABLE,
                SMI_INSERT_CURSOR,
                & sDstCursorProperty )
            != IDE_SUCCESS);
        sStage += 2;
    }

    /* ------------------------------------------------
     * make new row values
     * ----------------------------------------------*/
    sColumnCount = 0;
    sDestCol = aDstTblColumn;
    sLastCol = aDstTblColumn;

    while (sDestCol != NULL)
    {
        if( sDestCol->basicInfo->column.offset >
            sLastCol->basicInfo->column.offset )
        {
            sLastCol = sDestCol;
        }
        sColumnCount ++;
        sDestCol = sDestCol->next;
    }

    IDU_LIMITPOINT("qdbAlter::moveRow::malloc2");
    IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(smiValue) *
                                       sColumnCount,
                                       (void**)&sNewRow)
             != IDE_SUCCESS);

    IDU_LIMITPOINT("qdbAlter::moveRow::malloc3");
    IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(smiValue) *
                                       sColumnCount,
                                       (void**)&sNullRow)
             != IDE_SUCCESS);

    // PROJ-2264 Dictionary table
    if( (sLastCol->basicInfo->column.flag & SMI_COLUMN_COMPRESSION_MASK)
        == SMI_COLUMN_COMPRESSION_FALSE )
    {
        sLastColumnSize = sLastCol->basicInfo->module->nullValueSize();
    }
    else
    {
        sLastColumnSize = idlOS::align8( ID_SIZEOF(smOID) );
    }

    IDU_LIMITPOINT("qdbAlter::moveRow::malloc4");
    IDE_TEST(aStatement->qmxMem->alloc(
                 sLastCol->basicInfo->column.offset + sLastColumnSize,
                 (void**)&sNullRowValue )
             != IDE_SUCCESS);

    sDestCol = aDstTblColumn;

    while (sDestCol != NULL)
    {
        sColumnOrder = (sDestCol->basicInfo->column.id & SMI_COLUMN_ID_MASK);
        sSrcCol = aSrcTblColumn;
        while (sSrcCol != NULL)
        {
            if ( idlOS::strMatch( sSrcCol->name,
                                  idlOS::strlen( sSrcCol->name ),
                                  sDestCol->name,
                                  idlOS::strlen( sDestCol->name ) ) == 0 )
            {
                break;
            }
            else
            {
                sSrcCol = sSrcCol->next;
            }
        }

        //------------------------------
        // make null row
        //------------------------------

        // PROJ-1877
        // modify column 기능으로 기존의 null에 대하여 새로운 type에서의
        // null 값을 필요하게 되어 모든 dest column에 대한 null value를
        // 생성한다.

        // PROJ-2264 Dictionary table
        // Compression column 은 null 값 대신 dictionary table 에 존재하는
        // null row 의 smOID 를 가져야 한다.
        if( (sDestCol->basicInfo->column.flag & SMI_COLUMN_COMPRESSION_MASK)
            == SMI_COLUMN_COMPRESSION_FALSE )
        {
            // Variable column에 대해서는 smiValue.vlaue에 NULL을 할당한다.
            if( ( sDestCol->basicInfo->column.flag & SMI_COLUMN_TYPE_MASK )
                != SMI_COLUMN_TYPE_FIXED )
            {
                sNullRow[sColumnOrder].value = NULL;
                sNullRow[sColumnOrder].length = 0;
            }
            else
            {
                // PROJ-1705
                sValueTemp = (void*)mtc::value( sDestCol->basicInfo,
                                                sNullRowValue,
                                                MTD_OFFSET_USE );
                
                sDestCol->basicInfo->module->null( (sDestCol->basicInfo),
                                                   sValueTemp );

                IDE_TEST( qdbCommon::mtdValue2StoringValue(
                              sDestCol->basicInfo,
                              sDestCol->basicInfo,
                              sValueTemp,
                              &sStoringValue )
                          != IDE_SUCCESS );
                sNullRow[sColumnOrder].value = sStoringValue;

                IDE_TEST( qdbCommon::storingSize( sDestCol->basicInfo,
                                                  sDestCol->basicInfo,
                                                  sValueTemp,
                                                  &sStoringSize )
                          != IDE_SUCCESS );
                sNullRow[sColumnOrder].length = sStoringSize;
            }
        }
        else
        {
            // PROJ-2264 Dictionary table
            // 여기서 찾은 Null 값은 dictionary table 의 Null row 에 있는 값이다.
            // 기존에 존재하는 컬럼일 경우 이 값을 사용하지 않고,
            // 새로 추가하는 컬럼일 경우 이 값을 dictionary table 에 insert 하고
            // 그 OID 를 data table 에 넣는다.
            //
            // Compression column 은 mtc::value 를 할 경우 OID 를 읽어 dictionary table 에 있는 값을 읽어오려 한다.
            // 아직 dictionary table 은 비어있고, 실제 이렇게 읽어 올 필요 없이 null value 만 sNullRow 에 채우면 되므로
            // 직접 주소 연산을 한다.
            sValue = sNullRowValue + sDestCol->basicInfo->column.offset;

            sDestCol->basicInfo->module->null( (sDestCol->basicInfo),
                                               sValue );

            IDE_TEST( qdbCommon::mtdValue2StoringValue(
                          sDestCol->basicInfo,
                          sDestCol->basicInfo,
                          sValue,
                          &sStoringValue )
                      != IDE_SUCCESS );
            sNullRow[sColumnOrder].value = sStoringValue;

            IDE_TEST( qdbCommon::storingSize( sDestCol->basicInfo,
                                              sDestCol->basicInfo,
                                              sValue,
                                              &sStoringSize )
                      != IDE_SUCCESS );
            sNullRow[sColumnOrder].length = sStoringSize;
        }

        if (sSrcCol != NULL)
        {
            /* ------------------------------------------------
             * NEW/OLD Table에 모두 공통된 smiColumnList
             * ----------------------------------------------*/

            if (sBothColumnList == NULL)
            {
                IDU_LIMITPOINT("qdbAlter::moveRow::malloc5");
                IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(smiColumnList),
                                                   (void**)&sBothColumnList)
                         != IDE_SUCCESS);

                sColumnPtr = sBothColumnList;
            }
            else
            {
                IDU_LIMITPOINT("qdbAlter::moveRow::malloc6");
                IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(smiColumnList),
                                                   (void**)&(sColumnPtr->next))
                         != IDE_SUCCESS);

                sColumnPtr = sColumnPtr->next;
            }

            sColumnPtr->column = (smiColumn *)&(sSrcCol->basicInfo->column);
            sColumnPtr->next   = NULL;

            /* ------------------------------------------------
             * NEW/OLD Table에 모두 공통된 column에 대한 convert list
             * ----------------------------------------------*/

            if (sConvertContextList == NULL)
            {
                IDU_LIMITPOINT("qdbAlter::moveRow::malloc7");
                IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(qdbConvertContext),
                                                   (void**)&sConvertContextList)
                         != IDE_SUCCESS);

                sConvertContextPtr = sConvertContextList;
            }
            else
            {
                IDU_LIMITPOINT("qdbAlter::moveRow::malloc8");
                IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(qdbConvertContext),
                                                   (void**)&(sConvertContextPtr->next))
                         != IDE_SUCCESS);

                sConvertContextPtr = sConvertContextPtr->next;
            }

            // PROJ-1877
            // src column과 dest column이 서로 다른 type인 경우
            // convert context를 생성한다.
            IDE_TEST( makeConvertContext( aStatement,
                                          sSrcCol->basicInfo,
                                          sDestCol->basicInfo,
                                          sConvertContextPtr )
                      != IDE_SUCCESS );

            sConvertContextPtr->next = NULL;
        }
        else
        {
            /* ------------------------------------------------
             * NEW에만 해당하는 smiColumnList
             * ----------------------------------------------*/

            // this column is a new added column.
            if (sDestCol->defaultValue == NULL) // set NULL for added column
            {
                // make new row
                if( ( sDestCol->basicInfo->flag & MTC_COLUMN_TIMESTAMP_MASK )
                    == MTC_COLUMN_TIMESTAMP_FALSE )
                {
                    sNewRow[sColumnOrder].length =
                        sNullRow[sColumnOrder].length;
                    sNewRow[sColumnOrder].value  =
                        sNullRow[sColumnOrder].value;
                }
                else
                {
                    // set timestamp
                    IDU_LIMITPOINT("qdbAlter::moveRow::malloc9");
                    IDE_TEST(aStatement->qmxMem->alloc(
                                 MTD_BYTE_TYPE_STRUCT_SIZE(
                                     QC_BYTE_PRECISION_FOR_TIMESTAMP
                                     ),
                                 &sValue)
                             != IDE_SUCCESS);

                    ((mtdByteType*)sValue)->length = QC_BYTE_PRECISION_FOR_TIMESTAMP;

                    IDE_TEST( qmx::setTimeStamp( ((mtdByteType*)sValue)->value ) != IDE_SUCCESS );

                    IDE_TEST( qdbCommon::storingSize( sDestCol->basicInfo,
                                                      sDestCol->basicInfo,
                                                      sValue,
                                                      &sStoringSize )
                              != IDE_SUCCESS );
                    sNewRow[sColumnOrder].length = sStoringSize;

                    IDE_TEST( qdbCommon::mtdValue2StoringValue( sDestCol->basicInfo,
                                                      sDestCol->basicInfo,
                                                      sValue,
                                                      &sStoringValue )
                              != IDE_SUCCESS );
                    sNewRow[sColumnOrder].value  = sStoringValue;
                }
            }
            else
            {
                /* PROJ-1090 Function-based Index */
                if ( (sDestCol->flag & QCM_COLUMN_HIDDEN_COLUMN_MASK)
                     == QCM_COLUMN_HIDDEN_COLUMN_TRUE )
                {
                    sNewRow[sColumnOrder].length =
                        sNullRow[sColumnOrder].length;
                    sNewRow[sColumnOrder].value  =
                        sNullRow[sColumnOrder].value;
                    
                    if ( sHasDefaultExpr != ID_TRUE )
                    {
                        sHasDefaultExpr = ID_TRUE;

                        /* 추가되는 첫 컬럼을 기록 */
                        sNewColumns = sDestCol;
                    }
                    else
                    {
                        /* Nothing to do */
                    }
                }
                else // set DEFAULT value for added column
                {
                    // make default value
                    // Sequence Value 임시 저장
                    IDE_TEST( qmx::dummySequenceNextVals(
                                  aStatement,
                                  aStatement->myPlan->parseTree->nextValSeqs )
                              != IDE_SUCCESS );

                    IDE_TEST(qtc::calculate(sDestCol->defaultValue,
                                            QC_PRIVATE_TMPLATE(aStatement)) != IDE_SUCCESS);
                    sValueColumn =
                        &( QC_PRIVATE_TMPLATE(aStatement)->tmplate.
                           rows[sDestCol->defaultValue->node.table].
                           columns[sDestCol->defaultValue->node.column]);

                    // check conversion
                    /* PROJ-1361 : data type과 language module 분리했음 */

                    if (sDestCol->basicInfo->type.dataTypeId ==
                        sValueColumn->type.dataTypeId )
                    {
                        // same type
                        sValue = QC_PRIVATE_TMPLATE(aStatement)->tmplate.stack[0].value;
                    }
                    else
                    {
                        // convert
                        sArguCount =
                            sValueColumn->flag & MTC_COLUMN_ARGUMENT_COUNT_MASK;

                        IDE_TEST(mtv::estimateConvert4Server(
                                     aStatement->qmxMem,
                                     &sConvert,
                                     sDestCol->basicInfo->type,     //aDestinationType
                                     sValueColumn->type,            //aSourceType
                                     sArguCount,                    // aSourceArgument
                                     sValueColumn->precision,       // aSourcePrecision
                                     sValueColumn->scale,           // aSourceScale
                                     & QC_PRIVATE_TMPLATE(aStatement)->tmplate) // mtcTemplate* :
                                 // for passing session
                                 // dateFormat
                                 != IDE_SUCCESS);

                        // source value pointer
                        sConvert->stack[sConvert->count].value =
                            QC_PRIVATE_TMPLATE(aStatement)->tmplate.stack[0].value;

                        // destination value pointer
                        sValueColumn = sConvert->stack[0].column;
                        sValue       = sConvert->stack[0].value;

                        IDE_TEST(
                            mtv::executeConvert( sConvert,
                                                 &QC_PRIVATE_TMPLATE(aStatement)->tmplate )
                            != IDE_SUCCESS);
                    }

                    // PROJ-2002 Column Security
                    if ( ( sDestCol->basicInfo->module->flag & MTD_ENCRYPT_TYPE_MASK )
                         == MTD_ENCRYPT_TYPE_TRUE )
                    {
                        IDE_TEST( qcsModule::getEncryptInfo( aStatement,
                                                             aTableInfo,
                                                             sDestCol,
                                                             & sEncryptInfo )
                                  != IDE_SUCCESS );
                    }
                    else
                    {
                        // Nothing to do.
                    }

                    // canonize
                    if ( ( sDestCol->basicInfo->module->flag & MTD_CANON_MASK )
                         == MTD_CANON_NEED )
                    {
                        sCanonizedValue = sValue;

                        IDE_TEST( sDestCol->basicInfo->module->canonize(
                                      sDestCol->basicInfo,
                                      & sCanonizedValue,           // canonized value
                                      & sEncryptInfo,
                                      sValueColumn,
                                      sValue,                     // original value
                                      NULL,
                                      & QC_PRIVATE_TMPLATE(aStatement)->tmplate )
                                  != IDE_SUCCESS );

                        sValue = sCanonizedValue;
                    }
                    else if ( (sDestCol->basicInfo->module->flag & MTD_CANON_MASK)
                              == MTD_CANON_NEED_WITH_ALLOCATION )
                    {
                        IDU_LIMITPOINT("qdbAlter::moveRow::malloc10");
                        IDE_TEST(aStatement->qmxMem->alloc(
                                     sDestCol->basicInfo->column.size,
                                     (void**)&sCanonizedValue)
                                 != IDE_SUCCESS);

                        IDE_TEST( sDestCol->basicInfo->module->canonize(
                                      sDestCol->basicInfo,
                                      & sCanonizedValue,           // canonized value
                                      & sEncryptInfo,
                                      sValueColumn,
                                      sValue,                     // original value
                                      NULL,
                                      & QC_PRIVATE_TMPLATE(aStatement)->tmplate )
                                  != IDE_SUCCESS );

                        sValue = sCanonizedValue;
                    }
                    else
                    {
                        // Nothing to do.
                    }

                    sColumnOrder = (sDestCol->basicInfo->column.id &
                                    SMI_COLUMN_ID_MASK);

                    if ( ( sDestCol->basicInfo->column.flag & SMI_COLUMN_TYPE_MASK )
                         == SMI_COLUMN_TYPE_LOB )
                    {
                        if( sValueColumn->module->isNull( sValueColumn,
                                                          sValue )
                            != ID_TRUE )
                        {
                            // PROJ-1362
                            IDE_DASSERT( sValueColumn->module->id
                                         == sDestCol->basicInfo->module->id );
                        }
                        else
                        {
                            // Nothing To Do
                        }
                    }
                    else
                    {
                        // Nothing To Do
                    }

                    // PROJ-1705
                    IDE_TEST( qdbCommon::mtdValue2StoringValue( sDestCol->basicInfo,
                                                                sValueColumn,
                                                                sValue,
                                                                &sStoringValue )
                              != IDE_SUCCESS );
                    sNewRow[sColumnOrder].value = sStoringValue;

                    IDE_TEST( qdbCommon::storingSize( sDestCol->basicInfo,
                                                      sValueColumn,
                                                      sValue,
                                                      &sStoringSize )
                              != IDE_SUCCESS );
                    sNewRow[sColumnOrder].length = sStoringSize;

                }
            }

            // PROJ-2264 Dictionary table
            // Compression column 은 새로 추가될 경우 Null value 나 default value 를
            // dictionary table 에 넣고, 그 row 의 OID 를 추가된 컬럼에 채운다.
            if( (sDestCol->basicInfo->column.flag & SMI_COLUMN_COMPRESSION_MASK)
                == SMI_COLUMN_COMPRESSION_TRUE )
            {
                sDicTableHandle = smiGetTable( sDestCol->basicInfo->column.mDictionaryTableOID );
             
                SMI_CURSOR_PROP_INIT_FOR_FULL_SCAN( &sDstCursorProperty, aStatement->mStatistics );

                sDictionaryDstTblCursor.initialize();
                IDE_TEST( sDictionaryDstTblCursor.open(
                              QC_SMI_STMT( aStatement ),
                              sDicTableHandle,
                              NULL,
                              smiGetRowSCN( sDicTableHandle ),
                              NULL,
                              smiGetDefaultKeyRange(),
                              smiGetDefaultKeyRange(),
                              smiGetDefaultFilter(),
                              SMI_LOCK_WRITE|
                              SMI_TRAVERSE_FORWARD|
                              SMI_PREVIOUS_DISABLE,
                              SMI_INSERT_CURSOR,
                              & sDstCursorProperty )
                          != IDE_SUCCESS );
             
                // Dictionary table 에 insert 하고
                // new row 의 value 를 OID 로 덮어쓴다.
                // BUG-36718
                // Variable column 이 null 값을 받을 경우 storing value(smiValue.value) 가
                // NULL pointer 를 가지므로 storing value 에 반환값을 받아서는 안된다.
                // Compressed value 의 row OID 는 별도의 공간에 받아서
                // storing value 에 넣는다.

                IDE_TEST( aStatement->qmxMem->alloc( ID_SIZEOF( smOID ),
                                                     (void **)&sRowOID )
                          != IDE_SUCCESS );

                // PROJ-2429 Dictionary based data compress for on-disk DB
                // qdbCommon::mtdValue2StoringValue, qdbCommon::storingSize 함수를 통해 만들어진
                // disk type의 value를 memory type으로 변환한다.
                if ( smiTableSpace::isDiskTableSpace( sDestCol->basicInfo->column.colSpace ) == ID_TRUE ) 
                {
                    IDE_TEST( mtc::getNonStoringSize( &sDestCol->basicInfo->column, &sNonStoringSize ) 
                              != IDE_SUCCESS );

                    // disk저장 형식의 value를 memory형식으로 변환한다.
                    if ( sNewRow[sColumnOrder].value != NULL )
                    {    
                        sValue4Disk.value  = (void*)((UChar*)sNewRow[sColumnOrder].value - sNonStoringSize); 
                        sValue4Disk.length = sDestCol->basicInfo->module->actualSize(
                            sDestCol->basicInfo, sValue4Disk.value );
                    }    
                    else 
                    {
                        sValue4Disk.value  = sDestCol->basicInfo->module->staticNull; 
                        sValue4Disk.length = sDestCol->basicInfo->module->nullValueSize();
                    }    

                    IDE_TEST( sDictionaryDstTblCursor.insertRowWithIgnoreUniqueError(
                                  &sDictionaryDstTblCursor,
                                  (smcTableHeader *)SMI_MISC_TABLE_HEADER( sDicTableHandle ),
                                  &sValue4Disk,
                                  sRowOID,
                                  &sRow )
                              != IDE_SUCCESS );
                }
                else
                {
                    IDE_TEST( sDictionaryDstTblCursor.insertRowWithIgnoreUniqueError(
                                  &sDictionaryDstTblCursor,
                                  (smcTableHeader *)SMI_MISC_TABLE_HEADER( sDicTableHandle ),
                                  &(sNewRow[sColumnOrder]),
                                  sRowOID,
                                  &sRow )
                              != IDE_SUCCESS );
                }

                IDE_TEST( sDictionaryDstTblCursor.close() != IDE_SUCCESS );

                sNewRow[sColumnOrder].value = sRowOID;
             
                // OID 를 덮어썼으므로 길이도 OID 길이로 설정한다.
                sNewRow[sColumnOrder].length = ID_SIZEOF(smOID);
            }
            else
            {
                // Not compression column.
                // Nothing to do.
            }
        }

        sDestCol = sDestCol->next;
    }

    if ( ( sTableType == SMI_TABLE_MEMORY ) ||
         ( sTableType == SMI_TABLE_VOLATILE ) )
    {
        // bothColumnList는 NEW/OLD Table에 모두 공통된 smiColumnList로,
        // add column, drop column, modify column 수행시
        // 반드시 한 개 이상의 both column이 존재하여야 한다.
        IDE_TEST_RAISE( sBothColumnList == NULL,
                        ERR_INVALID_BOTH_COLUMN_LIST );

        /* ------------------------------------------------
         * get OLD table columnlist ( smiColumnList )
         * ----------------------------------------------*/

        sSrcCol = aSrcTblColumn;
        while (sSrcCol != NULL)
        {
            if (sSrcColumnList == NULL)
            {
                IDU_LIMITPOINT("qdbAlter::moveRow::malloc11");
                IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(smiColumnList),
                                                   (void**)&sSrcColumnList)
                         != IDE_SUCCESS);

                sColumnPtr     = sSrcColumnList;
            }
            else
            {
                IDU_LIMITPOINT("qdbAlter::moveRow::malloc12");
                IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(smiColumnList),
                                                   (void**)&(sColumnPtr->next))
                         != IDE_SUCCESS);

                sColumnPtr       = sColumnPtr->next;
            }

            sColumnPtr->column = (smiColumn *)&(sSrcCol->basicInfo->column);
            sColumnPtr->next   = NULL;

            sSrcCol = sSrcCol->next;
        }

        /* ------------------------------------------------
         * convert context
         * ----------------------------------------------*/

        // PROJ-1877
        // restore시 사용할 convert context 정보를 callback으로 내린다.
        sCallBackInfo.convertContextList = sConvertContextList;
        sCallBackInfo.nullValues = sNullRow;

        /* PROJ-1090 Function-based Index */
        if ( sHasDefaultExpr == ID_TRUE )
        {
            sCallBackInfo.hasDefaultExpr = ID_TRUE;
            sCallBackInfo.srcTableRef    = aTableRef;
            sCallBackInfo.dstTblColumn   = sNewColumns;

            /* PROJ-2464 hybrid partitioned table 지원 */
            sPartitionedTupleRowOffset = qmc::getRowOffsetForTuple( & QC_PRIVATE_TMPLATE(aStatement)->tmplate,
                                                                    aTableRef->table );

            IDU_FIT_POINT( "qdbAlter::moveRow::alloc::sCallBackInfo.rowBuffer",
                           idERR_ABORT_InsufficientMemory );

            IDE_TEST( aStatement->qmxMem->alloc( sPartitionedTupleRowOffset,
                                                 & sCallBackInfo.rowBuffer )
                      != IDE_SUCCESS );
        }
        else
        {
            /* Nothing to do */
        }
        
        /* ------------------------------------------------
         * restore table
         * ----------------------------------------------*/

        IDE_TEST(smiTable::restoreTableForAlterTable(
                     QC_SMI_STMT( aStatement ),
                     aSrcTable,
                     aDstTable,
                     sTableOID,
                     sSrcColumnList,
                     sBothColumnList,
                     sNewRow,
                     & sCallBack )
                 != IDE_SUCCESS);
    }
    else
    {
        //------------------------------------------
        // open index table insert cursors
        //------------------------------------------
        
        if ( aNewIndexTables != NULL )
        {
            IDE_TEST( qdx::initializeInsertIndexTableCursors(
                          aStatement,
                          aNewIndexTables,
                          &sIndexTableCursorInfo,
                          aNewTableInfo->indices,
                          aNewTableInfo->indexCount,
                          sColumnCount,
                          &sDstCursorProperty )
                      != IDE_SUCCESS );
            
            sInitedCursorInfo = ID_TRUE;
            
            sPartOID = smiGetTableId( aDstTable );    
        }
        else
        {
            // Nothing to do.
        }
        
        // move..
        IDE_TEST(sSrcTblCursor.beforeFirst() != IDE_SUCCESS);
        IDE_TEST(sSrcTblCursor.readRow(&sOldRow,
                                       &sRowGRID, SMI_FIND_NEXT)
                 != IDE_SUCCESS);
        
        while (sOldRow != NULL)
        {
            // To Fix PR-11704
            // 레코드 건수에 비례하여 메모리가 증가하지 않도록 해야 함.
            // Memory 재사용을 위하여 현재 위치 기록
            IDE_TEST( aStatement->qmxMem->getStatus(&sQmxMemStatus)
                      != IDE_SUCCESS);

            (void)qmx::clearLobInfo( sLobInfo );

            // default value with sequence 계산
            IDE_TEST( qdbCommon::calculateDefaultValueWithSequence(
                          aStatement,
                          aTableInfo,
                          aSrcTblColumn,
                          aDstTblColumn,
                          sNewRow )
                      != IDE_SUCCESS );

            //------------------------------------------
            // INSERT를 수행
            //------------------------------------------
            IDE_TEST(makeNewRow(QC_PRIVATE_TMPLATE(aStatement),
                                aTableInfo,
                                aSrcTblColumn,
                                aDstTblColumn,
                                sOldRow,
                                sNewRow,
                                & sSrcTblCursor,
                                sRowGRID,
                                sLobInfo,
                                sConvertContextList)
                     != IDE_SUCCESS);

            /* PROJ-1090 Function-based Index */
            if ( sHasDefaultExpr == ID_TRUE )
            {
                IDE_TEST( qmsDefaultExpr::calculateDefaultExpression(
                              QC_PRIVATE_TMPLATE(aStatement),
                              aTableRef,
                              NULL,
                              sNewColumns,
                              sOldRow,
                              sNewRow,
                              aDstTblColumn )
                          != IDE_SUCCESS );
            }
            else
            {
                /* Nothing to do */
            }

            IDE_TEST(sDstTblCursor.insertRow(sNewRow,
                                             & sInsRow,
                                             & sInsGRID)
                     != IDE_SUCCESS);

            //------------------------------------------
            // INSERT를 수행후 Lob 컬럼을 처리
            //------------------------------------------
            
            IDE_TEST( qmx::copyAndOutBindLobInfo( aStatement,
                                                  sLobInfo,
                                                  & sDstTblCursor,
                                                  sInsRow,
                                                  sInsGRID )
                      != IDE_SUCCESS );

            //------------------------------------------
            // INSERT를 수행후 non-partitioned index를 처리
            //------------------------------------------

            if ( aNewIndexTables != NULL )
            {
                IDE_TEST( qdx::insertIndexTableCursors( &sIndexTableCursorInfo,
                                                        sNewRow,
                                                        sPartOID,
                                                        sInsGRID )
                          != IDE_SUCCESS );
            }
            else
            {
                // Nothing to do.
            }

            // BUG-42920 DDL display data move progress
            IDE_TEST( qdbAlter::printProgressLog( &sCallBackInfo,
                                                  ID_FALSE )
                      != IDE_SUCCESS );
            
            // To Fix PR-11704
            // Memory 재사용을 위한 Memory 이동
            IDE_TEST( aStatement->qmxMem->setStatus(&sQmxMemStatus)
                      != IDE_SUCCESS);

            IDE_TEST(sSrcTblCursor.readRow(&sOldRow, &sRowGRID, SMI_FIND_NEXT)
                     != IDE_SUCCESS);
        }

        // BUG-42920 DDL display data move progress
        IDE_TEST( qdbAlter::printProgressLog( &sCallBackInfo,
                                              ID_TRUE )
                  != IDE_SUCCESS );

        // close.
        sStage = 1;
        IDE_TEST(sDstTblCursor.close() != IDE_SUCCESS);
        sStage = 0;
        IDE_TEST(sSrcTblCursor.close() != IDE_SUCCESS);
        
        // close index table cursor
        if ( aNewIndexTables != NULL )
        {
            IDE_TEST( qdx::closeInsertIndexTableCursors(
                          &sIndexTableCursorInfo )
                      != IDE_SUCCESS );
        }
        else
        {
            // Nothing to do.
        }
    }

    IDE_TEST( smiTable::dropTable( QC_SMI_STMT( aStatement ),
                                   aSrcTable,
                                   SMI_TBSLV_DDL_DML )
              != IDE_SUCCESS );

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_INVALID_BOTH_COLUMN_LIST )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QMC_UNEXPECTED_ERROR,
                                  "qdbAlter::moveRow",
                                  "Invalid both column list" ));
    }
    IDE_EXCEPTION_END;

    if (sStage == 1 || sStage == 3)
    {
        sSrcTblCursor.close();
    }
    if (sStage > 1)
    {
        sDstTblCursor.close();
    }

    if ( sInitedCursorInfo == ID_TRUE )
    {
        qdx::finalizeInsertIndexTableCursors(
            &sIndexTableCursorInfo );
    }
    else
    {
        // Nothing to do.
    }
    
    (void)qmx::finalizeLobInfo( aStatement, sLobInfo );

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::updateColumnSpecDefault(qcStatement * aStatement,
                                         qcmColumn   * aColumns )
{
/***********************************************************************
 *
 * Description :
 *      executeDropDefault(디폴트값 삭제),
 *      executeSetDefault(디폴트값 설정) 함수로부터 호출
 *
 * Implementation :
 *      1. SYS_COLUMNS_ 메타 테이블의 DEFAULT_VAL 값 변경
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::updateColumnSpecDefault"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY(""));

    qcmColumn * sColumn;

    SChar     * sSqlStr;
    vSLong      sRowCnt;
    // update meta.
    sColumn = aColumns;
    IDU_LIMITPOINT("qdbAlter::updateColumnSpecDefault::malloc");
    IDE_TEST(STRUCT_ALLOC_WITH_SIZE(aStatement->qmxMem,
                                    SChar,
                                    QD_MAX_SQL_LENGTH,
                                    &sSqlStr)
             != IDE_SUCCESS);
    while (sColumn != NULL)
    {
        if (sColumn->defaultValueStr != NULL)
        {
            idlOS::snprintf( sSqlStr, QD_MAX_SQL_LENGTH,
                             "UPDATE SYS_COLUMNS_ SET DEFAULT_VAL = '%s' "
                             "WHERE COLUMN_ID = %"ID_INT32_FMT"",
                             sColumn->defaultValueStr,
                             sColumn->basicInfo->column.id );
        }
        else
        {
            idlOS::snprintf( sSqlStr, QD_MAX_SQL_LENGTH,
                             "UPDATE SYS_COLUMNS_ SET DEFAULT_VAL = '' "
                             "WHERE COLUMN_ID = %"ID_INT32_FMT"",
                             sColumn->basicInfo->column.id);
        }

        IDE_TEST(qcg::runDMLforDDL(QC_SMI_STMT( aStatement ),
                                   sSqlStr, &sRowCnt) != IDE_SUCCESS);
        IDE_TEST_RAISE(sRowCnt != 1, ERR_BREAK_SCHEMA);
        sColumn = sColumn->next;
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_BREAK_SCHEMA);
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_META_CRASH));
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::executeNotNull(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... ALTER COLUMN (... NOT NULL ...) 의 execution 수행
 *
 * Implementation :
 *    0. 이중화 가능 여부 확인 
 *    1. alter 하고자 하는 컬럼에 널값의 데이터가 없는지 체크 => hasNullValue
 *    2. SYS_COLUMNS_ 메타 테이블 변경 => qdbCommon::updateColumnSpecNull
 *    3. 메타테이블에 새로운 constraint 정보 입력 => qdbCommon::createConstrNotNull
 *    6. 메타 캐쉬 재구성
 *    4. qcm::getTableInfoByID
 *    4. qdbCommon::makeColumnNotNull
 *    14. related PSM 을 invalid 상태로 변경
 *    5. qcm::touchTable
 *    6. 메타 캐쉬 재구성
 *
 ***********************************************************************/

    qcmColumn             * sColumn;
    qdTableParseTree      * sParseTree;
    UInt                    sTableID;
    smOID                   sTableOID;
    smSCN                   sSCN;
    idBool                  sHasNull;
    qcmTableInfo          * sOldTableInfo = NULL;
    qcmTableInfo          * sNewTableInfo = NULL;
    void                  * sTableHandle;
    idBool                  sIsPartitioned = ID_FALSE;
    qcmPartitionInfoList  * sOldPartInfoList = NULL;
    qcmPartitionInfoList  * sNewPartInfoList = NULL;
    smOID                   sOldTableOID = 0;
    smOID                   sNewTableOID = 0;
    smOID                 * sOldPartitionOID = NULL;
    UInt                    sOldPartitionCount = 0;
    idBool                  sIsReplicatedTable = ID_FALSE;
    smOID                 * sOldTableOIDArray = NULL;
    smOID                 * sNewTableOIDArray = NULL;
    UInt                    sTableOIDCount = 0;
    UInt                    sDDLSupplementalLog = QCU_DDL_SUPPLEMENTAL_LOG;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // TASK-2176
    // Table에 대한 Lock을 획득한다.
    IDE_TEST( qcm::validateAndLockTable(aStatement,
                                        sParseTree->tableHandle,
                                        sParseTree->tableSCN,
                                        SMI_TABLE_LOCK_X)
              != IDE_SUCCESS);

    sColumn = sParseTree->columns;
    sOldTableInfo = sParseTree->tableInfo;
    sOldTableOID    = smiGetTableId( sOldTableInfo->tableHandle );

    // PROJ-1407 Temporary table
    // session temporary table이 존재하는 경우 DDL을 할 수 없다.
    IDE_TEST_RAISE( qcuTemporaryObj::existSessionTable( sOldTableInfo ) == ID_TRUE,
                    ERR_SESSION_TEMPORARY_TABLE_EXIST );

    // PROJ-1502 PARTITIONED DISK TABLE
    if( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        sIsPartitioned = ID_TRUE;

        // 모든 파티션에 LOCK(X)
        IDE_TEST( qcmPartition::validateAndLockPartitionInfoList( aStatement,
                                                                  sParseTree->partTable->partInfoList,
                                                                  SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                                  SMI_TABLE_LOCK_X,
                                                                  ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                                    ID_ULONG_MAX :
                                                                    smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );

        // 예외 처리를 위하여, Lock을 잡은 후에 Partition List를 설정한다.
        sOldPartInfoList = sParseTree->partTable->partInfoList;

        if ( ( sOldTableInfo->replicationCount > 0 ) ||
             ( sDDLSupplementalLog == 1 ) )
        {

            IDE_TEST( qcmPartition::getAllPartitionOID( QC_QMX_MEM(aStatement),
                                                        sOldPartInfoList,
                                                        &sOldPartitionOID,
                                                        &sOldPartitionCount )
                      != IDE_SUCCESS );
        }
        else
        {
            /* do nothing */
        }
    }

    // PROJ-2642 Table on Replication Allow DDL
    if ( sOldTableInfo->replicationCount > 0 )
    {
        IDE_TEST( qci::mManageReplicationCallback.mIsDDLEnableOnReplicatedTable( 1,
                                                                                 sOldTableInfo )
                  != IDE_SUCCESS );

        IDE_TEST_RAISE( QC_SMI_STMT( aStatement )->getTrans()->getReplicationMode() == SMI_TRANSACTION_REPL_NONE,
                        ERR_CANNOT_WRITE_REPL_INFO );

        if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
        {
            sOldTableOIDArray = sOldPartitionOID;
            sTableOIDCount = sOldPartitionCount;
        }
        else
        {
            sOldTableOIDArray = &sOldTableOID;
            sTableOIDCount = 1;
        }

        IDE_TEST( qciMisc::checkRunningEagerReplicationByTableOID( aStatement,
                                                                   sOldTableOIDArray,
                                                                   sTableOIDCount )
                  != IDE_SUCCESS );

        IDE_TEST( qci::mManageReplicationCallback.mStopReceiverThreads( QC_SMI_STMT(aStatement),
                                                                        aStatement->mStatistics,
                                                                        sOldTableOIDArray,
                                                                        sTableOIDCount )
                  != IDE_SUCCESS );

        sIsReplicatedTable = ID_TRUE;
    }
    else
    {
        /* do nothing */
    }

    IDE_TEST(hasNullValue(aStatement, sParseTree->tableInfo,
                          sColumn, &sHasNull) != IDE_SUCCESS);

    IDE_TEST_RAISE(sHasNull == ID_TRUE, ERR_HAS_NULL_VALUE);

    // set nullable flag to false.
    IDE_TEST(qdbCommon::updateColumnSpecNull(aStatement, sColumn, ID_FALSE)
             != IDE_SUCCESS);

    IDE_TEST(qdbCommon::createConstrNotNull(
                 aStatement,
                 sParseTree->constraints,
                 sParseTree->userID,
                 sParseTree->tableInfo->tableID)
             != IDE_SUCCESS);

    sTableID = sParseTree->tableInfo->tableID;
    sTableOID = smiGetTableId(sParseTree->tableInfo->tableHandle);

    // fix BUG-14394
    IDE_TEST(qdbCommon::updateTableSpecFromMeta(
                 aStatement,
                 sParseTree->userName,
                 sParseTree->tableName,
                 sTableID,
                 sTableOID,
                 sParseTree->tableInfo->columnCount,
                 sParseTree->tableInfo->parallelDegree )
             != IDE_SUCCESS);

    IDE_TEST(qcm::makeAndSetQcmTableInfo( QC_SMI_STMT( aStatement ),
                                          sTableID,
                                          sTableOID)
             != IDE_SUCCESS);

    IDE_TEST(qcm::getTableInfoByID(aStatement,
                                   sTableID,
                                   &sNewTableInfo,
                                   &sSCN,
                                   &sTableHandle) != IDE_SUCCESS);

    IDE_TEST( qcm::validateAndLockTable(aStatement,
                                        sTableHandle,
                                        sSCN,
                                        SMI_TABLE_LOCK_X)
              != IDE_SUCCESS );

    IDE_TEST(qdbCommon::makeColumnNotNull(
                 aStatement,
                 sParseTree->tableInfo->tableHandle,
                 sParseTree->tableInfo->maxrows,
                 sOldPartInfoList,
                 sIsPartitioned,
                 sColumn->basicInfo->column.id )
             != IDE_SUCCESS);

    IDE_TEST(qcm::touchTable( QC_SMI_STMT( aStatement ),
                              sParseTree->tableInfo->tableID,
                              SMI_TBSLV_DDL_DML )
             != IDE_SUCCESS);

    (void)qcm::destroyQcmTableInfo(sNewTableInfo);
    sNewTableInfo = NULL;

    IDE_TEST(qcm::makeAndSetQcmTableInfo( QC_SMI_STMT( aStatement ),
                                          sTableID,
                                          sTableOID)
             != IDE_SUCCESS);

    IDE_TEST(qcm::getTableInfoByID(aStatement,
                                   sTableID,
                                   &sNewTableInfo,
                                   &sSCN,
                                   &sTableHandle) != IDE_SUCCESS);

    // PROJ-1502 PARTITIONED DISK TABLE
    if( sIsPartitioned == ID_TRUE )
    {
        IDE_TEST( qcmPartition::touchPartitionInfoList( QC_SMI_STMT( aStatement ),
                                                        sOldPartInfoList )
                  != IDE_SUCCESS );

        IDE_TEST( qcmPartition::makeAndSetAndGetQcmPartitionInfoList( aStatement,
                                                                      sNewTableInfo,
                                                                      sOldPartInfoList,
                                                                      & sNewPartInfoList )
                  != IDE_SUCCESS );
    }

    // PROJ-2642 Table on Replication Allow DDL
    if ( ( sIsReplicatedTable == ID_TRUE ) ||
         ( sDDLSupplementalLog == 1 ) )
    {
        sNewTableOID = smiGetTableId( sNewTableInfo->tableHandle );

        if ( sIsPartitioned == ID_FALSE )
        {
            sOldTableOIDArray = &sOldTableOID;
            sNewTableOIDArray = &sNewTableOID;
            sTableOIDCount = 1;
        }
        else
        {
            sOldTableOIDArray = sOldPartitionOID;

            IDE_TEST( qcmPartition::getAllPartitionOID( QC_QMX_MEM(aStatement),
                                                        sNewPartInfoList,
                                                        &sNewTableOIDArray,
                                                        &sTableOIDCount )
                      != IDE_SUCCESS );
        }

        IDE_TEST( qciMisc::writeTableMetaLogForReplication( aStatement,
                                                            sOldTableOIDArray,
                                                            sNewTableOIDArray,
                                                            sTableOIDCount )
                  != IDE_SUCCESS );

    }
    else
    {
        /* do nothing */
    }

    if ( sIsPartitioned == ID_TRUE )
    {
        (void)qcmPartition::destroyQcmPartitionInfoList( sOldPartInfoList );
    }
    else
    {
        /* do nothing */
    }

    (void)qcm::destroyQcmTableInfo(sOldTableInfo);

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_SESSION_TEMPORARY_TABLE_EXIST )
    {
        IDE_SET(ideSetErrorCode( qpERR_ABORT_QDB_TEMPORARY_TABLE_DDL_DISABLE ));
    }
    IDE_EXCEPTION(ERR_HAS_NULL_VALUE);
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_NOTNULL_HAS_NULL));
    }
    IDE_EXCEPTION( ERR_CANNOT_WRITE_REPL_INFO )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_CANNOT_WRITE_REPL_INFO ) );
    }
    IDE_EXCEPTION_END;

    (void)qcm::destroyQcmTableInfo( sNewTableInfo );
    (void)qcmPartition::destroyQcmPartitionInfoList( sNewPartInfoList );

    // on failure, restore tempinfo.
    qcmPartition::restoreTempInfo( sOldTableInfo,
                                   sOldPartInfoList,
                                   NULL );

    return IDE_FAILURE;
}

IDE_RC qdbAlter::executeNullable(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *      ALTER TABLE ... ALTER COLUMN ( ... NULL ) 수행
 *
 * Implementation :
 *      0. 이중화 가능 여부 확인 
 *      1. set nullable flag to true(메타 테이블 SYS_COLUMNS_ 변경)
 *      2. SYS_CONSTRAINTS_, SYS_CONSTRAINT_COLUMNs_ 메타 테이블에서
 *         NOT NULL constraint 정보 삭제
 *      3. 관련 PSM 상태를 invalid 로 변경
 *      4. 메타 캐쉬 재구성
 *      5. 이중화 대상 이면 writeMetaLog 수행
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::executeNullable"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY(""));

    qcmColumn             * sColumn;
    qdTableParseTree      * sParseTree;
    UInt                    sTableID;
    smOID                   sOldTableOID = 0;
    smOID                   sNewTableOID = 0;
    smSCN                   sSCN;
    qcmTableInfo          * sOldTableInfo  = NULL;
    qcmTableInfo          * sNewTableInfo  = NULL;
    qcmTableInfo          * sTempTableInfo = NULL;
    void                  * sTableHandle;
    idBool                  sIsPartitioned   = ID_FALSE;
    qcmPartitionInfoList  * sOldPartInfoList = NULL;
    qcmPartitionInfoList  * sNewPartInfoList = NULL;
    smOID                 * sOldPartitionOID = NULL;
    UInt                    sOldPartitionCount = 0;
    idBool                  sIsReplicatedTable = ID_FALSE;
    smOID                 * sOldTableOIDArray = NULL;
    smOID                 * sNewTableOIDArray = NULL;
    UInt                    sTableOIDCount = 0;
    UInt                    sDDLSupplementalLog = QCU_DDL_SUPPLEMENTAL_LOG;


    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // TASK-2176
    // Table에 대한 Lock을 획득한다.
    IDE_TEST( qcm::validateAndLockTable(aStatement,
                                        sParseTree->tableHandle,
                                        sParseTree->tableSCN,
                                        SMI_TABLE_LOCK_X)
              != IDE_SUCCESS);

    sColumn = sParseTree->columns;
    sOldTableInfo = sParseTree->tableInfo;
    sOldTableOID = smiGetTableId( sOldTableInfo->tableHandle );

    // PROJ-1502 PARTITIONED DISK TABLE
    if( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        sIsPartitioned = ID_TRUE;

        // 모든 파티션에 LOCK(X)
        IDE_TEST( qcmPartition::validateAndLockPartitionInfoList( aStatement,
                                                                  sParseTree->partTable->partInfoList,
                                                                  SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                                  SMI_TABLE_LOCK_X,
                                                                  ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                                    ID_ULONG_MAX :
                                                                    smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );

        // 예외 처리를 위하여, Lock을 잡은 후에 Partition List를 설정한다.
        sOldPartInfoList = sParseTree->partTable->partInfoList;

        if ( ( sOldTableInfo->replicationCount > 0 ) ||
             ( sDDLSupplementalLog == 1 ) )
        {
            IDE_TEST( qcmPartition::getAllPartitionOID( QC_QMX_MEM(aStatement),
                                                        sOldPartInfoList,
                                                        &sOldPartitionOID,
                                                        &sOldPartitionCount )
                      != IDE_SUCCESS );
        }
        else
        {
            /* do nothing */
        }
    }

    // PROJ-2642 Table on Replication Allow DDL
    if ( sOldTableInfo->replicationCount > 0 )
    {
        IDE_TEST( qci::mManageReplicationCallback.mIsDDLEnableOnReplicatedTable( 1,
                                                                                 sOldTableInfo )
                  != IDE_SUCCESS );

        IDE_TEST_RAISE( QC_SMI_STMT( aStatement )->getTrans()->getReplicationMode() == SMI_TRANSACTION_REPL_NONE,
                        ERR_CANNOT_WRITE_REPL_INFO );


        if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
        {
            sOldTableOIDArray = sOldPartitionOID;
            sTableOIDCount = sOldPartitionCount;
        }
        else
        {
            sOldTableOIDArray = &sOldTableOID;
            sTableOIDCount = 1;
        }

        IDE_TEST( qciMisc::checkRunningEagerReplicationByTableOID( aStatement,
                                                                   sOldTableOIDArray,
                                                                   sTableOIDCount )
                  != IDE_SUCCESS );

        IDE_TEST( qci::mManageReplicationCallback.mStopReceiverThreads( QC_SMI_STMT(aStatement),
                                                                        aStatement->mStatistics,
                                                                        sOldTableOIDArray,
                                                                        sTableOIDCount )
                  != IDE_SUCCESS );

        sIsReplicatedTable = ID_TRUE;
    }
    else
    {
        /* do nothing */
    }

    // set nullable flag to true.
    IDE_TEST(qdbCommon::updateColumnSpecNull(aStatement,
                                             sColumn,
                                             ID_TRUE) != IDE_SUCCESS);

    IDE_TEST( deleteNotNullConstraint( aStatement,
                                       sParseTree->tableInfo,
                                       sColumn->basicInfo->column.id )
              != IDE_SUCCESS );

    sTableID = sOldTableInfo->tableID;

    // fix BUG-14394
    IDE_TEST(qdbCommon::updateTableSpecFromMeta(
                 aStatement,
                 sParseTree->userName,
                 sParseTree->tableName,
                 sTableID,
                 sOldTableOID,
                 sParseTree->tableInfo->columnCount,
                 sParseTree->tableInfo->parallelDegree )
             != IDE_SUCCESS);

    IDE_TEST(qcm::makeAndSetQcmTableInfo(
                 QC_SMI_STMT( aStatement ),
                 sTableID,
                 sOldTableOID) != IDE_SUCCESS);

    IDE_TEST(qcm::getTableInfoByID(aStatement,
                                   sTableID,
                                   &sTempTableInfo,
                                   &sSCN,
                                   &sTableHandle) != IDE_SUCCESS);
    IDE_TEST( qcm::validateAndLockTable(aStatement,
                                        sTableHandle,
                                        sSCN,
                                        SMI_TABLE_LOCK_X)
              != IDE_SUCCESS );

    IDE_TEST(qdbCommon::makeColumnNullable(aStatement,
                                           sParseTree->tableInfo,
                                           sColumn->basicInfo->column.id)
             != IDE_SUCCESS);

    IDE_TEST(qcm::touchTable(QC_SMI_STMT( aStatement ),
                             sParseTree->tableInfo->tableID,
                             SMI_TBSLV_DDL_DML )
             != IDE_SUCCESS);

    (void)qcm::destroyQcmTableInfo(sTempTableInfo);
    sTempTableInfo = NULL;

    IDE_TEST(qcm::makeAndSetQcmTableInfo(
                 QC_SMI_STMT( aStatement ),
                 sTableID,
                 sOldTableOID) != IDE_SUCCESS);

    IDE_TEST(qcm::getTableInfoByID(aStatement,
                                   sTableID,
                                   &sNewTableInfo,
                                   &sSCN,
                                   &sTableHandle) != IDE_SUCCESS);

    // PROJ-1502 PARTITIONED DISK TABLE
    if( sIsPartitioned == ID_TRUE )
    {
        IDE_TEST( qcmPartition::touchPartitionInfoList( QC_SMI_STMT( aStatement ),
                                                        sOldPartInfoList )
                  != IDE_SUCCESS );

        IDE_TEST( qcmPartition::makeAndSetAndGetQcmPartitionInfoList( aStatement,
                                                                      sNewTableInfo,
                                                                      sOldPartInfoList,
                                                                      & sNewPartInfoList )
                  != IDE_SUCCESS );
    }

    // PROJ-2642 Table on Replication Allow DDL
    if ( ( sIsReplicatedTable == ID_TRUE ) ||
         ( sDDLSupplementalLog == 1 ) )
    {
        sNewTableOID = smiGetTableId( sNewTableInfo->tableHandle );

        if ( sIsPartitioned == ID_FALSE )
        {
            sOldTableOIDArray = &sOldTableOID;
            sNewTableOIDArray = &sNewTableOID;
            sTableOIDCount = 1;
        }
        else
        {
            sOldTableOIDArray = sOldPartitionOID;

            IDE_TEST( qcmPartition::getAllPartitionOID( QC_QMX_MEM(aStatement),
                                                        sNewPartInfoList,
                                                        &sNewTableOIDArray,
                                                        &sTableOIDCount )
                      != IDE_SUCCESS );
        }

        IDE_TEST( qciMisc::writeTableMetaLogForReplication( aStatement,
                                                            sOldTableOIDArray,
                                                            sNewTableOIDArray,
                                                            sTableOIDCount )
                  != IDE_SUCCESS );

    }
    else
    {
        /* do nothing */
    }

    if ( sIsPartitioned == ID_TRUE )
    {
        (void)qcmPartition::destroyQcmPartitionInfoList( sOldPartInfoList );
    }
    else
    {
        /* do nothing */
    }

    (void)qcm::destroyQcmTableInfo( sOldTableInfo );

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_CANNOT_WRITE_REPL_INFO )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_CANNOT_WRITE_REPL_INFO ) );
    }
    IDE_EXCEPTION_END;

    (void)qcm::destroyQcmTableInfo( sTempTableInfo );
    (void)qcmPartition::destroyQcmPartitionInfoList( sNewPartInfoList );

    // restore
    qcmPartition::restoreTempInfo( sOldTableInfo,
                                   sOldPartInfoList,
                                   NULL );

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::executeDropDefault(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... ALTER COLUMN (... DROP DEFAULT ...) 의 execution 수행
 *
 * Implementation :
 *    1. qcm::getTableInfo
 *    2. SYS_COLUMNS_ 메타 테이블 변경 => updateColumnSpecDefault
 *    3. related PSM 을 invalid 상태로 변경
 *    4. qcm::touchTable
 *    5. 메타 캐쉬 재구성
 *
 * Replication이 걸린 Table에 대한 DDL인 경우, 추가적으로 아래의 작업을 한다.
 *    1. Validate와 Execute는 다른 Transaction이므로, 프라퍼티 검사는 Execute에서 한다.
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::executeDropDefault"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY(""));

    qdTableParseTree     * sParseTree       = NULL;
    qcmTableInfo         * sOldTableInfo    = NULL;
    qcmColumn            * sColumn          = NULL;
    UInt                   sTableID         = 0;
    smOID                  sTableOID        = SM_OID_NULL;
    qcmPartitionInfoList * sOldPartInfoList = NULL;
    qcmPartitionInfoList * sNewPartInfoList = NULL;
    qcmTableInfo         * sNewTableInfo    = NULL;
    void                 * sNewTableHandle  = NULL;
    smSCN                  sNewSCN          = SM_SCN_INIT;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // TASK-2176
    // Table에 대한 Lock을 획득한다.
    IDE_TEST( qcm::validateAndLockTable(aStatement,
                                        sParseTree->tableHandle,
                                        sParseTree->tableSCN,
                                        SMI_TABLE_LOCK_X)
              != IDE_SUCCESS);

    sParseTree->columns->defaultValueStr = NULL;
    sOldTableInfo = sParseTree->tableInfo;
    sColumn = sParseTree->columns;

    // PROJ-1502 PARTITIONED DISK TABLE
    if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST( qcmPartition::validateAndLockPartitionInfoList( aStatement,
                                                                  sParseTree->partTable->partInfoList,
                                                                  SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                                  SMI_TABLE_LOCK_X,
                                                                  ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                                    ID_ULONG_MAX :
                                                                    smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );

        // 예외 처리를 위하여, Lock을 잡은 후에 Partition List를 설정한다.
        sOldPartInfoList = sParseTree->partTable->partInfoList;
    }
    else
    {
        /* Nothing to do */
    }

    /* PROJ-1442 Replication Online 중 DDL 허용
     * Validate와 Execute는 다른 Transaction이므로, 프라퍼티 검사는 Execute에서 한다.
     */
    if(sOldTableInfo->replicationCount > 0)
    {
        IDE_TEST( qci::mManageReplicationCallback.mIsDDLEnableOnReplicatedTable( 0, 
                                                                                 sOldTableInfo )
                  != IDE_SUCCESS );
    }

    while (sColumn != NULL)
    {
        sColumn->defaultValueStr = NULL;
        sColumn = sColumn->next;
    }

    IDE_TEST(updateColumnSpecDefault(aStatement,
                                     sParseTree->columns)
             != IDE_SUCCESS);

    sTableID = sParseTree->tableInfo->tableID;
    sTableOID = smiGetTableId(sParseTree->tableInfo->tableHandle);

    // fix BUG-14394
    IDE_TEST(qdbCommon::updateTableSpecFromMeta(
                 aStatement,
                 sParseTree->userName,
                 sParseTree->tableName,
                 sTableID,
                 sTableOID,
                 sParseTree->tableInfo->columnCount,
                 sParseTree->tableInfo->parallelDegree )
             != IDE_SUCCESS);

    IDE_TEST(qcm::touchTable(QC_SMI_STMT( aStatement ),
                             sTableID,
                             SMI_TBSLV_DDL_DML )
             != IDE_SUCCESS);

    IDE_TEST(qcm::makeAndSetQcmTableInfo(
                 QC_SMI_STMT( aStatement ),
                 sTableID,
                 sTableOID) != IDE_SUCCESS);

    IDE_TEST( qcm::getTableInfoByID( aStatement,
                                     sTableID,
                                     & sNewTableInfo,
                                     & sNewSCN,
                                     & sNewTableHandle )
              != IDE_SUCCESS );

    if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST( qcmPartition::touchPartitionInfoList( QC_SMI_STMT( aStatement ),
                                                        sOldPartInfoList )
                  != IDE_SUCCESS );

        IDE_TEST( qcmPartition::makeAndSetAndGetQcmPartitionInfoList( aStatement,
                                                                      sNewTableInfo,
                                                                      sOldPartInfoList,
                                                                      & sNewPartInfoList )
                  != IDE_SUCCESS );

        (void)qcmPartition::destroyQcmPartitionInfoList( sOldPartInfoList );
    }
    else
    {
        /* Nothing to do */
    }

    (void)qcm::destroyQcmTableInfo(sOldTableInfo);

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    (void)qcm::destroyQcmTableInfo( sNewTableInfo );
    (void)qcmPartition::destroyQcmPartitionInfoList( sNewPartInfoList );

    // on failure, restore tempinfo.
    qcmPartition::restoreTempInfo( sOldTableInfo,
                                   sOldPartInfoList,
                                   NULL );

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::executeCompactTable( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... COMPACT 의 execution 수행
 *
 ***********************************************************************/

    qdTableParseTree     * sParseTree    = NULL;
    UInt                   sTableID      = 0;
    smOID                  sTableOID     = 0;
    qcmPartitionInfoList * sPartInfoList = NULL;
    UInt                   sPartID       = 0;
    smOID                  sPartOID      = 0;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    if ( sParseTree->partTable->partAttr == NULL )
    {
        /* Table에 대한 Lock을 획득한다. */
        IDE_TEST( qcm::validateAndLockTable( aStatement,
                                             sParseTree->tableHandle,
                                             sParseTree->tableSCN,
                                             SMI_TABLE_LOCK_X )
                  != IDE_SUCCESS );

        /* 1. 모든 파티션에 LOCK(X) */
        IDE_TEST( qcmPartition::validateAndLockPartitionInfoList( aStatement,
                                                                  sParseTree->partTable->partInfoList,
                                                                  SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                                  SMI_TABLE_LOCK_X,
                                                                  ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                                    ID_ULONG_MAX :
                                                                    smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );
    }
    else
    {
        // 파티션을 지정한 경우에는 IX Lock만 잡는 게 동시성에 좋다.
        IDE_TEST( qcmPartition::validateAndLockTableAndPartitions( aStatement,
                                                                   sParseTree->tableHandle,
                                                                   sParseTree->tableSCN,
                                                                   sParseTree->partTable->partInfoList,
                                                                   SMI_TABLE_LOCK_IX,
                                                                   ID_FALSE ) //aIsSetViewSCN
                  != IDE_SUCCESS );
    }

    /* PROJ-2464 hybrid partitioned table 지원
     *  - HPT 인 경우에, Memory, Disk 매체를 모두 지닐 수 있다.
     *  - 따라서 Memory 매체만 해당 옵션을 사용해야 한다.
     *     1. 모든 파티션에 LOCK(X)
     *     2. Memory Partition의 Compact
     *     3. Memory Table의 Compact
     *     4. 모든 파티션의 Last DDL Time를 수정한다
     */
    if ( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        /* 2. Memory Parttion의 Compact */
        for ( sPartInfoList  = sParseTree->partTable->partInfoList;
              sPartInfoList != NULL;
              sPartInfoList  = sPartInfoList->next )
        {
            if ( ( sPartInfoList->partitionInfo->tableFlag & SMI_TABLE_TYPE_MASK ) != SMI_TABLE_DISK )
            {
                IDE_TEST( smiTable::compactTable( QC_SMI_STMT( aStatement ),
                                                  sPartInfoList->partHandle,
                                                  sParseTree->maxrows )
                          != IDE_SUCCESS );
            }
            else
            {
                /* Nothing to do */
            }
        }
    }
    else
    {
        /* 3. Memory Table의 Compact */
        IDE_TEST( smiTable::compactTable( QC_SMI_STMT( aStatement ),
                                          sParseTree->tableInfo->tableHandle,
                                          sParseTree->maxrows )
                  != IDE_SUCCESS );
    }

    sTableID  = sParseTree->tableInfo->tableID;
    sTableOID = smiGetTableId( sParseTree->tableInfo->tableHandle );

    /* fix BUG-14394 */
    IDE_TEST( qdbCommon::updateTableSpecFromMeta( aStatement,
                                                  sParseTree->userName,
                                                  sParseTree->tableName,
                                                  sTableID,
                                                  sTableOID,
                                                  sParseTree->tableInfo->columnCount,
                                                  sParseTree->tableInfo->parallelDegree )
              != IDE_SUCCESS );

    /* 4. 모든 파티션의 Last DDL Time를 수정한다. */
    if ( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        for ( sPartInfoList  = sParseTree->partTable->partInfoList;
              sPartInfoList != NULL;
              sPartInfoList  = sPartInfoList->next )
        {
            sPartID  = sPartInfoList->partitionInfo->partitionID;
            sPartOID = smiGetTableId( sPartInfoList->partHandle );

            IDE_TEST( qdbCommon::updatePartTableSpecFromMeta( aStatement,
                                                              sParseTree->tableInfo->tableID,
                                                              sPartID,
                                                              sPartOID )
                      != IDE_SUCCESS );
        }
    }
    else
    {
        /* Nothing to do */
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::executeAgingTable( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... AGING 의 execution 수행
 *
 ***********************************************************************/

    qdTableParseTree     * sParseTree    = NULL;
    UInt                   sTableID      = 0;
    smOID                  sTableOID     = 0;
    qcmPartitionInfoList * sPartInfoList = NULL;
    UInt                   sPartID       = 0;
    smOID                  sPartOID      = 0;
    qdIndexTableList     * sIndexTable   = NULL;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    if ( sParseTree->partTable->partAttr == NULL )
    {
        /* Table에 대한 Lock을 획득한다. */
        IDE_TEST( qcm::validateAndLockTable( aStatement,
                                             sParseTree->tableHandle,
                                             sParseTree->tableSCN,
                                             SMI_TABLE_LOCK_X )
                  != IDE_SUCCESS );

        /* 1. 모든 파티션에 LOCK(X) */
        IDE_TEST( qcmPartition::validateAndLockPartitionInfoList( aStatement,
                                                                  sParseTree->partTable->partInfoList,
                                                                  SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                                  SMI_TABLE_LOCK_X,
                                                                  ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                                    ID_ULONG_MAX :
                                                                    smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );
    }
    else
    {
        // 파티션을 지정한 경우에는 IX Lock만 잡는 게 동시성에 좋다.
        IDE_TEST( qcmPartition::validateAndLockTableAndPartitions( aStatement,
                                                                   sParseTree->tableHandle,
                                                                   sParseTree->tableSCN,
                                                                   sParseTree->partTable->partInfoList,
                                                                   SMI_TABLE_LOCK_IX,
                                                                   ID_FALSE ) //aIsSetViewSCN
                  != IDE_SUCCESS );
    }

    if ( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDU_FIT_POINT( "qdbAlter::executeAgingTable::beforeLockIndexTable" );

        /* PROJ-1624 non-partitioned index */
        IDE_TEST( qdx::validateAndLockIndexTableList( aStatement,
                                                      sParseTree->oldIndexTables,
                                                      SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                      SMI_TABLE_LOCK_X,
                                                      ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                        ID_ULONG_MAX :
                                                        smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );

        for ( sPartInfoList  = sParseTree->partTable->partInfoList;
              sPartInfoList != NULL;
              sPartInfoList  = sPartInfoList->next )
        {
            /* PROJ-2464 hybrid partitioned table 지원
             *  - Disk Partition의 Aging
             */
            if ( ( sPartInfoList->partitionInfo->tableFlag & SMI_TABLE_TYPE_MASK ) == SMI_TABLE_DISK )
            {
                IDE_TEST( smiTable::agingTable( QC_SMI_STMT( aStatement ),
                                                sPartInfoList->partHandle )
                          != IDE_SUCCESS );
            }
            else
            {
                /* Nothing to do */
            }
        }

        /* PROJ-1624 non-partitioned index */
        for ( sIndexTable = sParseTree->oldIndexTables;
              sIndexTable != NULL;
              sIndexTable = sIndexTable->next )
        {
            IDE_TEST(smiTable::agingTable( QC_SMI_STMT( aStatement ),
                                           sIndexTable->tableHandle )
                     != IDE_SUCCESS);
        }
    }
    else
    {
        IDE_TEST(smiTable::agingTable( QC_SMI_STMT( aStatement ),
                                       sParseTree->tableHandle )
                 != IDE_SUCCESS);
    }

    sTableID  = sParseTree->tableInfo->tableID;
    sTableOID = smiGetTableId( sParseTree->tableInfo->tableHandle );

    /* fix BUG-14394 */
    IDE_TEST( qdbCommon::updateTableSpecFromMeta( aStatement,
                                                  sParseTree->userName,
                                                  sParseTree->tableName,
                                                  sTableID,
                                                  sTableOID,
                                                  sParseTree->tableInfo->columnCount,
                                                  sParseTree->tableInfo->parallelDegree )
              != IDE_SUCCESS );

    /* 모든 파티션의 Last DDL Time를 수정한다. */
    if ( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        for ( sPartInfoList  = sParseTree->partTable->partInfoList;
              sPartInfoList != NULL;
              sPartInfoList  = sPartInfoList->next )
        {
            sPartID  = sPartInfoList->partitionInfo->partitionID;
            sPartOID = smiGetTableId( sPartInfoList->partHandle );

            IDE_TEST( qdbCommon::updatePartTableSpecFromMeta( aStatement,
                                                              sParseTree->tableInfo->tableID,
                                                              sPartID,
                                                              sPartOID )
                      != IDE_SUCCESS );
        }
    }
    else
    {
        /* Nothing to do */
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::executeAllIndexEnable(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... ALL INDEX ENABLE 의 execution 수행
 *
 * Implementation :
 *    1. smiTable::enableAllIndex 호출
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::executeAllIndexEnable"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY(""));

    qdTableParseTree     * sParseTree       = NULL;
    qcmTableInfo         * sOldTableInfo    = NULL;
    UInt                   sTableID         = 0;
    smOID                  sTableOID        = SM_OID_NULL;

    qcmPartitionInfoList * sOldPartInfoList = NULL;
    qcmPartitionInfoList * sNewPartInfoList = NULL;
    qcmPartitionInfoList * sPartInfoList    = NULL;
    qcmTableInfo         * sNewTableInfo    = NULL;
    void                 * sNewTableHandle  = NULL;
    smSCN                  sNewSCN          = SM_SCN_INIT;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // TASK-2176
    // Table에 대한 Lock을 획득한다.
    IDE_TEST( qcm::validateAndLockTable(aStatement,
                                        sParseTree->tableHandle,
                                        sParseTree->tableSCN,
                                        SMI_TABLE_LOCK_X)
              != IDE_SUCCESS);

    sOldTableInfo = sParseTree->tableInfo;

    // PROJ-1502 PARTITIONED DISK TABLE
    if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        // 모든 파티션에 LOCK(X)
        IDE_TEST( qcmPartition::validateAndLockPartitionInfoList( aStatement,
                                                                  sParseTree->partTable->partInfoList,
                                                                  SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                                  SMI_TABLE_LOCK_X,
                                                                  ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                                    ID_ULONG_MAX :
                                                                    smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );

        // 예외 처리를 위하여, Lock을 잡은 후에 Partition List를 설정한다.
        sOldPartInfoList = sParseTree->partTable->partInfoList;
    }
    else
    {
        /* Nothing to do */
    }

    IDE_TEST( smiTable::enableAllIndex( QC_SMI_STMT( aStatement ),
                                        sOldTableInfo->tableHandle )
              != IDE_SUCCESS );

    if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        for ( sPartInfoList = sOldPartInfoList;
              sPartInfoList != NULL;
              sPartInfoList = sPartInfoList->next )
        {
            IDE_TEST( smiTable::enableAllIndex( QC_SMI_STMT( aStatement ),
                                                sPartInfoList->partHandle )
                      != IDE_SUCCESS );
        }
    }
    else
    {
        /* Nothing to do */
    }

    sTableID = sOldTableInfo->tableID;
    sTableOID = smiGetTableId( sOldTableInfo->tableHandle );

    // fix BUG-14394
    IDE_TEST(qdbCommon::updateTableSpecFromMeta(
                 aStatement,
                 sParseTree->userName,
                 sParseTree->tableName,
                 sTableID,
                 sTableOID,
                 sOldTableInfo->columnCount,
                 sOldTableInfo->parallelDegree )
             != IDE_SUCCESS);

    IDE_TEST( qcm::touchTable( QC_SMI_STMT( aStatement ),
                               sTableID,
                               SMI_TBSLV_DDL_DML )
              != IDE_SUCCESS );

    IDE_TEST(qcm::makeAndSetQcmTableInfo(
                 QC_SMI_STMT( aStatement ),
                 sTableID,
                 sTableOID) != IDE_SUCCESS);

    IDE_TEST( qcm::getTableInfoByID( aStatement,
                                     sTableID,
                                     & sNewTableInfo,
                                     & sNewSCN,
                                     & sNewTableHandle )
              != IDE_SUCCESS );

    if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST( qcmPartition::touchPartitionInfoList( QC_SMI_STMT( aStatement ),
                                                        sOldPartInfoList )
                  != IDE_SUCCESS );

        IDE_TEST( qcmPartition::makeAndSetAndGetQcmPartitionInfoList( aStatement,
                                                                      sNewTableInfo,
                                                                      sOldPartInfoList,
                                                                      & sNewPartInfoList )
                  != IDE_SUCCESS );

        (void)qcmPartition::destroyQcmPartitionInfoList( sOldPartInfoList );
    }
    else
    {
        /* Nothing to do */
    }

    (void)qcm::destroyQcmTableInfo(sOldTableInfo);
    
    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    (void)qcm::destroyQcmTableInfo( sNewTableInfo );
    (void)qcmPartition::destroyQcmPartitionInfoList( sNewPartInfoList );

    // on failure, restore tempinfo.
    qcmPartition::restoreTempInfo( sOldTableInfo,
                                   sOldPartInfoList,
                                   NULL );

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::executeAllIndexDisable(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... ALL INDEX DISABLE 의 execution 수행
 *
 * Implementation :
 *    1. smiTable::disableAllIndex 호출
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::executeAllIndexDisable"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY(""));

    qdTableParseTree     * sParseTree       = NULL;
    qcmTableInfo         * sOldTableInfo    = NULL;
    UInt                   sTableID         = 0;
    smOID                  sTableOID        = SM_OID_NULL;

    qcmPartitionInfoList * sOldPartInfoList = NULL;
    qcmPartitionInfoList * sNewPartInfoList = NULL;
    qcmPartitionInfoList * sPartInfoList    = NULL;
    qcmTableInfo         * sNewTableInfo    = NULL;
    void                 * sNewTableHandle  = NULL;
    smSCN                  sNewSCN          = SM_SCN_INIT;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // TASK-2176
    // Table에 대한 Lock을 획득한다.
    IDE_TEST( qcm::validateAndLockTable(aStatement,
                                        sParseTree->tableHandle,
                                        sParseTree->tableSCN,
                                        SMI_TABLE_LOCK_X)
              != IDE_SUCCESS);

    sOldTableInfo = sParseTree->tableInfo;
    
    // PROJ-1502 PARTITIONED DISK TABLE
    if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        // 모든 파티션에 LOCK(X)
        IDE_TEST( qcmPartition::validateAndLockPartitionInfoList( aStatement,
                                                                  sParseTree->partTable->partInfoList,
                                                                  SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                                  SMI_TABLE_LOCK_X,
                                                                  ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                                    ID_ULONG_MAX :
                                                                    smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );

        // 예외 처리를 위하여, Lock을 잡은 후에 Partition List를 설정한다.
        sOldPartInfoList = sParseTree->partTable->partInfoList;
    }
    else
    {
        /* Nothing to do */
    }

    IDE_TEST( smiTable::disableAllIndex( QC_SMI_STMT( aStatement ),
                                         sOldTableInfo->tableHandle )
              != IDE_SUCCESS );

    if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        for ( sPartInfoList = sOldPartInfoList;
              sPartInfoList != NULL;
              sPartInfoList = sPartInfoList->next )
        {
            IDE_TEST( smiTable::disableAllIndex( QC_SMI_STMT( aStatement ),
                                                 sPartInfoList->partHandle )
                      != IDE_SUCCESS );
        }
    }
    else
    {
        /* Nothing to do */
    }

    sTableID = sOldTableInfo->tableID;
    sTableOID = smiGetTableId( sOldTableInfo->tableHandle );

    // fix BUG-14394
    IDE_TEST(qdbCommon::updateTableSpecFromMeta(
                 aStatement,
                 sParseTree->userName,
                 sParseTree->tableName,
                 sTableID,
                 sTableOID,
                 sOldTableInfo->columnCount,
                 sOldTableInfo->parallelDegree )
             != IDE_SUCCESS);

    IDE_TEST( qcm::touchTable( QC_SMI_STMT( aStatement ),
                               sTableID,
                               SMI_TBSLV_DDL_DML )
              != IDE_SUCCESS );

    IDE_TEST(qcm::makeAndSetQcmTableInfo(
                 QC_SMI_STMT( aStatement ),
                 sTableID,
                 sTableOID) != IDE_SUCCESS);

    IDE_TEST( qcm::getTableInfoByID( aStatement,
                                     sTableID,
                                     & sNewTableInfo,
                                     & sNewSCN,
                                     & sNewTableHandle )
              != IDE_SUCCESS );

    if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST( qcmPartition::touchPartitionInfoList( QC_SMI_STMT( aStatement ),
                                                        sOldPartInfoList )
                  != IDE_SUCCESS );

        IDE_TEST( qcmPartition::makeAndSetAndGetQcmPartitionInfoList( aStatement,
                                                                      sNewTableInfo,
                                                                      sOldPartInfoList,
                                                                      & sNewPartInfoList )
                  != IDE_SUCCESS );

        (void)qcmPartition::destroyQcmPartitionInfoList( sOldPartInfoList );
    }
    else
    {
        /* Nothing to do */
    }

    (void)qcm::destroyQcmTableInfo(sOldTableInfo);
    
    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    (void)qcm::destroyQcmTableInfo( sNewTableInfo );
    (void)qcmPartition::destroyQcmPartitionInfoList( sNewPartInfoList );

    // on failure, restore tempinfo.
    qcmPartition::restoreTempInfo( sOldTableInfo,
                                   sOldPartInfoList,
                                   NULL );

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::deletePartIndexFromMeta(
    qcStatement *aStatement,
    UInt         aIndexID)
{
/***********************************************************************
 *
 * Description :
 *      executeDropCol 로부터 호출, 메타 테이블로부터 인덱스 정보 삭제
 *
 * Implementation :
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::deletePartIndexFromMeta"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY(""));

    SChar               * sSqlStr;
    vSLong sRowCnt;

    IDU_LIMITPOINT("qdbAlter::deletePartIndexFromMeta::malloc");
    IDE_TEST(STRUCT_ALLOC_WITH_SIZE(aStatement->qmxMem,
                                    SChar,
                                    QD_MAX_SQL_LENGTH,
                                    &sSqlStr)
             != IDE_SUCCESS);

    idlOS::snprintf( sSqlStr, QD_MAX_SQL_LENGTH,
                     "DELETE FROM SYS_PART_INDICES_ "
                     "WHERE INDEX_ID = INTEGER'%"ID_INT32_FMT"'",
                     aIndexID);

    IDE_TEST(qcg::runDMLforDDL( QC_SMI_STMT( aStatement ),
                                sSqlStr,
                                & sRowCnt ) != IDE_SUCCESS);

    idlOS::snprintf( sSqlStr, QD_MAX_SQL_LENGTH,
                     "DELETE FROM SYS_INDEX_PARTITIONS_ "
                     "WHERE INDEX_ID = INTEGER'%"ID_INT32_FMT"'",
                     aIndexID);

    IDE_TEST(qcg::runDMLforDDL( QC_SMI_STMT( aStatement ),
                                sSqlStr,
                                & sRowCnt ) != IDE_SUCCESS);

    // To fix BUG-24282
    // 파티션드 테이블의 DROP COLUMN시 다른 파티션드 테이블의
    // 메타정보가 삭제되는 경우가 있습니다.
    idlOS::snprintf( sSqlStr, QD_MAX_SQL_LENGTH,
                     "DELETE FROM SYS_PART_KEY_COLUMNS_ "
                     "WHERE PARTITION_OBJ_ID = INTEGER'%"ID_INT32_FMT"'"
                     "AND OBJECT_TYPE = INTEGER'%"ID_INT32_FMT"'",
                     aIndexID,
                     QCM_INDEX_OBJECT_TYPE );

    IDE_TEST(qcg::runDMLforDDL( QC_SMI_STMT( aStatement ),
                                sSqlStr,
                                & sRowCnt ) != IDE_SUCCESS);

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::deleteIndexSpecFromMeta(
    qcStatement *aStatement,
    UInt         aTableID)
{
/***********************************************************************
 *
 * Description :
 *      executeAddCol 로부터 호출, 메타 테이블로부터 인덱스 정보 삭제
 *
 * Implementation :
 *      1. SYS_INDICES_, SYS_INDEX_COLUMNS_ 메타 테이블에서 정보 삭제
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::deleteIndexSpecFromMeta"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY(""));

    SChar               * sSqlStr;
    vSLong sRowCnt;

    IDU_LIMITPOINT("qdbAlter::deleteIndexSpecFromMeta::malloc");
    IDE_TEST(STRUCT_ALLOC_WITH_SIZE(aStatement->qmxMem,
                                    SChar,
                                    QD_MAX_SQL_LENGTH,
                                    &sSqlStr)
             != IDE_SUCCESS);

    idlOS::snprintf( sSqlStr, QD_MAX_SQL_LENGTH,
                     "DELETE FROM SYS_INDICES_ "
                     "WHERE TABLE_ID = INTEGER'%"ID_INT32_FMT"'",
                     aTableID);

    IDE_TEST(qcg::runDMLforDDL( QC_SMI_STMT( aStatement ),
                                sSqlStr,
                                & sRowCnt ) != IDE_SUCCESS);

    idlOS::snprintf( sSqlStr, QD_MAX_SQL_LENGTH,
                     "DELETE FROM SYS_INDEX_COLUMNS_ "
                     "WHERE TABLE_ID = INTEGER'%"ID_INT32_FMT"'",
                     aTableID);

    IDE_TEST(qcg::runDMLforDDL( QC_SMI_STMT( aStatement ),
                                sSqlStr,
                                & sRowCnt ) != IDE_SUCCESS);

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::deleteColumnSpecFromMeta(
    qcStatement    * aStatement,
    UInt             aTableID)
{
/***********************************************************************
 *
 * Description :
 *      executeAddCol 로부터 호출, 메타 테이블로부터 컬럼 정보 삭제
 *
 * Implementation :
 *      1. SYS_COLUMNS_ 메타 테이블에서 정보 삭제
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::deleteColumnSpecFromMeta"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY(""));

    SChar               * sSqlStr;
    vSLong sRowCnt;

    IDU_LIMITPOINT("qdbAlter::deleteColumnSpecFromMeta::malloc");
    IDE_TEST(STRUCT_ALLOC_WITH_SIZE(aStatement->qmxMem,
                                    SChar,
                                    QD_MAX_SQL_LENGTH,
                                    &sSqlStr)
             != IDE_SUCCESS);

    idlOS::snprintf( sSqlStr, QD_MAX_SQL_LENGTH,
                     "DELETE FROM SYS_COLUMNS_ "
                     "WHERE TABLE_ID = INTEGER'%"ID_INT32_FMT"'",
                     aTableID);

    IDE_TEST(qcg::runDMLforDDL( QC_SMI_STMT( aStatement ),
                                sSqlStr,
                                & sRowCnt ) != IDE_SUCCESS);

    // PROJ-1362
    idlOS::snprintf( sSqlStr, QD_MAX_SQL_LENGTH,
                     "DELETE FROM SYS_LOBS_ "
                     "WHERE TABLE_ID = INTEGER'%"ID_INT32_FMT"'",
                     aTableID);

    IDE_TEST(qcg::runDMLforDDL(QC_SMI_STMT(aStatement),
                               sSqlStr,
                               & sRowCnt ) != IDE_SUCCESS);

    // PROJ-2002 Column Security
    idlOS::snprintf( sSqlStr, QD_MAX_SQL_LENGTH,
                     "DELETE FROM SYS_ENCRYPTED_COLUMNS_ "
                     "WHERE TABLE_ID = INTEGER'%"ID_INT32_FMT"'",
                     aTableID);

    IDE_TEST(qcg::runDMLforDDL(QC_SMI_STMT(aStatement),
                               sSqlStr,
                               & sRowCnt ) != IDE_SUCCESS);

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::deletePartKeyColumnSpecFromMeta(
    qcStatement    * aStatement,
    UInt             aPartObjectID,
    UInt             aPartObjectType)
{
/***********************************************************************
 *
 * Description :
 *      executeAddCol 로부터 호출, 메타 테이블로부터 컬럼 정보 삭제
 *
 * Implementation :
 *      1. SYS_COLUMNS_ 메타 테이블에서 정보 삭제
 *
 ***********************************************************************/

    SChar               * sSqlStr;
    vSLong sRowCnt;

    IDU_LIMITPOINT("qdbAlter::deletePartKeyColumnSpecFromMeta::malloc");
    IDE_TEST(STRUCT_ALLOC_WITH_SIZE(aStatement->qmxMem,
                                    SChar,
                                    QD_MAX_SQL_LENGTH,
                                    &sSqlStr)
             != IDE_SUCCESS);

    idlOS::snprintf( sSqlStr, QD_MAX_SQL_LENGTH,
                     "DELETE FROM SYS_PART_KEY_COLUMNS_ "
                     "WHERE PARTITION_OBJ_ID = INTEGER'%"ID_INT32_FMT"'"
                     "AND OBJECT_TYPE = INTEGER'%"ID_INT32_FMT"'",
                     aPartObjectID,
                     aPartObjectType );

    IDE_TEST(qcg::runDMLforDDL( QC_SMI_STMT( aStatement ),
                                sSqlStr,
                                & sRowCnt ) != IDE_SUCCESS);

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::deletePartLobSpecFromMeta(
    qcStatement    * aStatement,
    UInt             aTableID)
{
/***********************************************************************
 *
 * Description :
 *      executeAddCol, executeDropCol 로부터 호출,
 *      메타 테이블로부터 컬럼 정보 삭제
 *
 * Implementation :
 *      1. SYS_PART_LOBS_ 메타 테이블에서 정보 삭제
 *
 ***********************************************************************/

    SChar               * sSqlStr;
    vSLong sRowCnt;

    IDU_LIMITPOINT("qdbAlter::deletePartLobSpecFromMeta::malloc");
    IDE_TEST(STRUCT_ALLOC_WITH_SIZE(aStatement->qmxMem,
                                    SChar,
                                    QD_MAX_SQL_LENGTH,
                                    &sSqlStr)
             != IDE_SUCCESS);

    // PROJ-1502 PARTITIONED DISK TABLE
    idlOS::snprintf( sSqlStr, QD_MAX_SQL_LENGTH,
                     "DELETE FROM SYS_PART_LOBS_ "
                     "WHERE TABLE_ID = INTEGER'%"ID_INT32_FMT"'",
                     aTableID);

    IDE_TEST(qcg::runDMLforDDL(QC_SMI_STMT(aStatement),
                               sSqlStr,
                               & sRowCnt ) != IDE_SUCCESS);

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::hasNullValue(qcStatement  *aStatement,
                              qcmTableInfo *aTableInfo,
                              qcmColumn    *aColumn,
                              idBool       *aHasNull)
{
/***********************************************************************
 *
 * Description :
 *    aColumn 에 널 값이 존재하는지 여부를 모든 레코드에 대해서 검사함
 *
 *    qdbAlter::executeNotNull()에서 호출됨.
 *
 * Implementation :
 *    1. Cursor의 초기화
 *    2. Cursor의 Open
 *    3. 한 레코드씩 읽으면서 널 값 검사
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::hasNullValue"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY(""));

    scGRID                 sRid; // Disk Table을 위한 Record IDentifier
    smiCursorProperties    sCursorProperty;
    smiTableCursor         sCursor;
    const void           * sRow = NULL;     // TASK-3876 Code Sonar
    const void           * sRowBuf = NULL;  // TASK-3876 Code Sonar
    void                 * sValueTemp;
    SInt                   sStage = 0;
    UInt                   sTableType;
    UInt                   sRowSize;
    qcmPartitionInfoList * sPartInfoList = NULL;
    qcmTableInfo         * sPartInfo;
    qdTableParseTree     * sParseTree;
    smiFetchColumnList   * sFetchColumnList = NULL;
    UChar                * sVarRowBuffer = NULL;
    UInt                   sVarRowSize;

    UInt                   sPartType     = 0 ;
    qcmTableInfo         * sDiskInfo     = NULL;
    qcmColumn            * sDiskColumn   = NULL;
    qcmTableInfo         * sMemoryInfo   = NULL;
    qcmColumn            * sMemoryColumn = NULL;
    qcmColumn            * sColumn       = NULL;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    sTableType = aTableInfo->tableFlag & SMI_TABLE_TYPE_MASK;

    /* PROJ-2464 hybrid partitioned table 지원
     *  - Partitioned의 Alter 구문인 경우, sPartInfoList에 적절한 Tablespace 정보가 있다.
     */
    if ( aTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        for ( sPartInfoList = sParseTree->partTable->partInfoList;
              sPartInfoList != NULL;
              sPartInfoList = sPartInfoList->next )
        {
            sPartInfo = sPartInfoList->partitionInfo;

            if ( ( sPartInfo->tableFlag & SMI_TABLE_TYPE_MASK ) == SMI_TABLE_DISK )
            {
                sDiskInfo = sPartInfo;
                sDiskColumn = qdbCommon::findColumnInColumnList( sPartInfo->columns,
                                                                 aColumn->basicInfo->column.id );

                IDE_TEST_RAISE( sDiskColumn == NULL, ERR_COLUMN_NOT_FOUND );
            }
            else
            {
                sMemoryInfo = sPartInfo;
                sMemoryColumn = qdbCommon::findColumnInColumnList( sPartInfo->columns,
                                                                   aColumn->basicInfo->column.id );

                IDE_TEST_RAISE( sMemoryColumn == NULL, ERR_COLUMN_NOT_FOUND );
            }
        }
    }
    else
    {
        if ( sTableType == SMI_TABLE_DISK )
        {
            sDiskInfo = aTableInfo;
            sDiskColumn = aColumn;
        }
        else
        {
            sMemoryInfo = aTableInfo;
            sMemoryColumn = aColumn;
        }
    }

    if ( sDiskInfo != NULL )
    {
        // Disk Table인 경우

        // Record Read를 위한 공간을 할당한다.
        IDE_TEST( qdbCommon::getDiskRowSize( sDiskInfo,
                                             & sRowSize )
                  != IDE_SUCCESS );

        // To fix BUG-14820
        // Disk-variable 컬럼의 rid비교를 위해 초기화 해야 함.
        IDU_LIMITPOINT("qdbAlter::hasNullValue::malloc1");
        IDE_TEST( aStatement->qmxMem->cralloc( sRowSize,
                                               (void **) & sRow )
                  != IDE_SUCCESS );

        // PROJ-1705
        // sm에서 레코드를 읽기위한 fetch column list 구성.
        IDE_TEST( qdbCommon::makeFetchColumnList(
                      QC_PRIVATE_TMPLATE(aStatement),
                      1,
                      sDiskColumn,
                      ID_TRUE,  // alloc smiColumnList
                      & sFetchColumnList ) != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    if ( sMemoryInfo != NULL )
    {
        // Memory Table인 경우 (Volatile Table도 Memory Table과 동일)
        // To fix BUG-24356
        // geometry에 대해서만 value buffer할당
        if ( ( (sMemoryColumn->basicInfo->column.flag & SMI_COLUMN_TYPE_MASK)
                == SMI_COLUMN_TYPE_VARIABLE_LARGE ) &&
             (sMemoryColumn->basicInfo->module->id == MTD_GEOMETRY_ID) )
        {
            sVarRowSize = smiGetVariableColumnSize( SMI_TABLE_MEMORY ) +
                sMemoryColumn->basicInfo->column.size;
            sVarRowSize = idlOS::align( sVarRowSize, 8 );

            IDE_DASSERT( sVarRowSize > 0 );

            IDU_LIMITPOINT("qdbAlter::hasNullValue::malloc2");
            IDE_TEST( aStatement->qmxMem->cralloc( sVarRowSize,
                                                   (void**) & sVarRowBuffer )
                      != IDE_SUCCESS );

            IDE_TEST( qcm::copyQcmColumns( aStatement->qmxMem,
                                           sMemoryColumn,
                                           & sColumn,
                                           1 )
                      != IDE_SUCCESS );

            sColumn->basicInfo->column.value = (void*) sVarRowBuffer;

            sMemoryColumn = sColumn;
        }
        else
        {
            // Nothing to do.
        }
    }
    else
    {
        /* Nothing to do */
    }

    sRowBuf = sRow;
    *aHasNull = ID_FALSE;

    // PROJ-1502 PARTITIONED DISK TABLE
    if( aTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        // 파스트리에서 파티션 정보 리스트를 가져온다.
        sPartInfoList = sParseTree->partTable->partInfoList;

        for( ;
             sPartInfoList != NULL;
             sPartInfoList = sPartInfoList->next )
        {
            sRow = sRowBuf;
            sPartInfo = sPartInfoList->partitionInfo;

            sPartType = sPartInfo->tableFlag & SMI_TABLE_TYPE_MASK;

            // 검색을 위한 자료 구조의 초기화
            SMI_CURSOR_PROP_INIT_FOR_FULL_SCAN( &sCursorProperty, aStatement->mStatistics );

            if ( sPartType == SMI_TABLE_DISK )
            {
                sCursorProperty.mFetchColumnList = sFetchColumnList;
                sColumn = sDiskColumn;
            }
            else
            {
                sColumn = sMemoryColumn;
            }

            sCursor.initialize();

            IDE_TEST(sCursor.open(
                         QC_SMI_STMT( aStatement ),
                         sPartInfo->tableHandle,
                         NULL,
                         smiGetRowSCN(sPartInfo->tableHandle),
                         NULL,
                         smiGetDefaultKeyRange(),
                         smiGetDefaultKeyRange(),
                         smiGetDefaultFilter(),
                         QCM_META_CURSOR_FLAG,
                         SMI_SELECT_CURSOR,
                         & sCursorProperty) != IDE_SUCCESS);
            sStage = 1;

            IDE_TEST(sCursor.beforeFirst() != IDE_SUCCESS);
            IDE_TEST(sCursor.readRow(&sRow, &sRid, SMI_FIND_NEXT) != IDE_SUCCESS);

            while ((sRow != NULL) && (*aHasNull != ID_TRUE))
            {
                if ((sColumn->basicInfo->column.flag & SMI_COLUMN_TYPE_MASK)
                    == SMI_COLUMN_TYPE_LOB)
                {
                    // PROJ-1362
                    if ( smiIsNullLobColumn(sRow, &sColumn->basicInfo->column)
                         == ID_TRUE )
                    {
                        *aHasNull = ID_TRUE;
                        break;
                    }
                    else
                    {
                        /* Nothing to do */
                    }
                }
                else
                {
                    sValueTemp = (void*)mtc::value( sColumn->basicInfo,
                                                    sRow,
                                                    MTD_OFFSET_USE );

                    if ( sColumn->basicInfo->module->isNull( sColumn->basicInfo,
                                                             sValueTemp )
                         == ID_TRUE )
                    {
                        *aHasNull = ID_TRUE;
                        break;
                    }
                    else
                    {
                        /* Nothing to do */
                    }
                }

                IDE_TEST(sCursor.readRow(&sRow, &sRid, SMI_FIND_NEXT)
                         != IDE_SUCCESS);
            }

            sStage = 0;

            IDE_TEST(sCursor.close() != IDE_SUCCESS);

            if( *aHasNull == ID_TRUE )
            {
                break;
            }
        }
    }
    else
    {
        // 검색을 위한 자료 구조의 초기화
        SMI_CURSOR_PROP_INIT_FOR_FULL_SCAN( &sCursorProperty, aStatement->mStatistics );

        if ( sTableType == SMI_TABLE_DISK )
        {
            // PROJ-1705
            // sm에서 레코드를 읽기위한 fetch column list 구성.
            sCursorProperty.mFetchColumnList = sFetchColumnList;
            sColumn = sDiskColumn;
        }
        else
        {
            sColumn = sMemoryColumn;
        }

        sCursor.initialize();

        IDE_TEST(sCursor.open(
                     QC_SMI_STMT( aStatement ),
                     aTableInfo->tableHandle,
                     NULL,
                     smiGetRowSCN(aTableInfo->tableHandle),
                     NULL,
                     smiGetDefaultKeyRange(),
                     smiGetDefaultKeyRange(),
                     smiGetDefaultFilter(),
                     QCM_META_CURSOR_FLAG,
                     SMI_SELECT_CURSOR,
                     & sCursorProperty) != IDE_SUCCESS);
        sStage = 1;

        IDE_TEST(sCursor.beforeFirst() != IDE_SUCCESS);
        IDE_TEST(sCursor.readRow(&sRow, &sRid, SMI_FIND_NEXT) != IDE_SUCCESS);

        while ((sRow != NULL) && (*aHasNull != ID_TRUE))
        {
            if ((sColumn->basicInfo->column.flag & SMI_COLUMN_TYPE_MASK)
                == SMI_COLUMN_TYPE_LOB)
            {
                // PROJ-1362
                if ( smiIsNullLobColumn(sRow, & sColumn->basicInfo->column)
                     == ID_TRUE )
                {
                    *aHasNull = ID_TRUE;
                    break;
                }
                else
                {
                    /* Nothing to do */
                }
            }
            else
            {
                sValueTemp = (void*)mtc::value( sColumn->basicInfo,
                                                sRow,
                                                MTD_OFFSET_USE );

                if (sColumn->basicInfo->module->isNull(sColumn->basicInfo,
                                                       sValueTemp )
                    == ID_TRUE)
                {
                    *aHasNull = ID_TRUE;
                    break;
                }
                else
                {
                    /* Nothing to do */
                }
            }

            IDE_TEST(sCursor.readRow(&sRow, &sRid, SMI_FIND_NEXT) != IDE_SUCCESS);
        }

        sStage = 0;

        IDE_TEST(sCursor.close() != IDE_SUCCESS);
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_COLUMN_NOT_FOUND )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QMC_UNEXPECTED_ERROR,
                                  "qdbAlter::hasNullValue",
                                  "Column Not Found" ) );
    }
    IDE_EXCEPTION_END;

    if (sStage == 1)
    {
        sCursor.close();
    }

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::executeAlterMaxRows(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *      ALTER TABLE ... MAXROWS 수행
 *
 * Implementation :
 *      1. getTableInfoByID
 *      2. modifyTableInfo
 *      3. SYS_TABLES_ 메타 테이블에서 MAXROW 값 변경
 *      4. 메타 캐쉬 재구성
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::executeAlterMaxRows"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY("qdbAlter::executeAlterMaxRows"));

    qdTableParseTree    * sParseTree;
    ULong                 sMaxRows;
    qcmTableInfo        * sTableInfo      = NULL;
    UInt                  sTableID;
    smOID                 sTableOID;
    SChar               * sSqlStr;
    vSLong                sRowCnt;

    qcmTableInfo        * sNewTableInfo   = NULL;
    void                * sNewTableHandle = NULL;
    smSCN                 sNewSCN         = SM_SCN_INIT;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // TASK-2176
    // Table에 대한 Lock을 획득한다.
    IDE_TEST( qcm::validateAndLockTable(aStatement,
                                        sParseTree->tableHandle,
                                        sParseTree->tableSCN,
                                        SMI_TABLE_LOCK_X)
              != IDE_SUCCESS);

    sTableInfo = sParseTree->tableInfo;
    sTableID = sTableInfo->tableID;

    if (sParseTree->maxrows == 0)
    {
        sMaxRows = ID_ULONG_MAX;
    }
    else
    {
        sMaxRows = sParseTree->maxrows;
    }

    // update maxrows
    IDE_TEST(smiTable::modifyTableInfo(QC_SMI_STMT( aStatement ),
                                       sTableInfo->tableHandle,
                                       NULL,
                                       0,
                                       NULL,
                                       0,
                                       SMI_TABLE_FLAG_UNCHANGE,
                                       SMI_TBSLV_DDL_DML,
                                       sMaxRows,
                                       0,
                                       ID_TRUE) /* aIsInitRowTemplate */
             != IDE_SUCCESS);

    IDU_LIMITPOINT("qdbAlter::executeAlterMaxRows::malloc");
    IDE_TEST(STRUCT_ALLOC_WITH_SIZE(aStatement->qmxMem,
                                    SChar,
                                    QD_MAX_SQL_LENGTH,
                                    &sSqlStr)
             != IDE_SUCCESS);

    idlOS::snprintf( sSqlStr, QD_MAX_SQL_LENGTH,
                     "UPDATE SYS_TABLES_ "
                     "SET MAXROW = BIGINT'%"ID_INT64_FMT"', "
                     "    LAST_DDL_TIME = SYSDATE "
                     "WHERE TABLE_ID = INTEGER'%"ID_INT32_FMT"'",
                     sParseTree->maxrows,
                     sTableID );

    IDE_TEST(qcg::runDMLforDDL( QC_SMI_STMT( aStatement ),
                                sSqlStr,
                                & sRowCnt ) != IDE_SUCCESS);

    IDE_TEST_RAISE(sRowCnt != 1, ERR_META_CRASH);

    // rebuild tableInfo
    sTableOID = smiGetTableId(sTableInfo->tableHandle);

    IDE_TEST(qcm::touchTable(QC_SMI_STMT( aStatement ),
                             sTableID,
                             SMI_TBSLV_DDL_DML )
             != IDE_SUCCESS);

    IDE_TEST(qcm::makeAndSetQcmTableInfo(
                 QC_SMI_STMT( aStatement ),
                 sTableID,
                 sTableOID) != IDE_SUCCESS);

    IDE_TEST( qcm::getTableInfoByID( aStatement,
                                     sTableID,
                                     & sNewTableInfo,
                                     & sNewSCN,
                                     & sNewTableHandle )
              != IDE_SUCCESS );

    /* Partitioned Table을 지원하지 않으므로, Partition 관련 작업을 하지 않는다. */

    (void)qcm::destroyQcmTableInfo(sTableInfo);

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_META_CRASH)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QCM_META_CRASH));
    }
    IDE_EXCEPTION_END;

    (void)qcm::destroyQcmTableInfo( sNewTableInfo );

    qcmPartition::restoreTempInfo( sTableInfo,
                                   NULL,
                                   NULL );

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::executeAlterTableOptions(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *      ALTER TABLE ... LOGGING/NOLOGGING PARALLEL/NOPARALLEL 수행
 *
 * Implementation :
 *      1. getTableInfoByID
 *      2. modifyTableInfo
 *      3. 메타 캐쉬 재구성
 *
 ***********************************************************************/

    qdTableParseTree    * sParseTree = NULL;
    qcmTableInfo        * sTableInfo = NULL;
    UInt                  sTableID;
    smOID                 sTableOID;
    UInt                  sFlag;
    UInt                  sLoggingMode;
    UInt                  sParallelDegree;

    qcmPartitionInfoList * sOldPartInfoList = NULL;
    qcmPartitionInfoList * sNewPartInfoList = NULL;
    qcmTableInfo         * sNewTableInfo    = NULL;
    void                 * sNewTableHandle  = NULL;
    smSCN                  sNewSCN          = SM_SCN_INIT;

    //------------------
    // 기본 정보 설정
    //------------------

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    //------------------
    // Table에 대한 Lock을 획득한다.
    //------------------

    IDE_TEST( qcm::validateAndLockTable(aStatement,
                                        sParseTree->tableHandle,
                                        sParseTree->tableSCN,
                                        SMI_TABLE_LOCK_X)
              != IDE_SUCCESS);

    sTableInfo = sParseTree->tableInfo;
    sTableID   = sTableInfo->tableID;

    // PROJ-1502 PARTITIONED DISK TABLE
    if ( sTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST( qcmPartition::validateAndLockPartitionInfoList( aStatement,
                                                                  sParseTree->partTable->partInfoList,
                                                                  SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                                  SMI_TABLE_LOCK_X,
                                                                  ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                                    ID_ULONG_MAX :
                                                                    smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );

        // 예외 처리를 위하여, Lock을 잡은 후에 Partition List를 설정한다.
        sOldPartInfoList = sParseTree->partTable->partInfoList;
    }
    else
    {
        /* Nothing to do */
    }

    //------------------
    // logging mode
    //------------------

    if ( sParseTree->loggingMode != NULL )
    {
        sLoggingMode = *(sParseTree->loggingMode);

        sFlag = sTableInfo->tableFlag;
        sFlag &= ~SMI_TABLE_LOGGING_MASK;
        sFlag |= sLoggingMode;
    }
    else
    {
        sFlag = SMI_TABLE_FLAG_UNCHANGE;
    }

    //------------------
    // parallel degree
    //------------------
    if ( sParseTree->parallelDegree != 0 )
    {
        sParallelDegree = sParseTree->parallelDegree;
    }
    else
    {
        // Parallel Degree가 0이면
        // Parallel Degree가 주어지지 않음을 의미
        // ( Parallel Degree를 0으로 넘기면
        //   sm 쪽에서 원래의 parallel degree 값을
        //   변경하지 않음 )
        sParallelDegree = 0;
    }

    //------------------
    // update logging mode & parallel degree
    //------------------
    IDE_TEST(smiTable::modifyTableInfo(QC_SMI_STMT( aStatement ),
                                       sTableInfo->tableHandle,
                                       NULL,
                                       0,
                                       NULL,
                                       0,
                                       sFlag,
                                       SMI_TBSLV_DDL_DML,
                                       0,
                                       sParallelDegree,
                                       ID_TRUE) /* aIsInitRowTemplate */
             != IDE_SUCCESS);

    /* TODO Partition에는 적용하지 않는 이유가 있을까? */

    // rebuild tableInfo
    sTableOID = smiGetTableId(sTableInfo->tableHandle);

    if (sParallelDegree == 0)
    {
        sParallelDegree = sTableInfo->parallelDegree;
    }
    else
    {
        /* nothing to do */
    }

    IDE_TEST(qdbCommon::updateTableSpecFromMeta(
                 aStatement,
                 sParseTree->userName,
                 sParseTree->tableName,
                 sTableID,
                 sTableOID,
                 sParseTree->tableInfo->columnCount,
                 sParallelDegree)
             != IDE_SUCCESS);

    IDE_TEST(qcm::touchTable(QC_SMI_STMT( aStatement ),
                             sTableID,
                             SMI_TBSLV_DDL_DML )
             != IDE_SUCCESS);

    IDE_TEST(qcm::makeAndSetQcmTableInfo(
                 QC_SMI_STMT( aStatement ),
                 sTableID,
                 sTableOID) != IDE_SUCCESS);

    IDE_TEST( qcm::getTableInfoByID( aStatement,
                                     sTableID,
                                     & sNewTableInfo,
                                     & sNewSCN,
                                     & sNewTableHandle )
              != IDE_SUCCESS );

    if ( sTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST( qcmPartition::touchPartitionInfoList( QC_SMI_STMT( aStatement ),
                                                        sOldPartInfoList )
                  != IDE_SUCCESS );

        IDE_TEST( qcmPartition::makeAndSetAndGetQcmPartitionInfoList( aStatement,
                                                                      sNewTableInfo,
                                                                      sOldPartInfoList,
                                                                      & sNewPartInfoList )
                  != IDE_SUCCESS );

        (void)qcmPartition::destroyQcmPartitionInfoList( sOldPartInfoList );
    }
    else
    {
        /* Nothing to do */
    }

    (void)qcm::destroyQcmTableInfo(sTableInfo);

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    (void)qcm::destroyQcmTableInfo( sNewTableInfo );
    (void)qcmPartition::destroyQcmPartitionInfoList( sNewPartInfoList );

    qcmPartition::restoreTempInfo( sTableInfo,
                                   sOldPartInfoList,
                                   NULL );

    return IDE_FAILURE;
}

IDE_RC qdbAlter::executeAlterLobAttributes(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *    PROJ-1362
 *    ALTER TABLE ... ALTER LOB COLUMN ( lob column )
 *      STORE AS ( LOGGING/NOLOGGING/BUFFER/NOBUFFER ) 의 execution 수행
 *
 * Implementation :
 *    1. 원복을 위해 new 메타 캐쉬 구성
 *    2. getTableInfoByID
 *    3. SYS_LOBS_ 메타 테이블 변경
 *    4. modifyTableInfo
 *    5. related PSM 을 invalid 상태로 변경
 *    6. qcm::touchTable
 *    7. 메타 캐쉬 재구성
 *
 ***********************************************************************/

    qdTableParseTree      * sParseTree;
    UInt                    sTableID;
    smOID                   sTableOID;
    smSCN                   sSCN;
    qcmTableInfo          * sOldTableInfo = NULL;
    qcmTableInfo          * sNewInfo = NULL;
    void                  * sTableHandle;
    qcmColumn             * sLastColumn;
    smiColumnList         * sColumnList;
    smiColumnList        ** sPartColumnList = NULL;
    SChar                 * sSqlStr;
    UInt                    sPartUpdateCount = 0;
    UInt                    sUpdateCount = 0;
    UInt                    i = 0;
    UInt                    sPartitionID;
    qdPartitionAttribute  * sPartAttr;
    qcmPartitionInfoList  * sPartInfoList = NULL;
    qcmPartitionInfoList  * sOldPartInfoList = NULL;
    qcmPartitionInfoList  * sNewPartInfoList = NULL;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // TASK-2176
    // Table에 대한 Lock을 획득한다.
    IDE_TEST( qcm::validateAndLockTable(aStatement,
                                        sParseTree->tableHandle,
                                        sParseTree->tableSCN,
                                        SMI_TABLE_LOCK_X)
              != IDE_SUCCESS);

    sOldTableInfo = sParseTree->tableInfo;

    sTableID = sParseTree->tableInfo->tableID;
    sTableOID = smiGetTableId(sParseTree->tableInfo->tableHandle);

    if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST( qcmPartition::validateAndLockPartitionInfoList( aStatement,
                                                                  sParseTree->partTable->partInfoList,
                                                                  SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                                  SMI_TABLE_LOCK_X,
                                                                  ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                                    ID_ULONG_MAX :
                                                                    smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );

        // 예외 처리를 위하여, Lock을 잡은 후에 Partition List를 설정한다.
        sOldPartInfoList = sParseTree->partTable->partInfoList;
    }
    else
    {
        /* Nothing to do */
    }

    IDE_TEST(qcm::makeAndSetQcmTableInfo(
                 QC_SMI_STMT(aStatement),
                 sTableID,
                 sTableOID) != IDE_SUCCESS);

    IDE_TEST(qcm::getTableInfoByID(aStatement,
                                   sTableID,
                                   &sNewInfo,
                                   &sSCN,
                                   &sTableHandle) != IDE_SUCCESS);

    IDE_TEST(qdbCommon::allocSmiColList(aStatement,
                                        sTableHandle,
                                        &sColumnList)
             != IDE_SUCCESS);

    IDU_LIMITPOINT("qdbAlter::executeAlterLobAttributes::malloc1");
    IDE_TEST(STRUCT_ALLOC_WITH_SIZE(aStatement->qmxMem,
                                    SChar,
                                    QD_MAX_SQL_LENGTH,
                                    &sSqlStr)
             != IDE_SUCCESS);

    if (sParseTree->lobAttr->columns == NULL)
    {
        // NULL이면 테이블의 모든 LOB 컬럼을 alter한다.
        for (sLastColumn = sNewInfo->columns;
             sLastColumn != NULL;
             sLastColumn = sLastColumn->next)
        {
            if ((sLastColumn->basicInfo->column.flag & SMI_COLUMN_TYPE_MASK)
                == SMI_COLUMN_TYPE_LOB)
            {
                IDE_TEST( updateLobStorageAttr(aStatement,
                                               sParseTree->lobAttr,
                                               sColumnList,
                                               sLastColumn,
                                               sSqlStr,
                                               0, /* aPartID */
                                               & sUpdateCount ) );
            }
            else
            {
                // Nothing to do.
            }
        }
    }
    else
    {
        for (sLastColumn = sParseTree->lobAttr->columns;
             sLastColumn != NULL;
             sLastColumn = sLastColumn->next)
        {
            IDE_TEST( updateLobStorageAttr(aStatement,
                                           sParseTree->lobAttr,
                                           sColumnList,
                                           sLastColumn,
                                           sSqlStr,
                                           0, /* aPartID */
                                           & sUpdateCount ) );
        }
    }

    // fix BUG-14394
    IDE_TEST(qdbCommon::updateTableSpecFromMeta(
                 aStatement,
                 sParseTree->userName,
                 sParseTree->tableName,
                 sTableID,
                 sTableOID,
                 sParseTree->tableInfo->columnCount,
                 sParseTree->tableInfo->parallelDegree )
             != IDE_SUCCESS);

    // PROJ-1502 PARTITIONED DISK TABLE
    if( sParseTree->partTable->partAttr != NULL )
    {
        for( sPartInfoList = sOldPartInfoList, i = 0;
             sPartInfoList != NULL;
             sPartInfoList = sPartInfoList->next, i++ )
        {
            // Nothing to do.
        }

        IDE_TEST( qcmPartition::makeAndSetAndGetQcmPartitionInfoList( aStatement,
                                                                      sNewInfo,
                                                                      sOldPartInfoList,
                                                                      & sNewPartInfoList )
                  != IDE_SUCCESS );

        IDU_LIMITPOINT("qdbAlter::executeAlterLobAttributes::malloc3");
        IDE_TEST( STRUCT_ALLOC_WITH_COUNT( aStatement->qmxMem,
                                           smiColumnList,
                                           i,
                                           & sPartColumnList )
                  != IDE_SUCCESS );

        for( sPartInfoList = sOldPartInfoList, i = 0;
             sPartInfoList != NULL;
             sPartInfoList = sPartInfoList->next, i++ )
        {
            IDE_TEST(qdbCommon::allocSmiColList(aStatement,
                                                sPartInfoList->partHandle,
                                                & sPartColumnList[i] )
                     != IDE_SUCCESS);
        }
    }

    for( sPartAttr = sParseTree->partTable->partAttr,
             sPartInfoList = sNewPartInfoList, i = 0;
         sPartAttr != NULL;
         sPartAttr = sPartAttr->next,
             sPartInfoList = sPartInfoList->next, i++ )
    {
        sPartitionID = sPartInfoList->partitionInfo->partitionID;

        if (sParseTree->lobAttr->columns == NULL)
        {
            // NULL이면 테이블의 모든 LOB 컬럼을 alter한다.
            for (sLastColumn = sPartInfoList->partitionInfo->columns;
                 sLastColumn != NULL;
                 sLastColumn = sLastColumn->next)
            {
                if ((sLastColumn->basicInfo->column.flag & SMI_COLUMN_TYPE_MASK)
                    == SMI_COLUMN_TYPE_LOB)
                {
                    IDE_TEST( updateLobStorageAttr(aStatement,
                                                   sPartAttr->lobAttr,
                                                   sPartColumnList[i],
                                                   sLastColumn,
                                                   sSqlStr,
                                                   sPartitionID,
                                                   & sPartUpdateCount ) );
                }
                else
                {
                    // Nothing to do.
                }
            }
        }
        else
        {
            for (sLastColumn = sPartAttr->lobAttr->columns;
                 sLastColumn != NULL;
                 sLastColumn = sLastColumn->next)
            {
                IDE_TEST( updateLobStorageAttr(aStatement,
                                               sPartAttr->lobAttr,
                                               sPartColumnList[i],
                                               sLastColumn,
                                               sSqlStr,
                                               sPartitionID,
                                               & sPartUpdateCount ) );
            }
        }
    }

    if( sPartUpdateCount > 0 )
    {
        for( sPartInfoList = sNewPartInfoList, i = 0;
             sPartInfoList != NULL;
             sPartInfoList = sPartInfoList->next, i++ )
        {
            IDE_TEST(smiTable::modifyTableInfo(
                         QC_SMI_STMT(aStatement),
                         sPartInfoList->partHandle,
                         sPartColumnList[i],
                         ID_SIZEOF(mtcColumn),
                         NULL,
                         0,
                         SMI_TABLE_FLAG_UNCHANGE,
                         SMI_TBSLV_DDL_DML,
                         sNewInfo->maxrows,
                         0,
                         ID_TRUE) /* aIsInitRowTemplate */
                     != IDE_SUCCESS);
        }
    }
    else
    {
        // Nothing to do
    }

    if (sUpdateCount > 0 || sPartUpdateCount > 0)
    {
        IDE_TEST(smiTable::modifyTableInfo(
                     QC_SMI_STMT(aStatement),
                     sTableHandle,
                     sColumnList,
                     ID_SIZEOF(mtcColumn),
                     NULL,
                     0,
                     SMI_TABLE_FLAG_UNCHANGE,
                     SMI_TBSLV_DDL_DML,
                     sNewInfo->maxrows,
                     0,
                     ID_TRUE) /* aIsInitRowTemplate */
                 != IDE_SUCCESS);
    }
    else
    {
        // Nothing to do.
    }

    IDE_TEST( qcm::touchTable( QC_SMI_STMT( aStatement ),
                               sTableID,
                               SMI_TBSLV_DDL_DML )
              != IDE_SUCCESS );

    (void)qcm::destroyQcmTableInfo( sNewInfo );
    sNewInfo = NULL;

    IDE_TEST( qcm::makeAndSetQcmTableInfo( QC_SMI_STMT( aStatement ),
                                           sTableID,
                                           sTableOID )
              != IDE_SUCCESS );

    IDE_TEST( qcm::getTableInfoByID( aStatement,
                                     sTableID,
                                     &sNewInfo,
                                     &sSCN,
                                     &sTableHandle )
              != IDE_SUCCESS );

    if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST( qcmPartition::touchPartitionInfoList( QC_SMI_STMT( aStatement ),
                                                        sOldPartInfoList )
                  != IDE_SUCCESS );

        (void)qcmPartition::destroyQcmPartitionInfoList( sNewPartInfoList );
        sNewPartInfoList = NULL;

        IDE_TEST( qcmPartition::makeAndSetAndGetQcmPartitionInfoList( aStatement,
                                                                      sNewInfo,
                                                                      sOldPartInfoList,
                                                                      & sNewPartInfoList )
                  != IDE_SUCCESS );

        // old partition info 삭제
        (void)qcmPartition::destroyQcmPartitionInfoList( sOldPartInfoList );
    }
    else
    {
        /* Nothing to do */
    }

    // old table info 삭제
    (void)qcm::destroyQcmTableInfo(sOldTableInfo);

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    (void)qcm::destroyQcmTableInfo( sNewInfo );
    (void)qcmPartition::destroyQcmPartitionInfoList( sNewPartInfoList );

    qcmPartition::restoreTempInfo( sOldTableInfo,
                                   sOldPartInfoList,
                                   NULL );

    return IDE_FAILURE;
}

IDE_RC qdbAlter::executeSplitPartition( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *    PROJ-1502 PARTITIONED DISK TABLE
 *
 *    ALTER TABLE tbl_name SPLIT PARTITION src_part
 *        { AT | VALUES } ( split_cond_value, ... )
 *            INTO ( PARTITION dst_part1, PARTITION dst_part2 )
 *    구문의 execution
 *
 *    - In-place Split
 *          - Left In-place Split
 *              ( src_part == dst_part1 )
 *          - Right In-place Split
 *              ( src_part == dst_part2 )
 *
 *    - Out-place Split
 *          ( src_part != dst_part1 ) and ( src_part != dst_part2 )
 *
 *
 * Implementation :
 *      1. In-placec Split(기존 파티션을 이용할 경우)
 *          1-1. DstPart 파티션 생성
 *          1-2. DstPart에 대한 메타 정보 입력
 *               (SYS_TABLE_PARTITIONS_, SYS_PART_LOBS_)
 *          1-3. SrcPart에서 DstPart로 데이터 이동
 *          1-4. SrcPart의 메타 정보 수정
 *               (SYS_TABLE_PARTITIONS_)
 *          1-5. 로컬 인덱스가 있는 경우 DstPart에 로컬 인덱스 생성
 *
 *      2. Out-place Split(새로운 파티션을 2개 생성할 경우)
 *          2-1. DstPart1, DstPart2 파티션 생성
 *          2-2. DstPart1, DstPart2에 대한 메타 정보 입력
 *               (SYS_TABLE_PARTITIONS_, SYS_PART_LOBS_)
 *          2-3. SrcPart에서 DstPart1과 DstPart2로 데이터 이동
 *          2-4. SrcPart에 대한 메타 정보 삭제
 *               (SYS_TABLE_PARTITIONS_, SYS_PART_LOBS_)
 *          2-5. SrcPart 파티션 삭제
 *          2-6. 로컬 인덱스가 있는 경우 DstPart1, DstPart2에 로컬 인덱스 생성
 *
 *      3. 메타 캐시 재구성(파티션드 테이블)
 *
 ***********************************************************************/

    qdTableParseTree        * sParseTree;
    qcmTableInfo            * sTableInfo;
    qcmTableInfo            * sOldTableInfo = NULL;
    qcmTableInfo            * sNewTableInfo = NULL;
    qdPartitionAttribute    * sSrcPartAttr;
    qdPartitionAttribute    * sDstPartAttr1;
    qdPartitionAttribute    * sDstPartAttr2;
    qcmTableInfo            * sSrcPartInfo = NULL;
    qcmTableInfo            * sTempInfo1 = NULL;
    void                    * sSrcPartHandle;
    qcmTableInfo            * sDstPartInfo1 = NULL;
    void                    * sDstPartHandle1;
    smSCN                     sDstPartSCN1;
    UInt                      sPartitionID1;
    smOID                     sPartitionOID1;
    qcmTableInfo            * sDstPartInfo2 = NULL;
    qcmTableInfo            * sTempInfo2 = NULL;
    void                    * sDstPartHandle2;
    smSCN                     sDstPartSCN2;
    UInt                      sPartitionID2;
    smOID                     sPartitionOID2;
    SChar                   * sSrcPartMinVal;
    SChar                   * sSrcPartMaxVal;
    SChar                   * sDstPartMinVal;
    SChar                   * sDstPartMaxVal;
    SChar                   * sDstPartMinVal2;
    SChar                   * sDstPartMaxVal2;
    UInt                      sPartOrder;
    UInt                      sIndexCount;
    smSCN                     sSCN = SM_SCN_INIT;
    void                    * sTableHandle = NULL;
    idBool                    sIsReplicated = ID_FALSE;

    IDU_LIMITPOINT("qdbAlter::executeSplitPartition::malloc1");
    IDE_TEST(aStatement->qmxMem->cralloc(
                 ID_SIZEOF(SChar) * (QC_MAX_PARTKEY_COND_VALUE_LEN+1),
                 (void**)&sSrcPartMinVal) != IDE_SUCCESS);
    IDU_LIMITPOINT("qdbAlter::executeSplitPartition::malloc2");
    IDE_TEST(aStatement->qmxMem->cralloc(
                 ID_SIZEOF(SChar) * (QC_MAX_PARTKEY_COND_VALUE_LEN+1),
                 (void**)&sSrcPartMaxVal) != IDE_SUCCESS);
    IDU_LIMITPOINT("qdbAlter::executeSplitPartition::malloc3");
    IDE_TEST(aStatement->qmxMem->cralloc(
                 ID_SIZEOF(SChar) * (QC_MAX_PARTKEY_COND_VALUE_LEN+1),
                 (void**)&sDstPartMinVal) != IDE_SUCCESS);
    IDU_LIMITPOINT("qdbAlter::executeSplitPartition::malloc4");
    IDE_TEST(aStatement->qmxMem->cralloc(
                 ID_SIZEOF(SChar) * (QC_MAX_PARTKEY_COND_VALUE_LEN+1),
                 (void**)&sDstPartMaxVal) != IDE_SUCCESS);
    IDU_LIMITPOINT("qdbAlter::executeSplitPartition::malloc5");
    IDE_TEST(aStatement->qmxMem->cralloc(
                 ID_SIZEOF(SChar) * (QC_MAX_PARTKEY_COND_VALUE_LEN+1),
                 (void**)&sDstPartMinVal2) != IDE_SUCCESS);
    IDU_LIMITPOINT("qdbAlter::executeSplitPartition::malloc6");
    IDE_TEST(aStatement->qmxMem->cralloc(
                 ID_SIZEOF(SChar) * (QC_MAX_PARTKEY_COND_VALUE_LEN+1),
                 (void**)&sDstPartMaxVal2) != IDE_SUCCESS);

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // BUG-42329
    IDU_FIT_POINT( "qdbAlter::executeSplitPartition::beforeXLock" );

    // BUG-42329 : 파티션드 테이블에 LOCK(X)
    // SrcPart에 LOCK(X)
    IDE_TEST( qcmPartition::validateAndLockTableAndPartitions(
                  aStatement,
                  sParseTree->tableHandle,
                  sParseTree->tableSCN,
                  sParseTree->partTable->partInfoList,
                  SMI_TABLE_LOCK_X,
                  ID_TRUE ) //aIsSetViewSCN
              != IDE_SUCCESS );

    sTableInfo = sParseTree->tableInfo;

    sSrcPartAttr  = sParseTree->partTable->partAttr;
    sDstPartAttr1 = sParseTree->partTable->partAttr->next;
    sDstPartAttr2 = sParseTree->partTable->partAttr->next->next;

    sSrcPartHandle = sParseTree->partTable->partInfoList->partHandle;
    sSrcPartInfo   = sParseTree->partTable->partInfoList->partitionInfo;

    if ( sSrcPartInfo->replicationCount > 0 )
    {
        sIsReplicated = ID_TRUE;
    }
    else
    {
        /* Nothing to do */
    }

    // PROJ-1624 non-partitioned index
    if ( sParseTree->oldIndexTables != NULL )
    {
        // Index Table을 재생성하지 않고 DML로 처리하므로, IX Lock을 잡는다.
        IDE_TEST( qdx::validateAndLockIndexTableList(
                      aStatement,
                      sParseTree->oldIndexTables,
                      SMI_TBSLV_DDL_DML,
                      SMI_TABLE_LOCK_IX,
                      ( ( smiGetDDLLockTimeOut() == -1 ) ?
                        ID_ULONG_MAX :
                        smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );
    }
    else
    {
        // Nothing to do.
    }

    /*
     * check replication count on partition
     */
    if ( sIsReplicated == ID_TRUE )
    {
        IDE_TEST_RAISE( ( QCG_GET_SESSION_LOCK_TABLE_UNTIL_NEXT_DDL( aStatement ) != ID_TRUE ) ||
                        ( QCG_GET_SESSION_TABLE_ID_OF_LOCK_TABLE_UNTIL_NEXT_DDL( aStatement ) != sTableInfo->tableID ),
                        ERR_DDL_WITH_REPLICATED_PARTITION );

        IDE_TEST( qci::mManageReplicationCallback.mIsDDLEnableOnReplicatedTable( 0, 
                                                                                 sTableInfo )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    // 메타 테이블에서 SrcPart의
    // PARTITION_MIN_VALUE, PARTITION_MAX_VALUE를 얻는다.
    IDE_TEST( qcmPartition::getPartMinMaxValue( QC_SMI_STMT( aStatement ),
                                                sSrcPartInfo->partitionID,
                                                sSrcPartMinVal,
                                                sSrcPartMaxVal )
              != IDE_SUCCESS );

    switch ( sSrcPartAttr->alterPart->splitMergeType )
    {
        case QD_ALTER_PARTITION_LEFT_INPLACE_TYPE:
            {
                //-----------------------------------------------------
                // 1-1. 파티션 키 조건 값을 구한다.
                //-----------------------------------------------------
                // 범위 파티션드 테이블
                if( sTableInfo->partitionMethod == QCM_PARTITION_METHOD_RANGE )
                {
                    // DstPart2의 PARTITION_MIN_VALUE는 파티션 분할 기준 값이다.
                    IDE_TEST( qdbCommon::getPartCondValueFromParseTree(
                                  aStatement,
                                  sSrcPartAttr,
                                  sDstPartMinVal2 )
                              != IDE_SUCCESS );

                    // 기본 파티션의 분할이라면 max_value는 NULL이다.
                    if( idlOS::strlen( sSrcPartMaxVal ) == 0 )
                    {
                        sDstPartMaxVal2[0] = '\0';
                    }
                    // DstPart2의 PARTITION_MAX_VALUE는 SrcPart의 max_value이다.
                    else
                    {
                        idlOS::memcpy( sDstPartMaxVal2,
                                       sSrcPartMaxVal,
                                       ID_SIZEOF(SChar) * (QC_MAX_PARTKEY_COND_VALUE_LEN+1) );

                        sDstPartMaxVal2[idlOS::strlen(sDstPartMaxVal2)] = '\0';
                    }
                }
                // 리스트 파티션드 테이블
                else
                {
                    // 기본 파티션의 분할이라면 DstPart2의
                    // min, max value는 NULL이다.
                    if( idlOS::strlen( sSrcPartMinVal ) == 0 )
                    {
                        sDstPartMinVal2[0] = '\0';
                        sDstPartMaxVal2[0] = '\0';
                    }
                    // DstPart2의 PARTITION_MIN_VALUE는
                    // SrcPart의 PARTITION_MIN_VALUE에서
                    // 분할 조건 값을 제거한 값이다.
                    // (PARTITION_MAX_VALUE도 마찬가지)
                    else
                    {
                        (void) qdbCommon::excludeSplitValFromPartVal( sTableInfo,
                                                                      sSrcPartAttr->alterPart,
                                                                      sDstPartMinVal2 );

                        idlOS::memcpy( sDstPartMaxVal2,
                                       sDstPartMinVal2,
                                       ID_SIZEOF(SChar) * (QC_MAX_PARTKEY_COND_VALUE_LEN+1) );

                        sDstPartMaxVal2[idlOS::strlen(sDstPartMaxVal2)] = '\0';
                    }

                    // SrcPart의 PARTITION_MIN_VALUE, PARTITION_MAX_VALUE는
                    // 파티션 분할 조건 값이다.
                    IDE_TEST( qdbCommon::getPartCondValueFromParseTree(
                                  aStatement,
                                  sSrcPartAttr,
                                  sSrcPartMinVal )
                              != IDE_SUCCESS );

                    idlOS::memcpy( sSrcPartMaxVal,
                                   sSrcPartMinVal,
                                   ID_SIZEOF(SChar) * (QC_MAX_PARTKEY_COND_VALUE_LEN+1) );

                    sSrcPartMaxVal[idlOS::strlen(sSrcPartMaxVal)] = '\0';
                }

                //-----------------------------------------------------
                // 1-2. 범위, 리스트 파티션드 테이블에는 파티션 순서 없음
                //-----------------------------------------------------
                sPartOrder = QDB_NO_PARTITION_ORDER;

                // ------------------------------------------------
                // DstPart2 파티션 생성 및 메타 정보 입력
                // ------------------------------------------------
                IDE_TEST( qdbCommon::createTablePartition( aStatement,
                                                           sParseTree,
                                                           sTableInfo,
                                                           sDstPartAttr2,
                                                           sDstPartMinVal2,
                                                           sDstPartMaxVal2,
                                                           sPartOrder,
                                                           &sPartitionID2,
                                                           &sPartitionOID2)
                          != IDE_SUCCESS );

                IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                              QC_SMI_STMT( aStatement ),
                              sPartitionID2,
                              sPartitionOID2,
                              sTableInfo,
                              NULL )
                          != IDE_SUCCESS );

                // DstPart2의 정보를 가져온다.
                IDE_TEST( qcmPartition::getPartitionInfo( aStatement,
                                                          sTableInfo->tableID,
                                                          sDstPartAttr2->tablePartName,
                                                          & sDstPartInfo2,
                                                          & sDstPartSCN2,
                                                          & sDstPartHandle2 )
                          != IDE_SUCCESS );

                // ------------------------------------------------
                // DISK PARTITIONED TABLE 데이터 이동
                // ------------------------------------------------
                /* PROJ-2464 hybrid partitioned table 지원
                 *  - DstPart Type으로 결정하도록 수정한다.
                 *  - Index를 나중에 생성해야만 하는 매체가 존재하기 때문에, 매체에 따라서 moveRow하는 시점이 다르다.
                 *  - 따라서, 두 매체를 모두 지니는 Partitioned는 한 매체의 방안으로 고정 시킨다.
                 */
                if ( ( sDstPartInfo2->tableFlag & SMI_TABLE_TYPE_MASK ) == SMI_TABLE_DISK )
                {
                    IDE_TEST( qdbCommon::moveRowForInplaceAlterPartition(
                                  aStatement,
                                  sSrcPartHandle,
                                  sDstPartHandle2,
                                  sSrcPartInfo,
                                  sDstPartInfo2,
                                  sParseTree->oldIndexTables,
                                  sSrcPartAttr->alterPart->splitMergeType )
                              != IDE_SUCCESS );
                }
                else
                {
                    /* Nothing To Do */
                }

                // ------------------------------------------------
                // SrcPart의 메타 정보 수정
                // ------------------------------------------------
                // 범위 파티션드 테이블의 경우
                // SrcPart의 PARTITION_MAX_VALUE를 분할 기준 값으로 수정한다.
                // SrcPart의 max_value는 DstPart2의 min_value이다.
                if( sTableInfo->partitionMethod == QCM_PARTITION_METHOD_RANGE )
                {
                    IDE_TEST( qdbCommon::updatePartMaxValueOfTablePartMeta (
                                  aStatement,
                                  sSrcPartInfo->partitionID,
                                  sDstPartMinVal2 )
                              != IDE_SUCCESS );
                }
                // 리스트 파티션드 테이블의 경우
                // excludeSplitValFromPartVal 함수에서 구해놓은
                // min_value, max_value를 이용하여 메타 테이블을 수정한다.
                else
                {
                    IDE_TEST( qdbCommon::updatePartMinValueOfTablePartMeta (
                                  aStatement,
                                  sSrcPartInfo->partitionID,
                                  sSrcPartMinVal )
                              != IDE_SUCCESS );

                    IDE_TEST( qdbCommon::updatePartMaxValueOfTablePartMeta (
                                  aStatement,
                                  sSrcPartInfo->partitionID,
                                  sSrcPartMaxVal )
                              != IDE_SUCCESS );
                }

                /* PROJ-2359 Table/Partition Access Option */
                IDE_TEST( updatePartAccessOfTablePartMeta(
                                aStatement,
                                sSrcPartInfo->partitionID,
                                sDstPartAttr1->accessOption )
                          != IDE_SUCCESS );

                // ------------------------------------------------
                // SrcPart에 로컬 인덱스가 있는 경우 DstPart2에 로컬 인덱스 생성
                // ------------------------------------------------
                if( sTableInfo->indices != NULL )
                {
                    IDE_TEST( qdx::createAllIndexOfTablePart( aStatement,
                                                              sTableInfo,
                                                              sDstPartInfo2,
                                                              sDstPartAttr2->alterPart->indexPartAttr )
                              != IDE_SUCCESS );
                }

                // ------------------------------------------------
                // PROJ-2334 PMT
                // MEMORY PARTITIONED TABLE 데이터 이동
                // ------------------------------------------------
                /* PROJ-2464 hybrid partitioned table 지원
                 *  - DstPart Type으로 결정하도록 수정한다.
                 *  - Index를 나중에 생성해야만 하는 매체가 존재하기 때문에, 매체에 따라서 moveRow하는 시점이 다르다.
                 *  - 따라서, 두 매체를 모두 지니는 Partitioned는 한 매체의 방안으로 고정 시킨다.
                 */
                if ( ( sDstPartInfo2->tableFlag & SMI_TABLE_TYPE_MASK ) != SMI_TABLE_DISK )
                {
                    IDE_TEST( qdbCommon::moveRowForInplaceAlterPartition(
                                  aStatement,
                                  sSrcPartHandle,
                                  sDstPartHandle2,
                                  sSrcPartInfo,
                                  sDstPartInfo2,
                                  sParseTree->oldIndexTables,
                                  sSrcPartAttr->alterPart->splitMergeType )
                              != IDE_SUCCESS );
                }
                else
                {
                    /* Nothing To Do */
                }

                IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                              QC_SMI_STMT( aStatement ),
                              sPartitionID2,
                              sPartitionOID2,
                              sTableInfo,
                              NULL )
                          != IDE_SUCCESS );

                // 새로운 DstPart2의 정보를 가져온다.
                IDE_TEST( qcmPartition::getPartitionInfo(
                              aStatement,
                              sTableInfo->tableID,
                              sDstPartAttr2->tablePartName,
                              & sTempInfo2,
                              & sDstPartSCN2,
                              & sDstPartHandle2 )
                          != IDE_SUCCESS );

                // 이전의 DstPart2의 정보를 삭제한다.
                (void)qcmPartition::destroyQcmPartitionInfo(sDstPartInfo2);
                sDstPartInfo2 = sTempInfo2;
                
                if ( sIsReplicated == ID_TRUE )
                {
                    // BUG-42851 이중화 대상 파티션이면 자동으로 split 후 파티션을 이중화 대상에
                    // 추가한다
                    IDE_TEST( qci::mExecuteReplicationCallback.mExecuteAlterSplitPartition(
                                  aStatement,
                                  sTableInfo,
                                  sSrcPartInfo,
                                  sSrcPartInfo,
                                  sDstPartInfo2 )
                              != IDE_SUCCESS );

                    sOldTableInfo = sTableInfo;
                }
                else
                {
                    /* do nothing */
                }
            }
            break;

        case QD_ALTER_PARTITION_RIGHT_INPLACE_TYPE:
            {
                //-----------------------------------------------------
                // 1-1. 파티션 키 조건 값을 구한다.
                //-----------------------------------------------------
                // 범위 파티션드 테이블
                if( sTableInfo->partitionMethod == QCM_PARTITION_METHOD_RANGE )
                {
                    // 가장 왼쪽의 파티션이면 DstPart1의 min_value는 NULL이다.
                    if( idlOS::strlen( sSrcPartMinVal ) == 0 )
                    {
                        sDstPartMinVal[0] = '\0';
                    }
                    else
                    {
                        // DstPart1의 PARTITION_MIN_VALUE는 SrcPart의 Min Value이다.
                        idlOS::memcpy( sDstPartMinVal,
                                       sSrcPartMinVal,
                                       ID_SIZEOF(SChar) * (QC_MAX_PARTKEY_COND_VALUE_LEN+1) );

                        sDstPartMinVal[idlOS::strlen(sDstPartMinVal)] = '\0';
                    }

                    // DstPart1의 PARTITION_MAX_VALUE는 파티션 분할 기준이다.
                    IDE_TEST( qdbCommon::getPartCondValueFromParseTree(
                                  aStatement,
                                  sSrcPartAttr,
                                  sDstPartMaxVal )
                              != IDE_SUCCESS );
                }
                // 리스트 파티션드 테이블
                else
                {
                    // DstPart1의 PARTITION_MIN_VALUE, PARTITION_MAX_VALUE는
                    // 파티션 분할 기준 값이다.
                    IDE_TEST( qdbCommon::getPartCondValueFromParseTree(
                                  aStatement,
                                  sSrcPartAttr,
                                  sDstPartMinVal )
                              != IDE_SUCCESS );

                    idlOS::memcpy( sDstPartMaxVal,
                                   sDstPartMinVal,
                                   ID_SIZEOF(SChar) * (QC_MAX_PARTKEY_COND_VALUE_LEN+1) );

                    sDstPartMaxVal[idlOS::strlen(sDstPartMaxVal)] = '\0';

                    // 기본 파티션의 분할이라면 SrcPart의
                    // min, max value는 NULL이다.
                    if( idlOS::strlen( sSrcPartMinVal ) == 0 )

                    {
                        sSrcPartMinVal[0] = '\0';
                        sSrcPartMaxVal[0] = '\0';
                    }
                    else
                    {
                        // SrcPart의 PARTITION_MIN_VALUE는
                        // 파티션 분할 전 PARTITION_MIN_VALUE에서
                        // 파티션 분할 기준 값을 제거한 값이다.
                        // (PARTITION_MAX_VALUE도 마찬가지)
                        (void) qdbCommon::excludeSplitValFromPartVal( sTableInfo,
                                                                      sSrcPartAttr->alterPart,
                                                                      sSrcPartMinVal );

                        idlOS::memcpy( sSrcPartMaxVal,
                                       sSrcPartMinVal,
                                       ID_SIZEOF(SChar) * (QC_MAX_PARTKEY_COND_VALUE_LEN+1) );

                        sSrcPartMaxVal[idlOS::strlen(sSrcPartMaxVal)] = '\0';
                    }
                }

                //-----------------------------------------------------
                // 1-2. 범위, 리스트 파티션드 테이블에는 파티션 순서 없음
                //-----------------------------------------------------
                sPartOrder = QDB_NO_PARTITION_ORDER;

                // ------------------------------------------------
                // DstPart1 파티션 생성 및 메타 정보 입력
                // ------------------------------------------------
                IDE_TEST( qdbCommon::createTablePartition( aStatement,
                                                           sParseTree,
                                                           sTableInfo,
                                                           sDstPartAttr1,
                                                           sDstPartMinVal,
                                                           sDstPartMaxVal,
                                                           sPartOrder,
                                                           &sPartitionID1,
                                                           &sPartitionOID1 )
                          != IDE_SUCCESS );

                IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                              QC_SMI_STMT( aStatement ),
                              sPartitionID1,
                              sPartitionOID1,
                              sTableInfo,
                              NULL )
                          != IDE_SUCCESS );

                // DstPart1의 정보를 가져온다.
                IDE_TEST( qcmPartition::getPartitionInfo( aStatement,
                                                          sTableInfo->tableID,
                                                          sDstPartAttr1->tablePartName,
                                                          & sDstPartInfo1,
                                                          & sDstPartSCN1,
                                                          & sDstPartHandle1 )
                          != IDE_SUCCESS );

                // ------------------------------------------------
                // DISK PARTITIONED TABLE  데이터 이동
                // ------------------------------------------------
                /* PROJ-2464 hybrid partitioned table 지원
                 *  - DstPart Type으로 결정하도록 수정한다.
                 *  - Index를 나중에 생성해야만 하는 매체가 존재하기 때문에, 매체에 따라서 moveRow하는 시점이 다르다.
                 *  - 따라서, 두 매체를 모두 지니는 Partitioned는 한 매체의 방안으로 고정 시킨다.
                 */
                if ( ( sDstPartInfo1->tableFlag & SMI_TABLE_TYPE_MASK ) == SMI_TABLE_DISK )
                {
                    IDE_TEST( qdbCommon::moveRowForInplaceAlterPartition(
                                  aStatement,
                                  sSrcPartHandle,
                                  sDstPartHandle1,
                                  sSrcPartInfo,
                                  sDstPartInfo1,
                                  sParseTree->oldIndexTables,
                                  sSrcPartAttr->alterPart->splitMergeType )
                              != IDE_SUCCESS );
                }
                else
                {
                    /* Nothing To Do */
                }

                // ------------------------------------------------
                // SrcPart의 메타 정보 수정
                // ------------------------------------------------
                if( sTableInfo->partitionMethod == QCM_PARTITION_METHOD_RANGE )
                {
                    // SrcPart의 PARTITION_MIN_VALUE를 분할 기준 값으로 수정
                    // DstPart2의 max_value가 SrcPart의 min_value이다.
                    IDE_TEST( qdbCommon::updatePartMinValueOfTablePartMeta(
                                  aStatement,
                                  sSrcPartInfo->partitionID,
                                  sDstPartMaxVal )
                              != IDE_SUCCESS );
                }
                else
                {
                    IDE_TEST( qdbCommon::updatePartMinValueOfTablePartMeta (
                                  aStatement,
                                  sSrcPartInfo->partitionID,
                                  sSrcPartMinVal )
                              != IDE_SUCCESS );

                    IDE_TEST( qdbCommon::updatePartMaxValueOfTablePartMeta (
                                  aStatement,
                                  sSrcPartInfo->partitionID,
                                  sSrcPartMaxVal )
                              != IDE_SUCCESS );
                }

                /* PROJ-2359 Table/Partition Access Option */
                IDE_TEST( updatePartAccessOfTablePartMeta(
                                aStatement,
                                sSrcPartInfo->partitionID,
                                sDstPartAttr2->accessOption )
                          != IDE_SUCCESS );

                // ------------------------------------------------
                // SrcPart에 로컬 인덱스가 있는 경우 DstPart1에 로컬 인덱스 생성
                // ------------------------------------------------
                if( sTableInfo->indices != NULL )
                {
                    IDE_TEST( qdx::createAllIndexOfTablePart( aStatement,
                                                              sTableInfo,
                                                              sDstPartInfo1,
                                                              sDstPartAttr1->alterPart->indexPartAttr )
                              != IDE_SUCCESS );
                }

                // ------------------------------------------------
                // PROJ-2334 PMT
                // MEMORY PARTITIONED TABLE  데이터 이동
                // ------------------------------------------------
                /* PROJ-2464 hybrid partitioned table 지원
                 *  - DstPart Type으로 결정하도록 수정한다.
                 *  - Index를 나중에 생성해야만 하는 매체가 존재하기 때문에, 매체에 따라서 moveRow하는 시점이 다르다.
                 *  - 따라서, 두 매체를 모두 지니는 Partitioned는 한 매체의 방안으로 고정 시킨다.
                 */
                if ( ( sDstPartInfo1->tableFlag & SMI_TABLE_TYPE_MASK ) != SMI_TABLE_DISK )
                {
                    IDE_TEST( qdbCommon::moveRowForInplaceAlterPartition(
                                  aStatement,
                                  sSrcPartHandle,
                                  sDstPartHandle1,
                                  sSrcPartInfo,
                                  sDstPartInfo1,
                                  sParseTree->oldIndexTables,
                                  sSrcPartAttr->alterPart->splitMergeType )
                              != IDE_SUCCESS );
                }
                else
                {
                    /* Nothing To Do */
                }

                IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                              QC_SMI_STMT( aStatement ),
                              sPartitionID1,
                              sPartitionOID1,
                              sTableInfo,
                              NULL )
                          != IDE_SUCCESS );

                // 새 DstPart1의 정보를 가져온다.
                IDE_TEST( qcmPartition::getPartitionInfo(
                              aStatement,
                              sTableInfo->tableID,
                              sDstPartAttr1->tablePartName,
                              & sTempInfo1,
                              & sDstPartSCN1,
                              & sDstPartHandle1 )
                          != IDE_SUCCESS );

                // 이전의 DstPart1의 정보를 삭제한다.
                (void)qcmPartition::destroyQcmPartitionInfo(sDstPartInfo1);
                sDstPartInfo1 = sTempInfo1;
                
                if ( sIsReplicated == ID_TRUE )
                {
                    // BUG-42851 이중화 대상 파티션이면 자동으로 split 후 파티션을 이중화 대상에
                    // 추가한다
                    IDE_TEST( qci::mExecuteReplicationCallback.mExecuteAlterSplitPartition(
                                  aStatement,
                                  sTableInfo,
                                  sSrcPartInfo,
                                  sDstPartInfo1,
                                  sSrcPartInfo )
                              != IDE_SUCCESS );

                    sOldTableInfo = sTableInfo;
                }
                else
                {
                    /* do nothing */
                }
            }
            break;

        case QD_ALTER_PARTITION_OUTPLACE_TYPE:
            {
                //-----------------------------------------------------
                // 1-1. 파티션 키 조건 값을 구한다.
                //-----------------------------------------------------
                // 범위 파티션드 테이블
                if( sTableInfo->partitionMethod == QCM_PARTITION_METHOD_RANGE )
                {
                    // 가장 왼쪽의 파티션이면 DstPart1의 min_value는 NULL이다.
                    if( idlOS::strlen( sSrcPartMinVal ) == 0 )
                    {
                        sDstPartMinVal[0] = '\0';
                    }
                    else
                    {
                        // DstPart1의 PARTITION_MIN_VALUE는 SrcPart의 Min Value이다.
                        idlOS::memcpy( sDstPartMinVal,
                                       sSrcPartMinVal,
                                       ID_SIZEOF(SChar) * (QC_MAX_PARTKEY_COND_VALUE_LEN+1) );

                        sDstPartMinVal[idlOS::strlen(sDstPartMinVal)] = '\0';
                    }

                    // DstPart1의 PARTITION_MAX_VALUE는 파티션 분할 기준이다.
                    IDE_TEST( qdbCommon::getPartCondValueFromParseTree(
                                  aStatement,
                                  sSrcPartAttr,
                                  sDstPartMaxVal )
                              != IDE_SUCCESS );

                    // DstPart2의 PARTITION_MIN_VALUE는 파티션 분할 기준 값이다.
                    IDE_TEST( qdbCommon::getPartCondValueFromParseTree(
                                  aStatement,
                                  sSrcPartAttr,
                                  sDstPartMinVal2 )
                              != IDE_SUCCESS );

                    // 기본 파티션이면 DstPart2의 max_value는 NULL이다.
                    if( idlOS::strlen( sSrcPartMaxVal ) == 0 )
                    {
                        sDstPartMaxVal2[0] = '\0';
                    }
                    else
                    {
                        // DstPart2의 PARTITION_MAX_VALUE는 SrcPart의 Max Value이다.
                        idlOS::memcpy( sDstPartMaxVal2,
                                       sSrcPartMaxVal,
                                       ID_SIZEOF(SChar) * (QC_MAX_PARTKEY_COND_VALUE_LEN+1) );

                        sDstPartMaxVal2[idlOS::strlen(sDstPartMaxVal2)] = '\0';
                    }
                }
                // 리스트 파티션드 테이블
                else
                {
                    // DstPart1의 PARTITION_MIN_VALUE, PARTITION_MAX_VALUE는
                    // 파티션 분할 기준 값이다.
                    IDE_TEST( qdbCommon::getPartCondValueFromParseTree(
                                  aStatement,
                                  sSrcPartAttr,
                                  sDstPartMinVal )
                              != IDE_SUCCESS );

                    idlOS::memcpy( sDstPartMaxVal,
                                   sDstPartMinVal,
                                   ID_SIZEOF(SChar) * (QC_MAX_PARTKEY_COND_VALUE_LEN+1) );

                    sDstPartMaxVal[idlOS::strlen(sDstPartMaxVal)] = '\0';

                    // 기본 파티션이면 DstPart2의 min, max_value는 NULL이다.
                    if( idlOS::strlen( sSrcPartMinVal ) == 0 )
                    {
                        sDstPartMinVal2[0] = '\0';
                        sDstPartMaxVal2[0] = '\0';
                    }
                    else
                    {
                        // DstPart2의 PARTITION_MIN_VALUE는
                        // SrcPart의 PARTITION_MIN_VALUE에서
                        // 파티션 분할 기준 값을 제거한 값이다.
                        // (PARTITION_MAX_VALUE도 마찬가지)
                        (void) qdbCommon::excludeSplitValFromPartVal( sTableInfo,
                                                                      sSrcPartAttr->alterPart,
                                                                      sDstPartMinVal2 );

                        idlOS::memcpy( sDstPartMaxVal2,
                                       sDstPartMinVal2,
                                       ID_SIZEOF(SChar) * (QC_MAX_PARTKEY_COND_VALUE_LEN+1) );

                        sDstPartMaxVal2[idlOS::strlen(sDstPartMaxVal2)] = '\0';
                    }
                }

                //-----------------------------------------------------
                // 1-2. 범위, 리스트 파티션드 테이블에는 파티션 순서 없음
                //-----------------------------------------------------
                sPartOrder = QDB_NO_PARTITION_ORDER;

                IDE_TEST(qdd::deleteTablePartitionFromMeta(aStatement,
                                                           sSrcPartInfo->partitionID)
                         != IDE_SUCCESS );

                // ------------------------------------------------
                // DstPart1 파티션 생성 및 메타 정보 입력
                // ------------------------------------------------
                IDE_TEST( qdbCommon::createTablePartition( aStatement,
                                                           sParseTree,
                                                           sTableInfo,
                                                           sDstPartAttr1,
                                                           sDstPartMinVal,
                                                           sDstPartMaxVal,
                                                           sPartOrder,
                                                           &sPartitionID1,
                                                           &sPartitionOID1)
                          != IDE_SUCCESS );

                // ------------------------------------------------
                // DstPart2 파티션 생성 및 메타 정보 입력
                // ------------------------------------------------
                IDE_TEST( qdbCommon::createTablePartition( aStatement,
                                                           sParseTree,
                                                           sTableInfo,
                                                           sDstPartAttr2,
                                                           sDstPartMinVal2,
                                                           sDstPartMaxVal2,
                                                           sPartOrder,
                                                           &sPartitionID2,
                                                           &sPartitionOID2 )
                          != IDE_SUCCESS );

                IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                              QC_SMI_STMT( aStatement ),
                              sPartitionID1,
                              sPartitionOID1,
                              sTableInfo,
                              NULL )
                          != IDE_SUCCESS );

                IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                              QC_SMI_STMT( aStatement ),
                              sPartitionID2,
                              sPartitionOID2,
                              sTableInfo,
                              NULL )
                          != IDE_SUCCESS );

                // DstPart1의 정보를 가져온다.
                IDE_TEST( qcmPartition::getPartitionInfo( aStatement,
                                                          sTableInfo->tableID,
                                                          sDstPartAttr1->tablePartName,
                                                          & sDstPartInfo1,
                                                          & sDstPartSCN1,
                                                          & sDstPartHandle1 )
                          != IDE_SUCCESS );

                // DstPart2의 정보를 가져온다.
                IDE_TEST( qcmPartition::getPartitionInfo( aStatement,
                                                          sTableInfo->tableID,
                                                          sDstPartAttr2->tablePartName,
                                                          & sDstPartInfo2,
                                                          & sDstPartSCN2,
                                                          & sDstPartHandle2 )
                          != IDE_SUCCESS );

                // ------------------------------------------------
                // DISK PARTITIONED TABLE 데이터 이동
                // ------------------------------------------------
                /* PROJ-2464 hybrid partitioned table 지원
                 *  - DstPart Type으로 결정하도록 수정한다.
                 *  - Index를 나중에 생성해야만 하는 매체가 존재하기 때문에, 매체에 따라서 moveRow하는 시점이 다르다.
                 *  - 따라서, 두 매체를 모두 지니는 Partitioned는 한 매체의 방안으로 고정 시킨다.
                 */
                if ( ( ( sDstPartInfo1->tableFlag & SMI_TABLE_TYPE_MASK ) == SMI_TABLE_DISK ) &&
                     ( ( sDstPartInfo2->tableFlag & SMI_TABLE_TYPE_MASK ) == SMI_TABLE_DISK ) )
                {
                    IDE_TEST( qdbCommon::moveRowForOutplaceSplitPartition(
                                  aStatement,
                                  sSrcPartHandle,
                                  sDstPartHandle1,
                                  sDstPartHandle2,
                                  sSrcPartInfo,
                                  sDstPartInfo1,
                                  sDstPartInfo2,
                                  sParseTree->oldIndexTables,
                                  sSrcPartAttr->alterPart->splitMergeType )
                              != IDE_SUCCESS );

                    // ------------------------------------------------
                    // SrcPart 삭제
                    // ------------------------------------------------
                    IDE_TEST( qdd::dropTablePartitionWithoutMeta( aStatement,
                                                                  sSrcPartInfo )
                              != IDE_SUCCESS );
                }
                else
                {
                    // -----------------------------------------------------
                    // PROJ-2334 PMT
                    // 인덱스 파티션 관련 메타 테이블 정보 삭제
                    // sDstPartInfo 가 sSrcPartitionInfo와 같을 수 있다.
                    // -----------------------------------------------------
                    for ( sIndexCount = 0;
                          sIndexCount < sSrcPartInfo->indexCount;
                          sIndexCount++ )
                    {
                        IDE_TEST( qdd::deleteIndexPartitionFromMeta(
                                      aStatement,
                                      sSrcPartInfo->indices[sIndexCount].indexPartitionID )
                                  != IDE_SUCCESS );
                    }
                }

                // ------------------------------------------------
                // SrcPart에 로컬 인덱스가 있는 경우
                // DstPart1, DstPart2에 로컬 인덱스 생성
                // ------------------------------------------------
                if( sTableInfo->indices != NULL )
                {
                    IDE_TEST( qdx::createAllIndexOfTablePart( aStatement,
                                                              sTableInfo,
                                                              sDstPartInfo1,
                                                              sDstPartAttr1->alterPart->indexPartAttr )
                              != IDE_SUCCESS );

                    IDE_TEST( qdx::createAllIndexOfTablePart( aStatement,
                                                              sTableInfo,
                                                              sDstPartInfo2,
                                                              sDstPartAttr2->alterPart->indexPartAttr )
                              != IDE_SUCCESS );
                }
                else
                {
                    // Nothing to do
                }

                // ------------------------------------------------
                // PROJ-2334 PMT
                // MEMORY PARTITIONED TABLE 데이터 이동
                // ------------------------------------------------
                /* PROJ-2464 hybrid partitioned table 지원
                 *  - DstPart Type으로 결정하도록 수정한다.
                 *  - Index를 나중에 생성해야만 하는 매체가 존재하기 때문에, 매체에 따라서 moveRow하는 시점이 다르다.
                 *  - 따라서, 두 매체를 모두 지니는 Partitioned는 한 매체의 방안으로 고정 시킨다.
                 */
                if ( ( ( sDstPartInfo1->tableFlag & SMI_TABLE_TYPE_MASK ) != SMI_TABLE_DISK ) ||
                     ( ( sDstPartInfo2->tableFlag & SMI_TABLE_TYPE_MASK ) != SMI_TABLE_DISK ) )
                {
                    IDE_TEST( qdbCommon::moveRowForOutplaceSplitPartition(
                                  aStatement,
                                  sSrcPartHandle,
                                  sDstPartHandle1,
                                  sDstPartHandle2,
                                  sSrcPartInfo,
                                  sDstPartInfo1,
                                  sDstPartInfo2,
                                  sParseTree->oldIndexTables,
                                  sSrcPartAttr->alterPart->splitMergeType )
                              != IDE_SUCCESS );

                    // -----------------------------------------------------
                    // SrcPart 파티션 객체 삭제
                    // -----------------------------------------------------
                    IDE_TEST( smiTable::dropTable( QC_SMI_STMT( aStatement ),
                                                   sSrcPartInfo->tableHandle,
                                                   SMI_TBSLV_DDL_DML )
                              != IDE_SUCCESS );
                }
                else
                {
                    /* Nothing To Do */
                }

                IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                              QC_SMI_STMT( aStatement ),
                              sPartitionID1,
                              sPartitionOID1,
                              sTableInfo,
                              NULL )
                          != IDE_SUCCESS );

                IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                              QC_SMI_STMT( aStatement ),
                              sPartitionID2,
                              sPartitionOID2,
                              sTableInfo,
                              NULL )
                          != IDE_SUCCESS );

                // DstPart1의 정보를 가져온다.
                IDE_TEST( qcmPartition::getPartitionInfo(
                              aStatement,
                              sTableInfo->tableID,
                              sDstPartAttr1->tablePartName,
                              & sTempInfo1,
                              & sDstPartSCN1,
                              & sDstPartHandle1 )
                          != IDE_SUCCESS );

                // 이전의 DstPart1의 정보를 삭제한다.
                (void)qcmPartition::destroyQcmPartitionInfo(sDstPartInfo1);
                sDstPartInfo1 = sTempInfo1;
                
                // DstPart2의 정보를 가져온다.
                IDE_TEST( qcmPartition::getPartitionInfo(
                              aStatement,
                              sTableInfo->tableID,
                              sDstPartAttr2->tablePartName,
                              & sTempInfo2,
                              & sDstPartSCN2,
                              & sDstPartHandle2 )
                          != IDE_SUCCESS );
                
                // 이전의 DstPart2의 정보를 삭제한다.
                (void)qcmPartition::destroyQcmPartitionInfo(sDstPartInfo2);
                sDstPartInfo2 = sTempInfo2;
                
                if ( sIsReplicated == ID_TRUE )
                {
                    // BUG-42851 이중화 대상 파티션이면 자동으로 split 후 파티션을 이중화 대상에
                    // 추가한다
                    IDE_TEST( qci::mExecuteReplicationCallback.mExecuteAlterSplitPartition(
                                  aStatement,
                                  sTableInfo,
                                  sSrcPartInfo,
                                  sDstPartInfo1,
                                  sDstPartInfo2 )
                              != IDE_SUCCESS );

                    sOldTableInfo = sTableInfo;
                }
                else
                {
                    /* do nothing */
                }
            }
            break;

        default:
            /* BUG-44469 [qx] codesonar warning in QX, MT, ST */
            IDE_TEST_RAISE( ID_TRUE, ERR_UNEXPECTED );
            break;

    }

    // To fix BUG-17547
    if( ( sSrcPartAttr->alterPart->splitMergeType ==
          QD_ALTER_PARTITION_LEFT_INPLACE_TYPE ) ||
        ( sSrcPartAttr->alterPart->splitMergeType ==
          QD_ALTER_PARTITION_RIGHT_INPLACE_TYPE ) )
    {
        IDE_TEST(qcmPartition::touchPartition(
                     QC_SMI_STMT( aStatement ),
                     sSrcPartInfo->partitionID)
                 != IDE_SUCCESS);
    }
    else
    {
        // Nothing to do
    }

    if ( sIsReplicated == ID_TRUE )
    {
        // qci::mExecuteReplicationCallback.mExecuteAlterSplitPartition()에서 touch를 이미 수행
        // 실패시 tableinfo의 원복이 필요함
        IDE_TEST( qcm::makeAndSetQcmTableInfo(
                      QC_SMI_STMT( aStatement ),
                      sOldTableInfo->tableID,
                      smiGetTableId( sOldTableInfo->tableHandle ) )
                  != IDE_SUCCESS );

        IDE_TEST( qcm::getTableInfoByID( aStatement,
                                         sOldTableInfo->tableID,
                                         &sNewTableInfo,
                                         &sSCN,
                                         &sTableHandle )
                  != IDE_SUCCESS );

        // 실패시 new tableInfo의 삭제가 필요함
        sTableInfo = sNewTableInfo;

        if ( sDstPartInfo1 != NULL )
        {
            IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                          QC_SMI_STMT( aStatement ),
                          sPartitionID1,
                          sPartitionOID1,
                          sNewTableInfo,
                          NULL )
                      != IDE_SUCCESS );

            // 새 DstPart1의 정보를 가져온다.
            IDE_TEST( qcmPartition::getPartitionInfo(
                          aStatement,
                          sNewTableInfo->tableID,
                          sDstPartAttr1->tablePartName,
                          & sTempInfo1,
                          & sDstPartSCN1,
                          & sDstPartHandle1 )
                      != IDE_SUCCESS );

            // 이전의 DstPart1의 정보를 삭제한다.
            (void)qcmPartition::destroyQcmPartitionInfo( sDstPartInfo1 );
            sDstPartInfo1 = sTempInfo1;
        }
        else
        {
            /* Nothing to do */
        }

        if ( sDstPartInfo2 != NULL )
        {
            IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                          QC_SMI_STMT( aStatement ),
                          sPartitionID2,
                          sPartitionOID2,
                          sNewTableInfo,
                          NULL )
                      != IDE_SUCCESS );

            // 새로운 DstPart2의 정보를 가져온다.
            IDE_TEST( qcmPartition::getPartitionInfo(
                          aStatement,
                          sNewTableInfo->tableID,
                          sDstPartAttr2->tablePartName,
                          & sTempInfo2,
                          & sDstPartSCN2,
                          & sDstPartHandle2 )
                      != IDE_SUCCESS );

            // 이전의 DstPart2의 정보를 삭제한다.
            (void)qcmPartition::destroyQcmPartitionInfo( sDstPartInfo2 );
            sDstPartInfo2 = sTempInfo2;
        }
        else
        {
            /* Nothing to do */
        }
    }
    else
    {
        /* Nothing to do */
    }

    // BUG-42329
    IDU_FIT_POINT( "qdbAlter::executeSplitPartition::afterTouch" );

    // fix BUG-14394
    IDE_TEST( qdbCommon::updateTableSpecFromMeta(
                  aStatement,
                  sParseTree->userName,
                  sParseTree->tableName,
                  sTableInfo->tableID,
                  smiGetTableId(sTableInfo->tableHandle),
                  sTableInfo->columnCount,
                  sTableInfo->parallelDegree )
              != IDE_SUCCESS );

    IDE_TEST(qcmView::setInvalidViewOfRelated(
                 aStatement,
                 sParseTree->userID,
                 sTableInfo->name,
                 idlOS::strlen((SChar*)sTableInfo->name),
                 QS_TABLE) != IDE_SUCCESS);

    IDE_TEST(qcmView::recompileAndSetValidViewOfRelated(
                 aStatement,
                 sParseTree->userID,
                 sTableInfo->name,
                 idlOS::strlen((SChar*)sTableInfo->name),
                 QS_TABLE)
             != IDE_SUCCESS);

    // Table Info, Partition Info의 destroy
    switch ( sSrcPartAttr->alterPart->splitMergeType )
    {
        case QD_ALTER_PARTITION_LEFT_INPLACE_TYPE:
            break;

        case QD_ALTER_PARTITION_RIGHT_INPLACE_TYPE:
            break;

        case QD_ALTER_PARTITION_OUTPLACE_TYPE:
            (void)qcmPartition::destroyQcmPartitionInfo(sSrcPartInfo);
            break;

        default:
            IDE_DASSERT(0);
            break;
    }

    if ( sIsReplicated == ID_TRUE )
    {
        (void)qcm::destroyQcmTableInfo( sOldTableInfo );
    }
    else
    {
        /* Nothing to do */
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_DDL_WITH_REPLICATED_PARTITION )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_DDL_WITH_REPLICATED_PART ) );
    }
    IDE_EXCEPTION( ERR_UNEXPECTED )
    {
        IDE_SET( ideSetErrorCode( mtERR_ABORT_UNEXPECTED_ERROR,
                                  "executeSplitPartition",
                                  "invalid split type" ) );
    }
    IDE_EXCEPTION_END;

    (void)qcmPartition::destroyQcmPartitionInfo( sDstPartInfo1 );
    (void)qcmPartition::destroyQcmPartitionInfo( sDstPartInfo2 );

    (void)qcm::destroyQcmTableInfo( sNewTableInfo );

    qcmPartition::restoreTempInfo( sOldTableInfo,
                                   NULL,
                                   NULL );

    return IDE_FAILURE;
}

IDE_RC qdbAlter::executeMergePartition(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *    PROJ-1502 PARTITIONED DISK TABLE
 *    ALTER TABLE ... MERGE PARTITIONS ... 구문의 수행
 *
 * Implementation :
 *
 ***********************************************************************/

    qdTableParseTree        * sParseTree;
    qcmTableInfo            * sTableInfo;
    qdPartitionAttribute    * sSrcPartAttr1;
    qdPartitionAttribute    * sSrcPartAttr2;
    qdPartitionAttribute    * sDstPartAttr;
    idBool                    sIsLeftPartIsLess;

    qcmTableInfo            * sSrcPartInfo1 = NULL;
    void                    * sSrcPartHandle1;

    qcmTableInfo            * sSrcPartInfo2 = NULL;
    void                    * sSrcPartHandle2;

    qcmTableInfo            * sDstPartInfo = NULL;
    qcmTableInfo            * sTempInfo = NULL;
    void                    * sDstPartHandle;
    smSCN                     sDstPartSCN;

    mtdCharType             * sSrcPartMinVal;
    mtdCharType             * sSrcPartMaxVal;
    mtdCharType             * sSrcPartMinVal2;
    mtdCharType             * sSrcPartMaxVal2;
    SChar                   * sDstPartMinVal;
    SChar                   * sDstPartMaxVal;

    UInt                      sPartOrder;
    UInt                      sPartitionID;
    smOID                     sPartitionOID;
    UInt                      sIndexCount;

    qcmTableInfo            * sOldTableInfo = NULL;
    qcmTableInfo            * sNewTableInfo = NULL;
    smSCN                     sSCN = SM_SCN_INIT;
    void                    * sTableHandle = NULL;
    idBool                    sIsReplicated = ID_FALSE;

    IDU_LIMITPOINT("qdbAlter::executeMergePartition::malloc1");
    IDE_TEST(aStatement->qmxMem->cralloc(
                 ID_SIZEOF(SChar) * (QC_MAX_PARTKEY_COND_VALUE_LEN+1),
                 (void**)&sDstPartMinVal) != IDE_SUCCESS);
    IDU_LIMITPOINT("qdbAlter::executeMergePartition::malloc2");
    IDE_TEST(aStatement->qmxMem->cralloc(
                 ID_SIZEOF(SChar) * (QC_MAX_PARTKEY_COND_VALUE_LEN+1),
                 (void**)&sDstPartMaxVal) != IDE_SUCCESS);

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    sSrcPartAttr1  = sParseTree->partTable->partAttr;
    sSrcPartAttr2  = sParseTree->partTable->partAttr->next;
    sDstPartAttr   = sParseTree->partTable->partAttr->next->next;

    sIsLeftPartIsLess = sSrcPartAttr1->alterPart->isLeftPartIsLess;

    // BUG-42329 : 파티션드 테이블에 LOCK(X)
    // 병합할 파티션에 LOCK(X)
    IDE_TEST( qcmPartition::validateAndLockTableAndPartitions(
                  aStatement,
                  sParseTree->tableHandle,
                  sParseTree->tableSCN,
                  sParseTree->partTable->partInfoList,
                  SMI_TABLE_LOCK_X,
                  ID_TRUE ) //aIsSetViewSCN
              != IDE_SUCCESS );

    sTableInfo = sParseTree->tableInfo;

    // --------------------------------------------------
    // SrcPart1에 LOCK(X)후, 파스트리에서 SrcPartInfo1을 가져온다.
    // --------------------------------------------------
    sSrcPartHandle1 = sParseTree->partTable->partInfoList->partHandle;
    sSrcPartInfo1   = sParseTree->partTable->partInfoList->partitionInfo;

    // --------------------------------------------------
    // SrcPart2에 LOCK(X)후, 파스트리에서 SrcPartInfo2를 가져온다.
    // --------------------------------------------------
    sSrcPartHandle2 = sParseTree->partTable->partInfoList->next->partHandle;
    sSrcPartInfo2   = sParseTree->partTable->partInfoList->next->partitionInfo;

    if ( ( sSrcPartInfo1->replicationCount > 0 ) &&
         ( sSrcPartInfo2->replicationCount > 0 ) )
    {
        sIsReplicated = ID_TRUE;
    }
    else
    {
        /* Nothing to do */
    }

    // PROJ-1624 non-partitioned index
    if ( sParseTree->oldIndexTables != NULL )
    {
        // Index Table을 재생성하지 않고 DML로 처리하므로, IX Lock을 잡는다.
        IDE_TEST( qdx::validateAndLockIndexTableList(
                      aStatement,
                      sParseTree->oldIndexTables,
                      SMI_TBSLV_DDL_DML,
                      SMI_TABLE_LOCK_IX,
                      ( ( smiGetDDLLockTimeOut() == -1 ) ?
                        ID_ULONG_MAX :
                        smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );
    }
    else
    {
        // Nothing to do.
    }
    
    /*
     * PROJ-2336
     * check replication count on partition
     */
    if ( ( sSrcPartInfo1->replicationCount > 0 ) || ( sSrcPartInfo2->replicationCount > 0 ) )
    {
        IDE_TEST_RAISE( ( sSrcPartInfo1->replicationCount == 0 ) || ( sSrcPartInfo2->replicationCount == 0 ),
                        ERR_DDL_WITH_REPLICATED_PARTITION );
        IDE_TEST_RAISE( ( QCG_GET_SESSION_LOCK_TABLE_UNTIL_NEXT_DDL( aStatement ) != ID_TRUE ) ||
                        ( QCG_GET_SESSION_TABLE_ID_OF_LOCK_TABLE_UNTIL_NEXT_DDL( aStatement ) != sTableInfo->tableID ),
                        ERR_DDL_WITH_REPLICATED_PARTITION );

        IDE_TEST( qci::mManageReplicationCallback.mIsDDLEnableOnReplicatedTable( 0, 
                                                                                 sTableInfo ) 
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    // --------------------------------------------------
    // SrcPart1, SrcPart2의 min, max_value를 파스트리에서 가져온다.
    // --------------------------------------------------
    sSrcPartMinVal = sSrcPartAttr1->alterPart->partKeyCondMinValStr;
    sSrcPartMaxVal = sSrcPartAttr1->alterPart->partKeyCondMaxValStr;

    sSrcPartMinVal2 = sSrcPartAttr2->alterPart->partKeyCondMinValStr;
    sSrcPartMaxVal2 = sSrcPartAttr2->alterPart->partKeyCondMaxValStr;

    // ------------------------------------------------
    // In-place, Out-place에 따라서 다르게 처리
    // ------------------------------------------------
    switch( sSrcPartAttr1->alterPart->splitMergeType )
    {
        case QD_ALTER_PARTITION_LEFT_INPLACE_TYPE:
            {
                // ------------------------------------------------
                // 데이터 이동(SrcPart2->SrcPart1)
                // ------------------------------------------------
                IDE_TEST( qdbCommon::moveRowForInplaceAlterPartition(
                              aStatement,
                              sSrcPartHandle2,
                              sSrcPartHandle1,
                              sSrcPartInfo2,
                              sSrcPartInfo1,
                              sParseTree->oldIndexTables,
                              sSrcPartAttr1->alterPart->splitMergeType )
                          != IDE_SUCCESS );

                // ------------------------------------------------
                // DstPart의 PARTITION_MIN_VALUE, PARTITION_MAX_VALUE를 구한다.
                // ------------------------------------------------
                // 범위 파티션드 테이블
                if( sTableInfo->partitionMethod == QCM_PARTITION_METHOD_RANGE )
                {
                    // SrcPart1이 SrcPart2보다 작은 파티션 조건 값을 갖는 경우
                    if( sIsLeftPartIsLess == ID_TRUE )
                    {
                        // DstPart의 max_value는 SrcPart2의 max_value이다.
                        // DstPart의 min_value는 변하지 않는다.
                        if( sSrcPartMaxVal2->length == 0 )
                        {
                            sDstPartMaxVal[0] = '\0';
                        }
                        else
                        {
                            idlOS::memcpy( sDstPartMaxVal,
                                           sSrcPartMaxVal2->value,
                                           sSrcPartMaxVal2->length );

                            sDstPartMaxVal[sSrcPartMaxVal2->length] = '\0';
                        }
                    }
                    else
                    {
                        // DstPart의 min_value는 SrcPart2의 min_value이다.
                        // DstPart의 max_value는 변하지 않는다.
                        if( sSrcPartMinVal2->length == 0 )
                        {
                            sDstPartMinVal[0] = '\0';
                        }
                        else
                        {
                            idlOS::memcpy( sDstPartMinVal,
                                           sSrcPartMinVal2->value,
                                           sSrcPartMinVal2->length );

                            sDstPartMinVal[sSrcPartMinVal2->length] = '\0';
                        }
                    }
                }
                // 리스트 파티션드 테이블
                else
                {
                    // 병합되는 파티션 중 한 파티션이 기본파티션이라면
                    // DstPart의 min_value, max_value는 NULL이다.
                    if( ( sSrcPartMinVal->length == 0 ) ||
                        ( sSrcPartMinVal2->length == 0 ) )
                    {
                        sDstPartMinVal[0] = '\0';
                        sDstPartMaxVal[0] = '\0';
                    }
                    else
                    {
                        // SrcPart1의 PARTITION_MIN_VALUE와
                        // SrcPart2의 PARTITION_MIN_VALUE를 병합해서
                        // sDstPartMinVal로 가져온다.
                        // (PARTITION_MAX_VALUE는 PARTITION_MIN_VALUE와 같다.)
                        qdbCommon::mergePartCondVal( aStatement,
                                                     sDstPartMinVal );

                        idlOS::memcpy( sDstPartMaxVal,
                                       sDstPartMinVal,
                                       ID_SIZEOF(SChar) * (QC_MAX_PARTKEY_COND_VALUE_LEN+1) );
                    }
                }

                // ------------------------------------------------
                // SrcPart의 메타 정보 수정
                // ------------------------------------------------
                // 범위 파티션드 테이블
                if( sTableInfo->partitionMethod == QCM_PARTITION_METHOD_RANGE )
                {
                    // SrcPart1이 SrcPart2보다 작은 파티션 조건 값을 갖는 경우
                    if( sIsLeftPartIsLess == ID_TRUE )
                    {
                        // SrcPart1의 max_value를
                        // DstPart의 max_value로 수정한다.
                        IDE_TEST( qdbCommon::updatePartMaxValueOfTablePartMeta(
                                      aStatement,
                                      sSrcPartInfo1->partitionID,
                                      sDstPartMaxVal )
                                  != IDE_SUCCESS );
                    }
                    else
                    {
                        // SrcPart1의 min_value를
                        // DstPart의 min_value로 수정한다.
                        IDE_TEST( qdbCommon::updatePartMinValueOfTablePartMeta(
                                      aStatement,
                                      sSrcPartInfo1->partitionID,
                                      sDstPartMinVal )
                                  != IDE_SUCCESS );
                    }
                }
                // 리스트 파티션드 테이블
                else
                {
                    // SrcPart1의 min_value를
                    // DstPart의 min_value로 수정한다.
                    IDE_TEST( qdbCommon::updatePartMinValueOfTablePartMeta(
                                  aStatement,
                                  sSrcPartInfo1->partitionID,
                                  sDstPartMinVal )
                              != IDE_SUCCESS );

                    // SrcPart1의 max_value를
                    // DstPart의 max_value로 수정한다.
                    IDE_TEST( qdbCommon::updatePartMaxValueOfTablePartMeta(
                                  aStatement,
                                  sSrcPartInfo1->partitionID,
                                  sDstPartMaxVal )
                              != IDE_SUCCESS );
                }

                /* PROJ-2359 Table/Partition Access Option */
                IDE_TEST( updatePartAccessOfTablePartMeta(
                                aStatement,
                                sSrcPartInfo1->partitionID,
                                sDstPartAttr->accessOption )
                          != IDE_SUCCESS );

                // ------------------------------------------------
                // SrcPart2 삭제
                // ------------------------------------------------
                IDE_TEST( qdd::dropTablePartition( aStatement,
                                                   sSrcPartInfo2,
                                                   ID_FALSE, /* aIsDropTablespace */
                                                   ID_FALSE )
                          != IDE_SUCCESS );

                /* BUG-42851 */
                if ( sIsReplicated == ID_TRUE )
                {
                    // BUG-42851 이중화 대상 파티션이면 자동으로 merge 후 파티션을 이중화 대상에
                    // 추가한다
                    IDE_TEST( qci::mExecuteReplicationCallback.mExecuteAlterMergePartition(
                                  aStatement,
                                  sTableInfo,
                                  sSrcPartInfo1,
                                  sSrcPartInfo2,
                                  sSrcPartInfo1 )
                              != IDE_SUCCESS );

                    sOldTableInfo = sTableInfo;
                }
                else
                {
                    /* Nothing to do */
                }
            }
            break;

        case QD_ALTER_PARTITION_RIGHT_INPLACE_TYPE:
            {
                // ------------------------------------------------
                // 데이터 이동(SrcPart1->SrcPart2)
                // ------------------------------------------------
                IDE_TEST( qdbCommon::moveRowForInplaceAlterPartition(
                              aStatement,
                              sSrcPartHandle1,
                              sSrcPartHandle2,
                              sSrcPartInfo1,
                              sSrcPartInfo2,
                              sParseTree->oldIndexTables,
                              sSrcPartAttr1->alterPart->splitMergeType )
                          != IDE_SUCCESS );

                // ------------------------------------------------
                // DstPart의 PARTITION_MIN_VALUE, PARTITION_MAX_VALUE를 구한다.
                // ------------------------------------------------
                // 범위 파티션드 테이블
                if( sTableInfo->partitionMethod == QCM_PARTITION_METHOD_RANGE )
                {
                    // SrcPart1이 SrcPart2보다 작은 파티션 조건 값을 갖는 경우
                    if( sIsLeftPartIsLess == ID_TRUE )
                    {
                        // DstPart의 min_value는 SrcPart1의 min_value이다.
                        // DstPart의 max_value는 변하지 않는다.
                        if( sSrcPartMinVal->length == 0 )
                        {
                            sDstPartMinVal[0] = '\0';
                        }
                        else
                        {
                            idlOS::memcpy( sDstPartMinVal,
                                           sSrcPartMinVal->value,
                                           sSrcPartMinVal->length );

                            sDstPartMinVal[sSrcPartMinVal->length] = '\0';
                        }
                    }
                    else
                    {
                        // DstPart의 max_value는 SrcPart1의 max_value이다.
                        // DstPart의 min_value는 변하지 않는다.
                        if( sSrcPartMaxVal->length == 0 )
                        {
                            sDstPartMaxVal[0] = '\0';
                        }
                        else
                        {
                            idlOS::memcpy( sDstPartMaxVal,
                                           sSrcPartMaxVal->value,
                                           sSrcPartMaxVal->length );

                            sDstPartMaxVal[sSrcPartMaxVal->length] = '\0';
                        }
                    }
                }
                // 리스트 파티션드 테이블
                else
                {
                    // 병합되는 파티션 중 한 파티션이 기본파티션이라면
                    // DstPart의 min_value, max_value는 NULL이다.
                    if( ( sSrcPartMinVal->length == 0 ) ||
                        ( sSrcPartMinVal2->length == 0 ) )
                    {
                        sDstPartMinVal[0] = '\0';
                        sDstPartMaxVal[0] = '\0';
                    }
                    else
                    {
                        // SrcPart1의 PARTITION_MIN_VALUE와
                        // SrcPart2의 PARTITION_MIN_VALUE를 병합해서
                        // sDstPartMinVal로 가져온다.
                        // (PARTITION_MAX_VALUE는 PARTITION_MIN_VALUE와 같다.)
                        qdbCommon::mergePartCondVal( aStatement,
                                                     sDstPartMinVal );

                        idlOS::memcpy( sDstPartMaxVal,
                                       sDstPartMinVal,
                                       ID_SIZEOF(SChar) * (QC_MAX_PARTKEY_COND_VALUE_LEN+1) );
                    }
                }

                // ------------------------------------------------
                // SrcPart의 메타 정보 수정
                // ------------------------------------------------
                // 범위 파티션드 테이블
                if( sTableInfo->partitionMethod == QCM_PARTITION_METHOD_RANGE )
                {
                    // SrcPart1이 SrcPart2보다 작은 파티션 조건 값을 갖는 경우
                    if( sIsLeftPartIsLess == ID_TRUE )
                    {
                        // SrcPart2의 min_value를
                        // DstPart의 min_value로 수정한다.
                        IDE_TEST( qdbCommon::updatePartMinValueOfTablePartMeta(
                                      aStatement,
                                      sSrcPartInfo2->partitionID,
                                      sDstPartMinVal )
                                  != IDE_SUCCESS );
                    }
                    else
                    {
                        // SrcPart2의 max_value를
                        // DstPart의 max_value로 수정한다.
                        IDE_TEST( qdbCommon::updatePartMaxValueOfTablePartMeta(
                                      aStatement,
                                      sSrcPartInfo2->partitionID,
                                      sDstPartMaxVal )
                                  != IDE_SUCCESS );
                    }
                }
                // 리스트 파티션드 테이블
                else
                {
                    // SrcPart2의 min_value를
                    // DstPart의 min_value로 수정한다.
                    IDE_TEST( qdbCommon::updatePartMinValueOfTablePartMeta(
                                  aStatement,
                                  sSrcPartInfo2->partitionID,
                                  sDstPartMinVal )
                              != IDE_SUCCESS );

                    // SrcPart2의 max_value를
                    // DstPart의 max_value로 수정한다.
                    IDE_TEST( qdbCommon::updatePartMaxValueOfTablePartMeta(
                                  aStatement,
                                  sSrcPartInfo2->partitionID,
                                  sDstPartMaxVal )
                              != IDE_SUCCESS );
                }

                /* PROJ-2359 Table/Partition Access Option */
                IDE_TEST( updatePartAccessOfTablePartMeta(
                                aStatement,
                                sSrcPartInfo2->partitionID,
                                sDstPartAttr->accessOption )
                          != IDE_SUCCESS );

                // ------------------------------------------------
                // SrcPart1 삭제
                // ------------------------------------------------
                IDE_TEST( qdd::dropTablePartition( aStatement,
                                                   sSrcPartInfo1,
                                                   ID_FALSE, /* aIsDropTablespace */
                                                   ID_FALSE )
                          != IDE_SUCCESS );

                /* BUG-42851 */
                if ( sIsReplicated == ID_TRUE )
                {
                    // BUG-42851 이중화 대상 파티션이면 자동으로 merge 후 파티션을 이중화 대상에
                    // 추가한다
                    IDE_TEST( qci::mExecuteReplicationCallback.mExecuteAlterMergePartition(
                                  aStatement,
                                  sTableInfo,
                                  sSrcPartInfo1,
                                  sSrcPartInfo2,
                                  sSrcPartInfo2 )
                              != IDE_SUCCESS );

                    sOldTableInfo = sTableInfo;
                }
                else
                {
                    /* Nothing to do */
                }
            }
            break;

        case QD_ALTER_PARTITION_OUTPLACE_TYPE:
            {
                // ------------------------------------------------
                // DstPart의 PARTITION_MIN_VALUE, PARTITION_MAX_VALUE를 구한다.
                // ------------------------------------------------
                // 범위 파티션드 테이블
                if( sTableInfo->partitionMethod == QCM_PARTITION_METHOD_RANGE )
                {
                    // SrcPart1이 SrcPart2보다 작은 파티션 조건 값을 갖는 경우
                    if( sIsLeftPartIsLess == ID_TRUE )
                    {
                        // DstPart의 min_value는 SrcPart1의 min_value이다.
                        if( sSrcPartMinVal->length == 0 )
                        {
                            sDstPartMinVal[0] = '\0';
                        }
                        else
                        {
                            idlOS::memcpy( sDstPartMinVal,
                                           sSrcPartMinVal->value,
                                           sSrcPartMinVal->length );

                            sDstPartMinVal[sSrcPartMinVal->length] = '\0';
                        }

                        // DstPart의 max_value는 SrcPart2의 max_value이다.
                        if( sSrcPartMaxVal2->length == 0 )
                        {
                            sDstPartMaxVal[0] = '\0';
                        }
                        else
                        {
                            idlOS::memcpy( sDstPartMaxVal,
                                           sSrcPartMaxVal2->value,
                                           sSrcPartMaxVal2->length );

                            sDstPartMaxVal[sSrcPartMaxVal2->length] = '\0';
                        }
                    }
                    else
                    {
                        // DstPart의 min_value는 SrcPart2의 min_value이다.
                        if( sSrcPartMinVal2->length == 0 )
                        {
                            sDstPartMinVal[0] = '\0';
                        }
                        else
                        {
                            idlOS::memcpy( sDstPartMinVal,
                                           sSrcPartMinVal2->value,
                                           sSrcPartMinVal2->length );

                            sDstPartMinVal[sSrcPartMinVal2->length] = '\0';
                        }

                        // DstPart의 max_value는 SrcPart1의 max_value이다.
                        if( sSrcPartMaxVal->length == 0 )
                        {
                            sDstPartMaxVal[0] = '\0';
                        }
                        else
                        {
                            idlOS::memcpy( sDstPartMaxVal,
                                           sSrcPartMaxVal->value,
                                           sSrcPartMaxVal->length );

                            sDstPartMaxVal[sSrcPartMaxVal->length] = '\0';
                        }
                    }
                }
                // 리스트 파티션드 테이블
                else
                {
                    // 병합되는 파티션 중 한 파티션이 기본파티션이라면
                    // DstPart의 min_value, max_value는 NULL이다.
                    if( ( sSrcPartMinVal->length == 0 ) ||
                        ( sSrcPartMinVal2->length == 0 ) )
                    {
                        sDstPartMinVal[0] = '\0';
                        sDstPartMaxVal[0] = '\0';
                    }
                    else
                    {
                        // SrcPart1의 PARTITION_MIN_VALUE와
                        // SrcPart2의 PARTITION_MIN_VALUE를 병합해서
                        // sDstPartMinVal로 가져온다.
                        // (PARTITION_MAX_VALUE는 PARTITION_MIN_VALUE와 같다.)
                        qdbCommon::mergePartCondVal( aStatement,
                                                     sDstPartMinVal );

                        idlOS::memcpy( sDstPartMaxVal,
                                       sDstPartMinVal,
                                       ID_SIZEOF(SChar) * (QC_MAX_PARTKEY_COND_VALUE_LEN+1) );
                    }
                }

                //-----------------------------------------------------
                // 1-2. 범위, 리스트 파티션드 테이블에는 파티션 순서 없음
                //-----------------------------------------------------
                sPartOrder = QDB_NO_PARTITION_ORDER;

                IDE_TEST(qdd::deleteTablePartitionFromMeta(aStatement,
                                                           sSrcPartInfo1->partitionID)
                         != IDE_SUCCESS );

                IDE_TEST(qdd::deleteTablePartitionFromMeta(aStatement,
                                                           sSrcPartInfo2->partitionID)
                         != IDE_SUCCESS );

                // ------------------------------------------------
                // DstPart1 파티션 생성 및 메타 정보 입력
                // ------------------------------------------------
                IDE_TEST( qdbCommon::createTablePartition( aStatement,
                                                           sParseTree,
                                                           sTableInfo,
                                                           sDstPartAttr,
                                                           sDstPartMinVal,
                                                           sDstPartMaxVal,
                                                           sPartOrder,
                                                           &sPartitionID,
                                                           &sPartitionOID )
                          != IDE_SUCCESS );

                IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                              QC_SMI_STMT( aStatement ),
                              sPartitionID,
                              sPartitionOID,
                              sTableInfo,
                              NULL )
                          != IDE_SUCCESS );

                // DstPart의 정보를 가져온다.
                IDE_TEST( qcmPartition::getPartitionInfo( aStatement,
                                                          sTableInfo->tableID,
                                                          sDstPartAttr->tablePartName,
                                                          & sDstPartInfo,
                                                          & sDstPartSCN,
                                                          & sDstPartHandle )
                          != IDE_SUCCESS );

                // ------------------------------------------------
                // DISK PARTITIONED TABLE 데이터 이동({SrcPart1, SrcPart2}->DstPart)
                // ------------------------------------------------
                /* PROJ-2464 hybrid partitioned table 지원
                 *  - DstPart Type으로 결정하도록 수정한다.
                 *  - Index를 나중에 생성해야만 하는 매체가 존재하기 때문에, 매체에 따라서 moveRow하는 시점이 다르다.
                 *  - 따라서, 두 매체를 모두 지니는 Partitioned는 한 매체의 방안으로 고정 시킨다.
                 */
                if ( ( sDstPartInfo->tableFlag & SMI_TABLE_TYPE_MASK ) == SMI_TABLE_DISK )
                {
                    IDE_TEST( qdbCommon::moveRowForOutplaceMergePartition(
                                  aStatement,
                                  sSrcPartHandle1,
                                  sSrcPartHandle2,
                                  sDstPartHandle,
                                  sSrcPartInfo1,
                                  sSrcPartInfo2,
                                  sDstPartInfo,
                                  sParseTree->oldIndexTables )
                              != IDE_SUCCESS );

                    // ------------------------------------------------
                    // SrcPart1 삭제
                    // ------------------------------------------------
                    IDE_TEST( qdd::dropTablePartitionWithoutMeta( aStatement,
                                                                  sSrcPartInfo1 )
                              != IDE_SUCCESS );

                    // ------------------------------------------------
                    // SrcPart2 삭제
                    // ------------------------------------------------
                    IDE_TEST( qdd::dropTablePartitionWithoutMeta( aStatement,
                                                                  sSrcPartInfo2 )
                              != IDE_SUCCESS );
                }
                else
                {
                    // -----------------------------------------------------
                    // PROJ-2334 PMT
                    // memory partitioned table은 인덱스 생성후 data move하기
                    // 때문에 index partition meta 먼저 삭제 한다.
                    // 인덱스 파티션 관련 메타 테이블 정보 삭제
                    // -----------------------------------------------------
                    for ( sIndexCount = 0;
                          sIndexCount < sSrcPartInfo1->indexCount;
                          sIndexCount++ )
                    {
                        IDE_TEST( qdd::deleteIndexPartitionFromMeta(
                                      aStatement,
                                      sSrcPartInfo1->indices[sIndexCount].indexPartitionID )
                                  != IDE_SUCCESS );
                    }

                    for ( sIndexCount = 0;
                          sIndexCount < sSrcPartInfo2->indexCount;
                          sIndexCount++ )
                    {
                        IDE_TEST( qdd::deleteIndexPartitionFromMeta(
                                      aStatement,
                                      sSrcPartInfo2->indices[sIndexCount].indexPartitionID )
                                  != IDE_SUCCESS );
                    }

                }
                
                // ------------------------------------------------
                // SrcPart에 로컬 인덱스가 있는 경우
                // DstPart에 로컬 인덱스 생성
                // ------------------------------------------------
                if( sTableInfo->indices != NULL )
                {
                    IDE_TEST( qdx::createAllIndexOfTablePart( aStatement,
                                                              sTableInfo,
                                                              sDstPartInfo,
                                                              sDstPartAttr->alterPart->indexPartAttr )
                              != IDE_SUCCESS );
                }
                else
                {
                    // Nothing to do
                }

                // ------------------------------------------------
                // PROJ-2334 PMT
                // MEMORY PARTITIONED TABLE 데이터 이동({SrcPart1, SrcPart2}->DstPart)
                // ------------------------------------------------
                /* PROJ-2464 hybrid partitioned table 지원
                 *  - DstPart Type으로 결정하도록 수정한다.
                 *  - Index를 나중에 생성해야만 하는 매체가 존재하기 때문에, 매체에 따라서 moveRow하는 시점이 다르다.
                 *  - 따라서, 두 매체를 모두 지니는 Partitioned는 한 매체의 방안으로 고정 시킨다.
                 */
                if ( ( sDstPartInfo->tableFlag & SMI_TABLE_TYPE_MASK ) != SMI_TABLE_DISK )
                {
                    IDE_TEST( qdbCommon::moveRowForOutplaceMergePartition(
                                  aStatement,
                                  sSrcPartHandle1,
                                  sSrcPartHandle2,
                                  sDstPartHandle,
                                  sSrcPartInfo1,
                                  sSrcPartInfo2,
                                  sDstPartInfo,
                                  sParseTree->oldIndexTables )
                              != IDE_SUCCESS );

                    // -----------------------------------------------------
                    // SrcPart1 파티션 객체 삭제
                    // -----------------------------------------------------
                    IDE_TEST( smiTable::dropTable( QC_SMI_STMT( aStatement ),
                                                   sSrcPartInfo1->tableHandle,
                                                   SMI_TBSLV_DDL_DML )
                              != IDE_SUCCESS );
                    
                    // -----------------------------------------------------
                    // SrcPart2 파티션 객체 삭제
                    // -----------------------------------------------------
                    IDE_TEST( smiTable::dropTable( QC_SMI_STMT( aStatement ),
                                                   sSrcPartInfo2->tableHandle,
                                                   SMI_TBSLV_DDL_DML )
                              != IDE_SUCCESS );
                }
                else
                {
                    /* Nothing To Do */
                }

                IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                              QC_SMI_STMT( aStatement ),
                              sPartitionID,
                              sPartitionOID,
                              sTableInfo,
                              NULL )
                          != IDE_SUCCESS );

                // DstPart의 정보를 가져온다.
                IDE_TEST( qcmPartition::getPartitionInfo(
                              aStatement,
                              sTableInfo->tableID,
                              sDstPartAttr->tablePartName,
                              & sTempInfo,
                              & sDstPartSCN,
                              & sDstPartHandle )
                          != IDE_SUCCESS );
                
                // 이전의 DstPart의 정보를 삭제한다.
                (void)qcmPartition::destroyQcmPartitionInfo(sDstPartInfo);
                sDstPartInfo = sTempInfo;
                
                /* BUG-42851 */
                if ( sIsReplicated == ID_TRUE )
                {
                    // BUG-42851 이중화 대상 파티션이면 자동으로 merge 후 파티션을 이중화 대상에
                    // 추가한다
                    IDE_TEST( qci::mExecuteReplicationCallback.mExecuteAlterMergePartition(
                                  aStatement,
                                  sTableInfo,
                                  sSrcPartInfo1,
                                  sSrcPartInfo2,
                                  sDstPartInfo )
                              != IDE_SUCCESS );

                    sOldTableInfo = sTableInfo;
                }
                else
                {
                    /* Nothing to do */
                }
            }
            break;

        default:
            IDE_DASSERT(0);
            break;
    }

    // To fix BUG-17547
    if( sSrcPartAttr1->alterPart->splitMergeType ==
        QD_ALTER_PARTITION_LEFT_INPLACE_TYPE )
    {
        IDE_TEST(qcmPartition::touchPartition(
                     QC_SMI_STMT( aStatement ),
                     sSrcPartInfo1->partitionID)
                 != IDE_SUCCESS);
    }
    else if( sSrcPartAttr1->alterPart->splitMergeType ==
             QD_ALTER_PARTITION_RIGHT_INPLACE_TYPE )
    {
        IDE_TEST(qcmPartition::touchPartition(
                     QC_SMI_STMT( aStatement ),
                     sSrcPartInfo2->partitionID)
                 != IDE_SUCCESS);
    }
    else
    {
        // Nothing to do
    }

    if ( sIsReplicated == ID_TRUE )
    {
        // qci::mExecuteReplicationCallback.mExecuteAlterMergePartition()에서 touch를 이미 수행
        // 실패시 tableinfo의 원복이 필요함
        IDE_TEST( qcm::makeAndSetQcmTableInfo(
                      QC_SMI_STMT( aStatement ),
                      sOldTableInfo->tableID,
                      smiGetTableId( sOldTableInfo->tableHandle ) )
                  != IDE_SUCCESS );

        IDE_TEST( qcm::getTableInfoByID( aStatement,
                                         sOldTableInfo->tableID,
                                         &sNewTableInfo,
                                         &sSCN,
                                         &sTableHandle )
                  != IDE_SUCCESS );

        // 실패시 new tableInfo의 삭제가 필요함
        sTableInfo = sNewTableInfo;

        if ( sDstPartInfo != NULL )
        {
            IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                          QC_SMI_STMT( aStatement ),
                          sPartitionID,
                          sPartitionOID,
                          sNewTableInfo,
                          NULL )
                      != IDE_SUCCESS );

            // DstPart의 정보를 가져온다.
            IDE_TEST( qcmPartition::getPartitionInfo(
                          aStatement,
                          sNewTableInfo->tableID,
                          sDstPartAttr->tablePartName,
                          & sTempInfo,
                          & sDstPartSCN,
                          & sDstPartHandle )
                      != IDE_SUCCESS );

            // 이전의 DstPart의 정보를 삭제한다.
            (void)qcmPartition::destroyQcmPartitionInfo(sDstPartInfo);
            sDstPartInfo = sTempInfo;
        }
        else
        {
            /* Nothing to do */
        }
    }
    else
    {
        /* Nothing to do */
    }

    // fix BUG-14394
    IDE_TEST( qdbCommon::updateTableSpecFromMeta(
                  aStatement,
                  sParseTree->userName,
                  sParseTree->tableName,
                  sTableInfo->tableID,
                  smiGetTableId(sTableInfo->tableHandle),
                  sTableInfo->columnCount,
                  sTableInfo->parallelDegree )
              != IDE_SUCCESS );

    IDE_TEST(qcmView::setInvalidViewOfRelated(
                 aStatement,
                 sParseTree->userID,
                 sTableInfo->name,
                 idlOS::strlen((SChar*)sTableInfo->name),
                 QS_TABLE) != IDE_SUCCESS);

    IDE_TEST(qcmView::recompileAndSetValidViewOfRelated(
                 aStatement,
                 sParseTree->userID,
                 sTableInfo->name,
                 idlOS::strlen((SChar*)sTableInfo->name),
                 QS_TABLE)
             != IDE_SUCCESS);

    // Table Info, Partition Info의 destroy
    switch( sSrcPartAttr1->alterPart->splitMergeType )
    {
        case QD_ALTER_PARTITION_LEFT_INPLACE_TYPE:
            (void)qcmPartition::destroyQcmPartitionInfo(sSrcPartInfo2);
            break;

        case QD_ALTER_PARTITION_RIGHT_INPLACE_TYPE:
            (void)qcmPartition::destroyQcmPartitionInfo(sSrcPartInfo1);
            break;

        case QD_ALTER_PARTITION_OUTPLACE_TYPE:
            (void)qcmPartition::destroyQcmPartitionInfo(sSrcPartInfo1);
            (void)qcmPartition::destroyQcmPartitionInfo(sSrcPartInfo2);
            break;

        default:
            IDE_DASSERT(0);
            break;
    }

    if ( sIsReplicated == ID_TRUE )
    {
        (void)qcm::destroyQcmTableInfo( sOldTableInfo );
    }
    else
    {
        /* Nothing to do */
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_DDL_WITH_REPLICATED_PARTITION )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_DDL_WITH_REPLICATED_PART ) );
    }
    IDE_EXCEPTION_END;

    (void)qcmPartition::destroyQcmPartitionInfo( sDstPartInfo );

    (void)qcm::destroyQcmTableInfo( sNewTableInfo );

    qcmPartition::restoreTempInfo( sOldTableInfo,
                                   NULL,
                                   NULL );

    return IDE_FAILURE;
}

IDE_RC qdbAlter::executeDropPartition( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *    PROJ-1502 PARTITIONED DISK TABLE
 *
 *
 * Implementation :
 *
 ***********************************************************************/

    qdTableParseTree        * sParseTree;
    qcmTableInfo            * sTableInfo = NULL;
    qcmTableInfo            * sOldTableInfo = NULL;
    qcmTableInfo            * sNewTableInfo = NULL;

    smSCN                     sSCN = SM_SCN_INIT;
    void                    * sTableHandle  = NULL;
    qcmTableInfo            * sDropPartInfo = NULL;
    qcmTableInfo            * sRightPartInfo;
    idBool                    sIsReplicated = ID_FALSE;

    SChar                     sPartMinVal[QC_MAX_PARTKEY_COND_VALUE_LEN+1];
    SChar                     sPartMaxVal[QC_MAX_PARTKEY_COND_VALUE_LEN+1];

    idlOS::memset( sPartMinVal, 0x00, QC_MAX_PARTKEY_COND_VALUE_LEN+1 );
    idlOS::memset( sPartMaxVal, 0x00, QC_MAX_PARTKEY_COND_VALUE_LEN+1 );

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // BUG-43243 IX -> X
    // 파티션드 테이블에 LOCK(X)
    // 삭제할 파티션에 LOCK(X)
    IDE_TEST( qcmPartition::validateAndLockTableAndPartitions(
                  aStatement,
                  sParseTree->tableHandle,
                  sParseTree->tableSCN,
                  sParseTree->partTable->partInfoList,
                  SMI_TABLE_LOCK_X,
                  ID_FALSE ) //aIsSetViewSCN
              != IDE_SUCCESS );

    sTableInfo = sParseTree->tableInfo;

    sDropPartInfo = sParseTree->partTable->partInfoList->partitionInfo;

    if ( sDropPartInfo->replicationCount > 0 )
    {
        sIsReplicated = ID_TRUE;
    }
    else
    {
        /* Nothing to do */
    }

    // PROJ-1624 non-partitioned index
    if ( sParseTree->oldIndexTables != NULL )
    {
        // Index Table을 재생성하지 않고 DML로 처리하므로, IX Lock을 잡는다.
        IDE_TEST( qdx::validateAndLockIndexTableList(
                      aStatement,
                      sParseTree->oldIndexTables,
                      SMI_TBSLV_DDL_DML,
                      SMI_TABLE_LOCK_IX,
                      ( ( smiGetDDLLockTimeOut() == -1 ) ?
                        ID_ULONG_MAX :
                        smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );
    }
    else
    {
        // Nothing to do.
    }

    /*
     * check replication count on partition
     */
    if ( sIsReplicated == ID_TRUE )
    {
        IDE_TEST_RAISE( ( QCG_GET_SESSION_LOCK_TABLE_UNTIL_NEXT_DDL( aStatement ) != ID_TRUE ) ||
                        ( QCG_GET_SESSION_TABLE_ID_OF_LOCK_TABLE_UNTIL_NEXT_DDL( aStatement ) != sTableInfo->tableID ),
                        ERR_DDL_WITH_REPLICATED_PARTITION );

        IDE_TEST( qci::mManageReplicationCallback.mIsDDLEnableOnReplicatedTable( 0, 
                                                                                 sTableInfo ) 
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    // ------------------------------------------------
    // 범위 파티션드 테이블이면 오른쪽 파티션의 PARTITION_MIN_VALUE 수정
    // ------------------------------------------------
    if( sTableInfo->partitionMethod == QCM_PARTITION_METHOD_RANGE )
    {
        sRightPartInfo =
            sParseTree->partTable->partInfoList->next->partitionInfo;

        // 삭제할 파티션의 min_value를 구한다.
        IDE_TEST( qcmPartition::getPartMinMaxValue( QC_SMI_STMT( aStatement ),
                                                    sDropPartInfo->partitionID,
                                                    sPartMinVal,
                                                    sPartMaxVal )
                  != IDE_SUCCESS );

        // 오른쪽으로 인접한 파티션의 min_value를
        // 삭제할 파티션의 min_value로 수정한다.
        IDE_TEST( qdbCommon::updatePartMinValueOfTablePartMeta(
                      aStatement,
                      sRightPartInfo->partitionID,
                      sPartMinVal )
                  != IDE_SUCCESS );
    }
    else
    {
        // 리스트 파티션드 테이블
        // Nothing to do
    }

    // ------------------------------------------------
    // index table에서 drop partition oid 삭제
    // ------------------------------------------------

    // PROJ-1624 non-partitioned index
    if ( sParseTree->oldIndexTables != NULL )
    {
        IDE_TEST( qdx::deletePartitionInIndexTableList(
                      aStatement,
                      sParseTree->oldIndexTables,
                      smiGetTableId(sDropPartInfo->tableHandle) )
                  != IDE_SUCCESS );
    }
    else
    {
        // Nothing to do.
    }
    
    // ------------------------------------------------
    // 메타 테이블에서 해당 파티션에 관련된 정보 삭제
    // 파티션 삭제
    // ------------------------------------------------
    IDE_TEST(qdd::dropTablePartition( aStatement,
                                      sDropPartInfo,
                                      ID_FALSE, /* aIsDropTablespace */
                                      ID_FALSE )
             != IDE_SUCCESS );

    // BUG-43243
    if ( sIsReplicated == ID_TRUE )
    {
        IDE_TEST( qci::mExecuteReplicationCallback.mExecuteAlterDropPartition( 
                    aStatement,
                    sTableInfo,
                    sDropPartInfo ) 
                  != IDE_SUCCESS );

        sOldTableInfo = sTableInfo;

        // qci::mExecuteReplicationCallback.mExecuteAlterDropPartition()에서 touch를 이미 수행
        // 이 이후 실패시 sOldTableInfo 로 원복이 필요함
        IDE_TEST( qcm::makeAndSetQcmTableInfo( 
                        QC_SMI_STMT( aStatement ),
                        sOldTableInfo->tableID,
                        smiGetTableId( sOldTableInfo->tableHandle ) )
                  != IDE_SUCCESS );

        IDE_TEST( qcm::getTableInfoByID( aStatement,
                                         sOldTableInfo->tableID,
                                         &sNewTableInfo,
                                         &sSCN,
                                         &sTableHandle ) 
                  != IDE_SUCCESS );
        // 이 이후 실패시 sNewTableInfo 는 삭제되어야 함
        sTableInfo = sNewTableInfo;

        // table Partition 은 삭제될 metaCache 이므로 새로 생성하지 않는다.
    }
    else
    {
        /* Nothing to do */
    }

    // fix BUG-14394
    IDE_TEST( qdbCommon::updateTableSpecFromMeta(
                  aStatement,
                  sParseTree->userName,
                  sParseTree->tableName,
                  sTableInfo->tableID,
                  smiGetTableId(sTableInfo->tableHandle),
                  sTableInfo->columnCount,
                  sTableInfo->parallelDegree )
              != IDE_SUCCESS );

    IDE_TEST(qcmView::setInvalidViewOfRelated(
                 aStatement,
                 sParseTree->userID,
                 sTableInfo->name,
                 idlOS::strlen((SChar*)sTableInfo->name),
                 QS_TABLE) != IDE_SUCCESS);

    IDE_TEST(qcmView::recompileAndSetValidViewOfRelated(
                 aStatement,
                 sParseTree->userID,
                 sTableInfo->name,
                 idlOS::strlen((SChar*)sTableInfo->name),
                 QS_TABLE)
             != IDE_SUCCESS);

    // 메타 캐시 삭제
    (void)qcmPartition::destroyQcmPartitionInfo(sDropPartInfo);

    if ( sIsReplicated == ID_TRUE )
    {
        (void)qcm::destroyQcmTableInfo( sOldTableInfo );
    }
    else
    {
        /* Nothing to do */
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_DDL_WITH_REPLICATED_PARTITION )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_DDL_WITH_REPLICATED_PART ) );
    }
    IDE_EXCEPTION_END;

    (void)qcm::destroyQcmTableInfo( sNewTableInfo );

    qcmPartition::restoreTempInfo( sOldTableInfo,
                                   NULL,
                                   NULL );

    return IDE_FAILURE;
}

IDE_RC qdbAlter::executeRenamePartition( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *    PROJ-1502 PARTITIONED DISK TABLE
 *
 *    ALTER TABLE t1 RENAME PARTITION old_part TO new_part;
 *    구문의 execution
 *
 *
 *
 * Implementation :
 *
 ***********************************************************************/

    qdTableParseTree        * sParseTree;
    qcmTableInfo            * sTableInfo     = NULL;
    qcmTableInfo            * sPartInfo      = NULL;
    SChar                     sNewPartName[QC_MAX_OBJECT_NAME_LEN + 1];

    qcmTableInfo            * sNewPartInfo   = NULL;
    void                    * sNewPartHandle = NULL;
    smSCN                     sNewSCN        = SM_SCN_INIT;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // 파티션드 테이블에 LOCK(IX)
    // 파티션에 LOCK(X)
    IDE_TEST( qcmPartition::validateAndLockTableAndPartitions(
                  aStatement,
                  sParseTree->tableHandle,
                  sParseTree->tableSCN,
                  sParseTree->partTable->partInfoList,
                  SMI_TABLE_LOCK_IX,
                  ID_FALSE ) //aIsSetViewSCN
              != IDE_SUCCESS );

    sTableInfo = sParseTree->tableInfo;

    sPartInfo = sParseTree->partTable->partInfoList->partitionInfo;

    IDE_TEST_RAISE( sPartInfo->replicationCount > 0,
                    ERR_DDL_WITH_REPLICATED_PARTITION );

    QC_STR_COPY( sNewPartName, sParseTree->partTable->partAttr->next->tablePartName );

    // 파티션 이름 업데이트
    IDE_TEST( qdbCommon::updatePartNameOfTablePartMeta (
                  aStatement,
                  sPartInfo->partitionID,
                  sNewPartName )
              != IDE_SUCCESS );

    // To fix BUG-17547
    IDE_TEST(qcmPartition::touchPartition(
                 QC_SMI_STMT( aStatement ),
                 sPartInfo->partitionID)
             != IDE_SUCCESS);

    // fix BUG-14394
    IDE_TEST( qdbCommon::updateTableSpecFromMeta(
                  aStatement,
                  sParseTree->userName,
                  sParseTree->tableName,
                  sTableInfo->tableID,
                  smiGetTableId(sTableInfo->tableHandle),
                  sTableInfo->columnCount,
                  sTableInfo->parallelDegree )
              != IDE_SUCCESS );

    IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                  QC_SMI_STMT( aStatement ),
                  sPartInfo->partitionID,
                  smiGetTableId( sPartInfo->tableHandle ),
                  sTableInfo,
                  NULL )
              != IDE_SUCCESS );

    IDE_TEST( qcmPartition::getPartitionInfo( aStatement,
                                              sTableInfo->tableID,
                                              (UChar *)sNewPartName,
                                              (SInt)idlOS::strlen( sNewPartName ),
                                              & sNewPartInfo,
                                              & sNewSCN,
                                              & sNewPartHandle )
              != IDE_SUCCESS );

    IDE_TEST(qcmView::setInvalidViewOfRelated(
                 aStatement,
                 sParseTree->userID,
                 sTableInfo->name,
                 idlOS::strlen((SChar*)sTableInfo->name),
                 QS_TABLE) != IDE_SUCCESS);

    IDE_TEST(qcmView::recompileAndSetValidViewOfRelated(
                 aStatement,
                 sParseTree->userID,
                 sTableInfo->name,
                 idlOS::strlen((SChar*)sTableInfo->name),
                 QS_TABLE)
             != IDE_SUCCESS);

    // 메타 캐시 삭제
    (void)qcmPartition::destroyQcmPartitionInfo(sPartInfo);

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_DDL_WITH_REPLICATED_PARTITION )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_DDL_WITH_REPLICATED_PART ) );
    }
    IDE_EXCEPTION_END;

    (void)qcmPartition::destroyQcmPartitionInfo( sNewPartInfo );

    qcmPartition::restoreTempInfoForPartition( sTableInfo,
                                               sPartInfo );

    return IDE_FAILURE;
}

IDE_RC qdbAlter::executeTruncatePartition( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *    PROJ-1502 PARTITIONED DISK TABLE
 *
 *
 * Implementation :
 *
 * Replication이 걸린 Table에 대한 DDL인 경우, 추가적으로 아래의 작업을 한다.
 *    1. Validate와 Execute는 다른 Transaction이므로, 프라퍼티 검사는 Execute에서 한다.
 *    2. 관련 Receiver Thread 중지
 *    3. SYS_REPL_ITEMS_의 TABLE_OID 컬럼 갱신
 *    4. Table Meta Log Record 기록
 *
 ***********************************************************************/

    qdTableParseTree        * sParseTree;
    qcmTableInfo            * sTableInfo   = NULL;
    smOID                     sNewPartOID;
    smOID                     sOldPartOID;
    UInt                      sIndexCount;
    smiColumnList           * sColumnListAtKey;
    UInt                      sFlag = 0;

    qcmTableInfo            * sOldPartInfo = NULL;
    const void              * sIndexHandle;
    idBool                    sIsReplicatedTable = ID_FALSE;
    smiSegAttr                sSegAttr;
    smiSegStorageAttr         sSegStoAttr;

    UInt                      sPartType         = 0;

    qcmTableInfo            * sNewPartInfo   = NULL;
    void                    * sNewPartHandle = NULL;
    smSCN                     sNewSCN        = SM_SCN_INIT;

    qcmColumn               * sTempColumns = NULL;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // 파티션드 테이블에 LOCK(IX)
    // 파티션에 LOCK(X)
    IDE_TEST( qcmPartition::validateAndLockTableAndPartitions(
                  aStatement,
                  sParseTree->tableHandle,
                  sParseTree->tableSCN,
                  sParseTree->partTable->partInfoList,
                  SMI_TABLE_LOCK_IX,
                  ID_FALSE ) //aIsSetViewSCN
              != IDE_SUCCESS );

    // PROJ-1624 non-partitioned index
    if ( sParseTree->oldIndexTables != NULL )
    {
        // Index Table을 재생성하지 않고 DML로 처리하므로, IX Lock을 잡는다.
        IDE_TEST( qdx::validateAndLockIndexTableList(
                      aStatement,
                      sParseTree->oldIndexTables,
                      SMI_TBSLV_DDL_DML,
                      SMI_TABLE_LOCK_IX,
                      ( ( smiGetDDLLockTimeOut() == -1 ) ?
                        ID_ULONG_MAX :
                        smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );
    }
    else
    {
        // Nothing to do.
    }
    
    sTableInfo = sParseTree->tableInfo;

    sOldPartInfo = sParseTree->partTable->partInfoList->partitionInfo;
    sOldPartOID  = smiGetTableId(sOldPartInfo->tableHandle);
    sPartType    = sOldPartInfo->tableFlag & SMI_TABLE_TYPE_MASK;

    /* BUG-20514 (PROJ-1442) Partition에 대한 Truncate를 지원해야 합니다.
     * Validate와 Execute는 다른 Transaction이므로, 프라퍼티 검사는 Execute에서 한다.
     */
    if(sTableInfo->replicationCount > 0)
    {
        IDE_TEST( qci::mManageReplicationCallback.mIsDDLEnableOnReplicatedTable( 0, 
                                                                                 sTableInfo )
                  != IDE_SUCCESS );

        IDE_TEST_RAISE(QC_SMI_STMT(aStatement)->getTrans()->getReplicationMode()
                       == SMI_TRANSACTION_REPL_NONE,
                       ERR_CANNOT_WRITE_REPL_INFO);

        /* BUG-20514 (PROJ-1442) Partition에 대한 Truncate를 지원해야 합니다.
         * 관련 Receiver Thread 중지
         */
        IDE_TEST( qciMisc::checkRunningEagerReplicationByTableOID( aStatement,
                                                                   &sOldPartOID,
                                                                   1 )
                  != IDE_SUCCESS );

        //BUG-22703 : Begin Statement를 수행한 후에 Hang이 걸리지 않아야 합니다.
        // mStatistics 통계 정보를 전달 합니다.
        IDE_TEST(qci::mManageReplicationCallback.mStopReceiverThreads(
                                                        QC_SMI_STMT(aStatement),
                                                        aStatement->mStatistics,
                                                        &sOldPartOID,
                                                        1 )
                 != IDE_SUCCESS);

        sIsReplicatedTable = ID_TRUE;
    }

    /* PROJ-2464 hybrid partitioned table 지원
     *  - Partition Info를 구성할 때에, Table Option을 Partitioned Table의 값으로 복제한다.
     *  - 따라서, PartInfo의 정보를 이용하지 않고, TBSID에 따라 적합한 값으로 조정해서 이용한다.
     */
    qdbCommon::adjustPhysicalAttr( sPartType,
                                   sTableInfo->segAttr,
                                   sTableInfo->segStoAttr,
                                   & sSegAttr,
                                   & sSegStoAttr,
                                   ID_TRUE /* aIsTable */ );

    /* BUG-45503 Table 생성 이후에 실패 시, Table Meta Cache의 Column 정보를 복구하지 않는 경우가 있습니다. */
    IDE_TEST( qcm::copyQcmColumns( QC_QMX_MEM( aStatement ),
                                   sOldPartInfo->columns,
                                   & sTempColumns,
                                   sOldPartInfo->columnCount )
              != IDE_SUCCESS );

    IDE_TEST(qdbCommon::createTableOnSM( aStatement,
                                         sTempColumns,
                                         sTableInfo->tableOwnerID,
                                         sTableInfo->tableID,
                                         sTableInfo->maxrows,
                                         sOldPartInfo->TBSID,
                                         sSegAttr,
                                         sSegStoAttr,
                                         /* 원본 Table Flag를
                                            통째로 복사 =>
                                            MASK 비트를 모두 1로설정*/
                                         QDB_TABLE_ATTR_MASK_ALL,
                                         sTableInfo->tableFlag, /* Flag Value */
                                         sTableInfo->parallelDegree,
                                         & sNewPartOID )
             != IDE_SUCCESS);

    // BUG-44814 ddl 구문 수행시 통계정보 복사를 해야함
    smiStatistics::copyTableStats( smiGetTable(sNewPartOID), sOldPartInfo->tableHandle, NULL, 0 );

    // SYS_TABLE_PARTITIONS_의 PARTITION_OID 업데이트
    IDE_TEST(qdbCommon::updatePartTableSpecFromMeta( aStatement,
                                                     sTableInfo->tableID,
                                                     sOldPartInfo->partitionID,
                                                     sNewPartOID )
             != IDE_SUCCESS );

    // fix BUG-14394
    IDE_TEST(qdbCommon::updateTableSpecFromMeta(
                 aStatement,
                 sParseTree->userName,
                 sParseTree->tableName,
                 sParseTree->tableInfo->tableID,
                 smiGetTableId(sParseTree->tableInfo->tableHandle),
                 sParseTree->tableInfo->columnCount,
                 sParseTree->tableInfo->parallelDegree )
             != IDE_SUCCESS);

    // ------------------------------------------------
    // 인덱스가 존재하면
    // re-create index!!
    // ------------------------------------------------
    // 다른 테이블 파티션에 있는
    // 로컬 인덱스의 개수와 똑같이 생성해야 한다.
    for( sIndexCount = 0;
         sIndexCount < sOldPartInfo->indexCount;
         sIndexCount++ )
    {
        // 인덱스 생성을 위한 flag
        sFlag = smiTable::getIndexInfo(sOldPartInfo->indices[sIndexCount].indexHandle);
        sSegAttr = smiTable::getIndexSegAttr(sOldPartInfo->indices[sIndexCount].indexHandle);
        sSegStoAttr = smiTable::getIndexSegStoAttr(sOldPartInfo->indices[sIndexCount].indexHandle);

        // 인덱스 생성을 위한 키 컬럼 정보를 구한다.
        IDE_TEST( qdx::getKeyColumnList( aStatement,
                                         & sOldPartInfo->indices[sIndexCount],
                                         & sColumnListAtKey )
                  != IDE_SUCCESS );

        /* PROJ-2464 hybrid partitioned table 지원
         *  - 관련내용 : PROJ-2433
         */
        IDE_TEST( smiTable::createIndex(aStatement->mStatistics,
                                        QC_SMI_STMT( aStatement ),
                                        sOldPartInfo->indices[sIndexCount].TBSID,
                                        smiGetTable( sNewPartOID ),
                                        (SChar*)sOldPartInfo->indices[sIndexCount].name,
                                        sOldPartInfo->indices[sIndexCount].indexId,
                                        sOldPartInfo->indices[sIndexCount].indexTypeId,
                                        sColumnListAtKey,
                                        sFlag,
                                        QD_INDEX_DEFAULT_PARALLEL_DEGREE,
                                        SMI_INDEX_BUILD_UNCOMMITTED_ROW_DISABLE,
                                        sSegAttr,
                                        sSegStoAttr,
                                        0, /* BUG-42124 : direct key index는 partitioned table를 지원하지 않는다. */
                                        & sIndexHandle )
                  != IDE_SUCCESS );
    }

    // ------------------------------------------------
    // index table에서 old partition oid 삭제
    // ------------------------------------------------

    // PROJ-1624 non-partitioned index
    if ( sParseTree->oldIndexTables != NULL )
    {
        IDE_TEST( qdx::deletePartitionInIndexTableList(
                      aStatement,
                      sParseTree->oldIndexTables,
                      sOldPartOID )
                  != IDE_SUCCESS );
    }
    else
    {
        // Nothing to do.
    }
    
    /* BUG-20514 (PROJ-1442) Partition에 대한 Truncate를 지원해야 합니다.
     * SYS_REPL_ITEMS_의 TABLE_OID 컬럼 갱신
     */
    if(sIsReplicatedTable == ID_TRUE)
    {
        IDE_TEST(qci::mCatalogReplicationCallback.mUpdateReplItemsTableOID(QC_SMI_STMT(aStatement),
                                                  sOldPartOID,
                                                  sNewPartOID)
                 != IDE_SUCCESS);
    }

    // 메타 캐시 생성
    IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                  QC_SMI_STMT( aStatement ),
                  sOldPartInfo->partitionID,
                  sNewPartOID,
                  sTableInfo,
                  NULL )
              != IDE_SUCCESS );

    IDE_TEST( qcmPartition::getPartitionInfo( aStatement,
                                              sTableInfo->tableID,
                                              (UChar *)sOldPartInfo->name,
                                              (SInt)idlOS::strlen( sOldPartInfo->name ),
                                              & sNewPartInfo,
                                              & sNewSCN,
                                              & sNewPartHandle )
              != IDE_SUCCESS );

    // ------------------------------------------------
    // OldPart 삭제
    // ------------------------------------------------
    IDE_TEST( smiTable::dropTable( QC_SMI_STMT( aStatement ),
                                   sOldPartInfo->tableHandle,
                                   SMI_TBSLV_DDL_DML )
              != IDE_SUCCESS );

    /* BUG-20514 (PROJ-1442) Partition에 대한 Truncate를 지원해야 합니다.
     * Table Meta Log Record 기록
     */
    if(sIsReplicatedTable == ID_TRUE)
    {
        IDE_TEST(qci::mManageReplicationCallback.mWriteTableMetaLog(
                                                                aStatement,
                                                                sOldPartOID,
                                                                sNewPartOID)
                 != IDE_SUCCESS);
    }

    // 메타 캐시 삭제
    (void)qcmPartition::destroyQcmPartitionInfo(sOldPartInfo);

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_CANNOT_WRITE_REPL_INFO)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_WRITE_REPL_INFO));
    }
    IDE_EXCEPTION_END;

    (void)qcmPartition::destroyQcmPartitionInfo( sNewPartInfo );

    return IDE_FAILURE;
}

IDE_RC qdbAlter::executeRowmovement( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *    PROJ-1502 PARTITIONED DISK TABLE
 *
 *
 * Implementation :
 *
 ***********************************************************************/

    qdTableParseTree    * sParseTree;
    qcmTableInfo        * sTableInfo        = NULL;
    UInt                  sTableID;
    smOID                 sTableOID;
    SChar               * sTrueFalse[2] = {(SChar*)"T", (SChar*)"F"};
    SChar               * sIsRowmovement;
    SChar               * sSqlStr;
    vSLong                sRowCnt;

    qcmPartitionInfoList * sAllPartInfoList = NULL;
    qcmPartitionInfoList * sOldPartInfoList = NULL;
    qcmPartitionInfoList * sNewPartInfoList = NULL;
    qcmTableInfo         * sNewTableInfo    = NULL;
    void                 * sNewTableHandle  = NULL;
    smSCN                  sNewSCN          = SM_SCN_INIT;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // 파티션드 테이블에 LOCK(X)
    IDE_TEST( qcm::validateAndLockTable(aStatement,
                                        sParseTree->tableHandle,
                                        sParseTree->tableSCN,
                                        SMI_TABLE_LOCK_X)
              != IDE_SUCCESS );

    sTableInfo = sParseTree->tableInfo;
    sTableID = sTableInfo->tableID;

    IDE_TEST( qcmPartition::getPartitionInfoList( aStatement,
                                                  QC_SMI_STMT( aStatement ),
                                                  QC_QMX_MEM( aStatement ),
                                                  sTableInfo->tableID,
                                                  & sAllPartInfoList )
              != IDE_SUCCESS );

    IDE_TEST( qcmPartition::validateAndLockPartitionInfoList( aStatement,
                                                              sAllPartInfoList,
                                                              SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                              SMI_TABLE_LOCK_X,
                                                              ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                                ID_ULONG_MAX :
                                                                smiGetDDLLockTimeOut() * 1000000 ) )
              != IDE_SUCCESS );

    // 예외 처리를 위하여, Lock을 잡은 후에 Partition List를 설정한다.
    sOldPartInfoList = sAllPartInfoList;

    if( sParseTree->partTable->partAttr->alterPart->alterType ==
        QD_ENABLE_ROW_MOVEMENT )
    {
        sIsRowmovement = sTrueFalse[0];
    }
    else if( sParseTree->partTable->partAttr->alterPart->alterType ==
             QD_DISABLE_ROW_MOVEMENT )
    {
        sIsRowmovement = sTrueFalse[1];
    }
    else
    {
        // TASK-3876 Code Sonar
        // 허용되지 않는 case
        IDE_ASSERT( 0 );
    }

    IDU_LIMITPOINT("qdbAlter::executeRowmovement::malloc");
    IDE_TEST(STRUCT_ALLOC_WITH_SIZE(aStatement->qmxMem,
                                    SChar,
                                    QD_MAX_SQL_LENGTH,
                                    &sSqlStr)
             != IDE_SUCCESS);

    // SYS_PART_TABLES_에서 ROW_MOVEMENT 값 수정
    idlOS::snprintf( sSqlStr, QD_MAX_SQL_LENGTH,
                     "UPDATE SYS_PART_TABLES_ "
                     "SET ROW_MOVEMENT = CHAR'%s' "
                     "WHERE TABLE_ID = INTEGER'%"ID_INT32_FMT"'",
                     sIsRowmovement,
                     sTableID );

    IDE_TEST(qcg::runDMLforDDL( QC_SMI_STMT( aStatement ),
                                sSqlStr,
                                & sRowCnt ) != IDE_SUCCESS);

    IDE_TEST_RAISE(sRowCnt != 1, ERR_META_CRASH);

    // rebuild tableInfo
    sTableOID = smiGetTableId(sTableInfo->tableHandle);

    // fix BUG-14394
    IDE_TEST(qdbCommon::updateTableSpecFromMeta(
                 aStatement,
                 sParseTree->userName,
                 sParseTree->tableName,
                 sTableID,
                 sTableOID,
                 sParseTree->tableInfo->columnCount,
                 sParseTree->tableInfo->parallelDegree )
             != IDE_SUCCESS);

    IDE_TEST(qcm::touchTable(QC_SMI_STMT( aStatement ),
                             sTableID,
                             SMI_TBSLV_DDL_DML )
             != IDE_SUCCESS);

    IDE_TEST(qcm::makeAndSetQcmTableInfo(
                 QC_SMI_STMT( aStatement ),
                 sTableID,
                 sTableOID) != IDE_SUCCESS);

    IDE_TEST( qcm::getTableInfoByID( aStatement,
                                     sTableID,
                                     & sNewTableInfo,
                                     & sNewSCN,
                                     & sNewTableHandle )
              != IDE_SUCCESS );

    IDE_TEST( qcmPartition::touchPartitionInfoList( QC_SMI_STMT( aStatement ),
                                                    sOldPartInfoList )
              != IDE_SUCCESS );

    IDE_TEST( qcmPartition::makeAndSetAndGetQcmPartitionInfoList( aStatement,
                                                                  sNewTableInfo,
                                                                  sOldPartInfoList,
                                                                  & sNewPartInfoList )
              != IDE_SUCCESS );

    (void)qcmPartition::destroyQcmPartitionInfoList( sOldPartInfoList );

    (void)qcm::destroyQcmTableInfo(sTableInfo);

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_META_CRASH)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QCM_META_CRASH));
    }

    IDE_EXCEPTION_END;

    (void)qcm::destroyQcmTableInfo( sNewTableInfo );
    (void)qcmPartition::destroyQcmPartitionInfoList( sNewPartInfoList );

    qcmPartition::restoreTempInfo( sTableInfo,
                                   sOldPartInfoList,
                                   NULL );

    return IDE_FAILURE;
}

IDE_RC qdbAlter::executeAddPartition( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *    PROJ-1502 PARTITIONED DISK TABLE
 *
 *
 * Implementation :
 *
 ***********************************************************************/

    qdTableParseTree        * sParseTree;
    qdPartitionAttribute    * sDstPartAttr;
    qcmTableInfo            * sTableInfo = NULL;
    qcmTableInfo            * sSrcPartInfo = NULL;
    qcmTableInfo            * sDstPartInfo = NULL;
    qcmTableInfo           ** sNewPartInfoArr = NULL;
    qcmPartitionInfoList    * sPartInfoList = NULL;
    qcmPartitionInfoList    * sSrcPartInfoList = NULL;
    UInt                      sDstPartCount;

    SChar                     sPartMinVal[1];
    SChar                     sPartMaxVal[1];
    UInt                      sDstPartOrder;

    UInt                    * sPartitionID;
    smOID                   * sNewPartitionOID = NULL;
    UInt                      i;
    UInt                      sFlag = 0;
    const void              * sIndexHandle;
    UInt                      sIndexCount = 0;
    smiColumnList           * sColumnListAtKey;
    smiSegAttr                sSegAttr;
    smiSegStorageAttr         sSegStoAttr;
    qdIndexTableList        * sIndexTable;
    qcmIndex                * sNewIndices = NULL;

    qcmTableInfo            * sNewTableInfo = NULL;
    void                    * sTableHandle;
    smOID                     sTableOID;
    smSCN                     sSCN;

    void                    * sDstPartHandle    = NULL;
    smSCN                     sDstPartSCN;
    SInt                      sTempMemType      = 0;
    SInt                      sTempVolType      = 0;
    SInt                      sCountMemType     = 0;
    SInt                      sCountVolType     = 0;
    UInt                      sPartType         = 0;

    qcmColumn               * sTempColumns = NULL;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;
    sDstPartAttr = sParseTree->partTable->partAttr;

    // 파티션드 테이블에 LOCK(X)
    IDE_TEST( qcm::validateAndLockTable(aStatement,
                                        sParseTree->tableHandle,
                                        sParseTree->tableSCN,
                                        SMI_TABLE_LOCK_X)
              != IDE_SUCCESS );

    // 모든 파티션에 LOCK(X)
    IDE_TEST( qcmPartition::validateAndLockPartitionInfoList( aStatement,
                                                              sParseTree->partTable->partInfoList,
                                                              SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                              SMI_TABLE_LOCK_X,
                                                              ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                                ID_ULONG_MAX :
                                                                smiGetDDLLockTimeOut() * 1000000 ) )
              != IDE_SUCCESS );

    // BUG-43292 DDL / DDL partiton 연산시 최신 viewSCN을 보지 못함
    IDE_TEST( smiStatement::setViewSCNOfAllStmt( QC_SMI_STMT( aStatement ) )
              != IDE_SUCCESS );

    // PROJ-1624 non-partitioned index
    IDE_TEST( qdx::validateAndLockIndexTableList( aStatement,
                                                  sParseTree->oldIndexTables,
                                                  SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                  SMI_TABLE_LOCK_X,
                                                  ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                    ID_ULONG_MAX :
                                                    smiGetDDLLockTimeOut() * 1000000 ) )
              != IDE_SUCCESS );
        
    sTableInfo = sParseTree->tableInfo;

    sSrcPartInfoList = sParseTree->partTable->partInfoList;

    for( sPartInfoList = sSrcPartInfoList, sDstPartCount = 1;
         sPartInfoList != NULL;
         sPartInfoList = sPartInfoList->next, sDstPartCount++ )
    {
        // Nothing to do.
    }

    IDU_LIMITPOINT("qdbAlter::executeAddPartition::malloc1");
    IDE_TEST(aStatement->qmxMem->cralloc(ID_SIZEOF(smOID) * sDstPartCount,
                                         (void**)&sNewPartitionOID)
             != IDE_SUCCESS);
    IDU_LIMITPOINT("qdbAlter::executeAddPartition::malloc2");
    IDE_TEST(aStatement->qmxMem->cralloc(ID_SIZEOF(UInt) * sDstPartCount,
                                         (void**)&sPartitionID)
             != IDE_SUCCESS);

    for( i = 0, sPartInfoList = sSrcPartInfoList;
         sPartInfoList != NULL;
         sPartInfoList = sPartInfoList->next, i++ )
    {
        sSrcPartInfo = sPartInfoList->partitionInfo;
        sPartType    = sSrcPartInfo->tableFlag & SMI_TABLE_TYPE_MASK;

        /* PROJ-2464 hybrid partitioned table 지원
         *  - Partition Info를 구성할 때에, Table Option을 Partitioned Table의 값으로 복제한다.
         *  - 따라서, PartInfo의 정보를 이용하지 않고, TBSID에 따라 적합한 값으로 조정해서 이용한다.
         */
        qdbCommon::adjustPhysicalAttr( sPartType,
                                       sTableInfo->segAttr,
                                       sTableInfo->segStoAttr,
                                       & sSegAttr,
                                       & sSegStoAttr,
                                       ID_TRUE /* aIsTable */ );

        /* BUG-45503 Table 생성 이후에 실패 시, Table Meta Cache의 Column 정보를 복구하지 않는 경우가 있습니다. */
        IDE_TEST( qcm::copyQcmColumns( QC_QMX_MEM( aStatement ),
                                       sSrcPartInfo->columns,
                                       & sTempColumns,
                                       sSrcPartInfo->columnCount )
                  != IDE_SUCCESS );

        // 원본 테이블의 Flag
        // 새로운 테이블도 같은 Flag를 가지게 된다.
        IDE_TEST(qdbCommon::createTableOnSM(aStatement,
                                            sTempColumns,
                                            sTableInfo->tableOwnerID,
                                            sTableInfo->tableID,
                                            sTableInfo->maxrows,
                                            sSrcPartInfo->TBSID,
                                            sSegAttr,
                                            sSegStoAttr,
                                            /* 원본 Table Flag를
                                               통째로 복사 =>
                                               MASK 비트를 모두 1로설정*/
                                            QDB_TABLE_ATTR_MASK_ALL,
                                            sTableInfo->tableFlag, /* Flag Value */
                                            sTableInfo->parallelDegree,
                                            &sNewPartitionOID[i])
                 != IDE_SUCCESS);

        // BUG-44814 ddl 구문 수행시 통계정보 복사를 해야함
        smiStatistics::copyTableStats( smiGetTable(sNewPartitionOID[i]), sSrcPartInfo->tableHandle, NULL, 0 );
        
        sPartitionID[i] = sSrcPartInfo->partitionID;

        IDE_TEST(qdbCommon::updatePartTableSpecFromMeta( aStatement,
                                                         sTableInfo->tableID,
                                                         sPartitionID[i],
                                                         sNewPartitionOID[i] )
                 != IDE_SUCCESS );
    }

    sPartMinVal[0] = '\0';
    sPartMaxVal[0] = '\0';
    sDstPartOrder = sDstPartCount - 1;

    // ---------------------------------------------
    // DstPart 생성 및 메타 정보 입력
    // ---------------------------------------------
    IDE_TEST( qdbCommon::createTablePartition( aStatement,
                                               sParseTree,
                                               sTableInfo,
                                               sDstPartAttr,
                                               sPartMinVal,
                                               sPartMaxVal,
                                               sDstPartOrder,
                                               & sPartitionID[i],
                                               & sNewPartitionOID[i] )
              != IDE_SUCCESS );

    // ---------------------------------------------
    // non-partitioned index 재생성
    // ---------------------------------------------
    
    // PROJ-1624 non-partitioned index
    if ( sParseTree->oldIndexTables != NULL )
    {
        IDE_DASSERT( sTableInfo->indexCount > 0 );
        
        IDE_TEST( aStatement->qmxMem->alloc(
                      ID_SIZEOF(qcmIndex) * sTableInfo->indexCount,
                      (void**)&sNewIndices)
                  != IDE_SUCCESS );

        idlOS::memcpy( sNewIndices,
                       sTableInfo->indices,
                       ID_SIZEOF(qcmIndex) * sTableInfo->indexCount );
        
        //---------------------------
        // drop old index tables
        //---------------------------
        
        // index table은 createIndex시 다시 생성되므로 meta를 위해 미리 지운다.
        for ( sIndexTable = sParseTree->oldIndexTables;
              sIndexTable != NULL;
              sIndexTable = sIndexTable->next )
        {
            IDE_TEST( qdx::dropIndexTable( aStatement,
                                           sIndexTable,
                                           ID_FALSE /* aIsDropTablespace */ )
                      != IDE_SUCCESS );
        }
        
        //---------------------------
        // create new index tables
        //---------------------------
        
        IDE_TEST( qdx::createIndexTableOfTable(
                      aStatement,
                      sTableInfo,
                      sNewIndices,
                      sParseTree->oldIndexTables,
                      &(sParseTree->newIndexTables) )
                  != IDE_SUCCESS );
        
        //---------------------------
        // update meta table
        //---------------------------
        
        IDE_TEST( qdx::updateIndexTableSpecFromMeta(
                      aStatement,
                      sTableInfo,
                      sNewIndices )
                  != IDE_SUCCESS );
    }
    else
    {
        /* BUG-44469 [qx] codesonar warning in QX, MT, ST */
        IDE_TEST_RAISE( sParseTree->newIndexTables != NULL, ERR_UNEXPECTED );
    }

    /* PROJ-2464 hybrid partitioned table 지원
     *  - Hash 인 경우에, 모든 Partition을 새로 구성하기 때문에, 기존의 Memory, Disk 매체의 구성을 확인한다.
     *  - DstPartAttr의 매체도 확인한다.
     */
    qdbCommon::getTableTypeCountInPartInfoList( NULL,
                                                sSrcPartInfoList,
                                                NULL,
                                                & sCountMemType,
                                                & sCountVolType );

    qdbCommon::getTableTypeCountInPartAttrList( NULL,
                                                sDstPartAttr,
                                                NULL,
                                                & sTempMemType,
                                                & sTempVolType );

    sCountMemType += sTempMemType;
    sCountVolType += sTempVolType;

    // ---------------------------------------------
    // DISK PARTITIONED TABLE 데이터 재구성
    // ---------------------------------------------
    /* PROJ-2464 hybrid partitioned table 지원
     *  - 매체 구성에 따라서 결정하도록 수정한다.
     *  - Index를 나중에 생성해야만 하는 매체가 존재하기 때문에, 매체에 따라서 moveRow하는 시점이 다르다.
     *  - 따라서, 두 매체를 모두 지니는 Partitioned는 한 매체의 방안으로 고정 시킨다.
     */
    if ( ( sCountMemType + sCountVolType ) == 0 )
    {
        IDE_TEST( qdbCommon::reorganizeForHashPartition(
                      aStatement,
                      sTableInfo,
                      sSrcPartInfoList,
                      sDstPartCount,
                      sNewPartitionOID,
                      sNewIndices,
                      sParseTree->newIndexTables )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing To Do */
    }

    // ---------------------------------------------
    // 인덱스 생성
    // ---------------------------------------------
    if( sTableInfo->indices != NULL )
    {
        for( i = 0, sPartInfoList = sSrcPartInfoList;
             sPartInfoList != NULL;
             sPartInfoList = sPartInfoList->next, i++ )
        {
            sSrcPartInfo = sPartInfoList->partitionInfo;

            for( sIndexCount = 0;
                 sIndexCount < sSrcPartInfo->indexCount;
                 sIndexCount++ )
            {
                // 인덱스 생성을 위한 flag
                sFlag = smiTable::getIndexInfo( sSrcPartInfo->indices[sIndexCount].indexHandle );
                sSegAttr = smiTable::getIndexSegAttr(sSrcPartInfo->indices[sIndexCount].indexHandle);
                sSegStoAttr = smiTable::getIndexSegStoAttr(sSrcPartInfo->indices[sIndexCount].indexHandle);

                // 인덱스 생성을 위한 키 컬럼 정보를 구한다.
                IDE_TEST( qdx::getKeyColumnList(
                              aStatement,
                              & sSrcPartInfo->indices[sIndexCount],
                              & sColumnListAtKey )
                          != IDE_SUCCESS );

                /* PROJ-2464 hybrid partitioned table 지원
                 *  - 관련내용 : PROJ-2433
                 */
                IDE_TEST( smiTable::createIndex(
                              aStatement->mStatistics,
                              QC_SMI_STMT( aStatement ),
                              sSrcPartInfo->indices[sIndexCount].TBSID,
                              smiGetTable( sNewPartitionOID[i]),
                              (SChar*)sSrcPartInfo->indices[sIndexCount].name,
                              sSrcPartInfo->indices[sIndexCount].indexId,
                              sSrcPartInfo->indices[sIndexCount].indexTypeId,
                              sColumnListAtKey,
                              sFlag,
                              QD_INDEX_DEFAULT_PARALLEL_DEGREE,
                              SMI_INDEX_BUILD_UNCOMMITTED_ROW_ENABLE,
                              sSegAttr,
                              sSegStoAttr,
                              0, /* BUG-42124 : direct key index는 partitioned table를 지원하지 않는다. */
                              & sIndexHandle )
                          != IDE_SUCCESS );

                // BUG-44814 ddl 구문 수행시 통계정보 복사를 해야함
                smiStatistics::copyIndexStats( sIndexHandle, sSrcPartInfo->indices[sIndexCount].indexHandle );
            }
        }

        /* PROJ-2464 hybrid partitioned table 지원
         *  1. Dst PartInfo를 만든다.
         *  2. Dst PartInfo를 가져온다.
         *  3. Dst Part의 Index를 생성한다.
         */
        /* 1. Dst PartInfo를 만든다. */
        IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo( QC_SMI_STMT( aStatement ),
                                                            sPartitionID[i],
                                                            sNewPartitionOID[i],
                                                            sTableInfo,
                                                            NULL )
                  != IDE_SUCCESS );

        /* 2. Dst PartInfo를 가져온다. */
        IDE_TEST( qcmPartition::getPartitionInfo( aStatement,
                                                  sTableInfo->tableID,
                                                  sDstPartAttr->tablePartName,
                                                  & sDstPartInfo,
                                                  & sDstPartSCN,
                                                  & sDstPartHandle )
                  != IDE_SUCCESS );

        /* 3. Dst Part의 Index를 생성한다. */
        IDE_TEST( qdx::createAllIndexOfTablePart( aStatement,
                                                  sTableInfo,
                                                  sDstPartInfo,
                                                  sDstPartAttr->alterPart->indexPartAttr )
                  != IDE_SUCCESS );
    }

    // ---------------------------------------------
    // PROJ-2334 PMT
    // MEMORY PARTITIONED TABLE 데이터 재구성
    // ---------------------------------------------
    /* PROJ-2464 hybrid partitioned table 지원
     *  - 매체 구성에 따라서 결정하도록 수정한다.
     *  - Index를 나중에 생성해야만 하는 매체가 존재하기 때문에, 매체에 따라서 moveRow하는 시점이 다르다.
     *  - 따라서, 두 매체를 모두 지니는 Partitioned는 한 매체의 방안으로 고정 시킨다.
     */
    if ( ( sCountMemType + sCountVolType ) != 0 )
    {
        IDE_TEST( qdbCommon::reorganizeForHashPartition(
                      aStatement,
                      sTableInfo,
                      sSrcPartInfoList,
                      sDstPartCount,
                      sNewPartitionOID,
                      sNewIndices,
                      sParseTree->newIndexTables )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing To Do */
    }
    
    for( sPartInfoList = sSrcPartInfoList;
         sPartInfoList != NULL;
         sPartInfoList = sPartInfoList->next )
    {
        sSrcPartInfo = sPartInfoList->partitionInfo;
        IDE_TEST( smiTable::dropTable( QC_SMI_STMT( aStatement ),
                                       sSrcPartInfo->tableHandle,
                                       SMI_TBSLV_DDL_DML )
                  != IDE_SUCCESS );
    }

    IDU_LIMITPOINT("qdbAlter::executeAddPartition::malloc3");
    IDE_TEST(aStatement->qmxMem->cralloc( ID_SIZEOF(qcmTableInfo*)
                                          * (sDstPartCount-1),
                                          (void**)&sNewPartInfoArr)
             != IDE_SUCCESS);

    // ---------------------------------------------
    // 메타 캐시 재생성
    // ---------------------------------------------

    // non-partitioned index의 변경으로 tableInfo를 재생성한다.
    sTableOID = smiGetTableId(sTableInfo->tableHandle);
    
    IDE_TEST(qcm::touchTable(QC_SMI_STMT( aStatement ),
                             sTableInfo->tableID,
                             SMI_TBSLV_DDL_DML )
             != IDE_SUCCESS);

    IDE_TEST(qcm::makeAndSetQcmTableInfo(
                 QC_SMI_STMT( aStatement ),
                 sTableInfo->tableID,
                 sTableOID)
             != IDE_SUCCESS);

    IDE_TEST(qcm::getTableInfoByID(aStatement,
                                   sTableInfo->tableID,
                                   &sNewTableInfo,
                                   &sSCN,
                                   &sTableHandle)
             != IDE_SUCCESS);
    
    for( i = 0, sPartInfoList = sSrcPartInfoList;
         sPartInfoList != NULL;
         sPartInfoList = sPartInfoList->next, i++ )
    {
        IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                      QC_SMI_STMT( aStatement ),
                      sPartitionID[i],
                      sNewPartitionOID[i],
                      sTableInfo,
                      NULL )
                  != IDE_SUCCESS );

        IDE_TEST( smiGetTableTempInfo( smiGetTable( sNewPartitionOID[i] ),
                                       (void**)&sNewPartInfoArr[i] )
                  != IDE_SUCCESS );
    }


    /* BUG-42399 [qx] [valgrind] QX valgrind warnings
     *  - Dst PartInfo의 Index를 생성하면서, Dst PartInfo 정보가 필요하여
     *    위에서 해당 Partition만 미리 makeAndSetQcmPartitionInfo를 수행하였다.
     *    따라서, 작업이 끝난 이 시점에서는 미리 생성한 캐시를 삭제하고 생성한다.
     *  - 관련내용 : PROJ-2464 hybrid partitioned table 지원
     */
    if ( sDstPartInfo != NULL )
    {
        (void)qcmPartition::destroyQcmPartitionInfo( sDstPartInfo );

        sDstPartInfo = NULL;
    }
    else
    {
        /* Nothing to do */
    }
    
    // 새로 ADD되는 파티션의 메타 캐시 생성
    IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                  QC_SMI_STMT( aStatement ),
                  sPartitionID[i],
                  sNewPartitionOID[i],
                  sTableInfo,
                  NULL )
              != IDE_SUCCESS );

    IDE_TEST( smiGetTableTempInfo( smiGetTable( sNewPartitionOID[i] ),
                                   (void**)&sDstPartInfo )
              != IDE_SUCCESS);

    // fix BUG-14394
    IDE_TEST(qdbCommon::updateTableSpecFromMeta(
                 aStatement,
                 sParseTree->userName,
                 sParseTree->tableName,
                 sParseTree->tableInfo->tableID,
                 smiGetTableId(sParseTree->tableInfo->tableHandle),
                 sParseTree->tableInfo->columnCount,
                 sParseTree->tableInfo->parallelDegree )
             != IDE_SUCCESS);

    IDE_TEST(qcmView::setInvalidViewOfRelated(
                 aStatement,
                 sParseTree->userID,
                 sTableInfo->name,
                 idlOS::strlen((SChar*)sTableInfo->name),
                 QS_TABLE) != IDE_SUCCESS);

    IDE_TEST(qcmView::recompileAndSetValidViewOfRelated(
                 aStatement,
                 sParseTree->userID,
                 sTableInfo->name,
                 idlOS::strlen((SChar*)sTableInfo->name),
                 QS_TABLE)
             != IDE_SUCCESS);

    (void)qcmPartition::destroyQcmPartitionInfoList( sSrcPartInfoList );

    for ( sIndexTable = sParseTree->oldIndexTables;
          sIndexTable != NULL;
          sIndexTable = sIndexTable->next )
    {
        (void)qcm::destroyQcmTableInfo(sIndexTable->tableInfo);
    }
    
    (void)qcm::destroyQcmTableInfo(sTableInfo);
    
    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_UNEXPECTED );
    IDE_SET( ideSetErrorCode( mtERR_ABORT_UNEXPECTED_ERROR,
                              "executeAddPartition",
                              "invalid newIndexTables" ) );
    IDE_EXCEPTION_END;

    if ( sNewPartInfoArr != NULL )
    {
        for( i = 0, sPartInfoList = sSrcPartInfoList;
             sPartInfoList != NULL;
             sPartInfoList = sPartInfoList->next, i++ )
        {
            (void)qcmPartition::destroyQcmPartitionInfo( sNewPartInfoArr[i] );
        }
    }

    for ( sIndexTable = sParseTree->newIndexTables;
          sIndexTable != NULL;
          sIndexTable = sIndexTable->next )
    {
        (void)qcm::destroyQcmTableInfo(sIndexTable->tableInfo);
    }
        
    // 추가된 파티션의 메타 캐시 제거
    if( sDstPartInfo != NULL )
    {
        (void)qcmPartition::destroyQcmPartitionInfo(sDstPartInfo);
    }

    (void)qcm::destroyQcmTableInfo( sNewTableInfo );

    // on fail, must restore temp info.
    qcmPartition::restoreTempInfo( sTableInfo,
                                   sSrcPartInfoList,
                                   NULL );
    
    return IDE_FAILURE;
}

IDE_RC qdbAlter::executeCoalescePartition( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *    PROJ-1502 PARTITIONED DISK TABLE
 *
 *    ALTER TABLE table_name COALESCE PARTITION; 구문의 execution
 *
 *    PartOrder가 가장 큰 파티션(마지막 파티션)을 병합하고 데이터를
 *    재구성한다.
 *
 *
 * Implementation :
 *    disk partitioned table, memory partitioned table 차이점.
 *    data 재구성 순서가 다르다.
 *    disk partitioned table은 data 재구성 후 index rebuild.
 *    memory partitioned table은 index rebuild 후 data 재구성.
 *
 ***********************************************************************/

    qdTableParseTree        * sParseTree;
    qcmTableInfo            * sTableInfo = NULL;
    qcmPartitionInfoList    * sSrcPartInfoList = NULL;
    qcmPartitionInfoList    * sPartInfoList = NULL;
    qcmTableInfo            * sSrcPartInfo = NULL;
    qcmTableInfo           ** sNewPartInfoArr = NULL;

    UInt                    * sPartitionID;
    smOID                   * sNewPartitionOID = NULL;
    UInt                      i = 0;
    UInt                      sFlag = 0;
    const void              * sIndexHandle;
    UInt                      sIndexCount = 0;
    UInt                      sDstPartCount = 0;
    smiColumnList           * sColumnListAtKey;
    smiSegAttr                sSegAttr;
    smiSegStorageAttr         sSegStoAttr;
    qdIndexTableList        * sIndexTable;
    qcmIndex                * sNewIndices = NULL;

    qcmTableInfo            * sNewTableInfo = NULL;
    void                    * sTableHandle;
    smOID                     sTableOID;
    smSCN                     sSCN;

    SInt                      sCountMemType     = 0;
    SInt                      sCountVolType     = 0;
    UInt                      sPartType         = 0;

    qcmColumn               * sTempColumns = NULL;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // BUG-43292 DDL / DDL partiton 연산시 최신 viewSCN을 보지 못함
    IDU_FIT_POINT( "qdbAlter::executeCoalescePartition::beforeXLock" );

    // 파티션드 테이블에 LOCK(X)
    IDE_TEST( qcm::validateAndLockTable(aStatement,
                                        sParseTree->tableHandle,
                                        sParseTree->tableSCN,
                                        SMI_TABLE_LOCK_X)
              != IDE_SUCCESS );

    // 모든 파티션에 LOCK(X)
    IDE_TEST( qcmPartition::validateAndLockPartitionInfoList( aStatement,
                                                              sParseTree->partTable->partInfoList,
                                                              SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                              SMI_TABLE_LOCK_X,
                                                              ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                                ID_ULONG_MAX :
                                                                smiGetDDLLockTimeOut() * 1000000 ) )
              != IDE_SUCCESS );

    // BUG-43292 DDL / DDL partiton 연산시 최신 viewSCN을 보지 못함
    IDE_TEST( smiStatement::setViewSCNOfAllStmt( QC_SMI_STMT( aStatement ) )
              != IDE_SUCCESS );

    // PROJ-1624 non-partitioned index
    IDE_TEST( qdx::validateAndLockIndexTableList( aStatement,
                                                  sParseTree->oldIndexTables,
                                                  SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                  SMI_TABLE_LOCK_X,
                                                  ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                    ID_ULONG_MAX :
                                                    smiGetDDLLockTimeOut() * 1000000 ) )
              != IDE_SUCCESS );

    sTableInfo = sParseTree->tableInfo;

    sSrcPartInfoList = sParseTree->partTable->partInfoList;

    IDE_DASSERT( sSrcPartInfoList->next != NULL );

    for( sPartInfoList = sSrcPartInfoList, sDstPartCount = 0;
         sPartInfoList->next != NULL;
         sPartInfoList = sPartInfoList->next, sDstPartCount++ )
    {
        // Nothing to do.
    }

    IDU_LIMITPOINT("qdbAlter::executeCoalescePartition::malloc1");
    IDE_TEST(aStatement->qmxMem->cralloc(ID_SIZEOF(smOID) * sDstPartCount,
                                         (void**)&sNewPartitionOID)
             != IDE_SUCCESS);
    IDU_LIMITPOINT("qdbAlter::executeCoalescePartition::malloc2");
    IDE_TEST(aStatement->qmxMem->cralloc(ID_SIZEOF(UInt) * sDstPartCount,
                                         (void**)&sPartitionID)
             != IDE_SUCCESS);

    // ---------------------------------------------
    // OUT-PLACE ADD를 위한 새로운 파티션 생성
    // ---------------------------------------------
    for( i = 0, sPartInfoList = sSrcPartInfoList;
         sPartInfoList->next != NULL;
         sPartInfoList = sPartInfoList->next, i++ )
    {
        sSrcPartInfo = sPartInfoList->partitionInfo;
        sPartType    = sSrcPartInfo->tableFlag & SMI_TABLE_TYPE_MASK;

        /* PROJ-2464 hybrid partitioned table 지원
         *  - Partition Info를 구성할 때에, Table Option을 Partitioned Table의 값으로 복제한다.
         *  - 따라서, PartInfo의 정보를 이용하지 않고, TBSID에 따라 적합한 값으로 조정해서 이용한다.
         */
        qdbCommon::adjustPhysicalAttr( sPartType,
                                       sTableInfo->segAttr,
                                       sTableInfo->segStoAttr,
                                       & sSegAttr,
                                       & sSegStoAttr,
                                       ID_TRUE /* aIsTable */ );

        /* BUG-45503 Table 생성 이후에 실패 시, Table Meta Cache의 Column 정보를 복구하지 않는 경우가 있습니다. */
        IDE_TEST( qcm::copyQcmColumns( QC_QMX_MEM( aStatement ),
                                       sSrcPartInfo->columns,
                                       & sTempColumns,
                                       sSrcPartInfo->columnCount )
                  != IDE_SUCCESS );

        // 원본 테이블의 Flag
        // 새로운 테이블도 같은 Flag를 가지게 된다.
        IDE_TEST(qdbCommon::createTableOnSM(aStatement,
                                            sTempColumns,
                                            sTableInfo->tableOwnerID,
                                            sTableInfo->tableID,
                                            sTableInfo->maxrows,
                                            sSrcPartInfo->TBSID,
                                            sSegAttr,
                                            sSegStoAttr,
                                            /* 원본 Table Flag를
                                               통째로 복사 =>
                                               MASK 비트를 모두 1로설정*/
                                            QDB_TABLE_ATTR_MASK_ALL,
                                            sTableInfo->tableFlag, /* Flag Value */
                                            sTableInfo->parallelDegree,
                                            &sNewPartitionOID[i])
                 != IDE_SUCCESS);

        // BUG-44814 ddl 구문 수행시 통계정보 복사를 해야함
        smiStatistics::copyTableStats( smiGetTable(sNewPartitionOID[i]), sSrcPartInfo->tableHandle, NULL, 0 );

        sPartitionID[i] = sSrcPartInfo->partitionID;

        IDE_TEST(qdbCommon::updatePartTableSpecFromMeta( aStatement,
                                                         sTableInfo->tableID,
                                                         sPartitionID[i],
                                                         sNewPartitionOID[i] )
                 != IDE_SUCCESS );
    }

    // ---------------------------------------------
    // non-partitioned index 재생성
    // ---------------------------------------------
    
    // PROJ-1624 non-partitioned index
    if ( sParseTree->oldIndexTables != NULL )
    {
        IDE_DASSERT( sTableInfo->indexCount > 0 );
        
        IDE_TEST( aStatement->qmxMem->alloc(
                      ID_SIZEOF(qcmIndex) * sTableInfo->indexCount,
                      (void**)&sNewIndices)
                  != IDE_SUCCESS );

        idlOS::memcpy( sNewIndices,
                       sTableInfo->indices,
                       ID_SIZEOF(qcmIndex) * sTableInfo->indexCount );
        
        //---------------------------
        // drop old index tables
        //---------------------------
        
        // index table은 createIndex시 다시 생성되므로 meta를 위해 미리 지운다.
        for ( sIndexTable = sParseTree->oldIndexTables;
              sIndexTable != NULL;
              sIndexTable = sIndexTable->next )
        {
            IDE_TEST( qdx::dropIndexTable( aStatement,
                                           sIndexTable,
                                           ID_FALSE /* aIsDropTablespace */ )
                      != IDE_SUCCESS );
        }
        
        //---------------------------
        // create new index tables
        //---------------------------
        
        IDE_TEST( qdx::createIndexTableOfTable(
                      aStatement,
                      sTableInfo,
                      sNewIndices,
                      sParseTree->oldIndexTables,
                      &(sParseTree->newIndexTables) )
                  != IDE_SUCCESS );
        
        //---------------------------
        // update meta table
        //---------------------------
        
        IDE_TEST( qdx::updateIndexTableSpecFromMeta(
                      aStatement,
                      sTableInfo,
                      sNewIndices )
                  != IDE_SUCCESS );
    }
    else
    {
        // Nothing to do.
    }

    /* PROJ-2464 hybrid partitioned table 지원
     *  - Hash 인 경우에, 모든 Partition을 새로 구성하기 때문에, 기존의 Memory, Disk 매체의 구성을 확인한다.
     */
    qdbCommon::getTableTypeCountInPartInfoList( NULL,
                                                sSrcPartInfoList,
                                                NULL,
                                                & sCountMemType,
                                                & sCountVolType );

    // ---------------------------------------------
    // DISK PARTITIONED TABLE 데이터 재구성
    // ---------------------------------------------
    /* PROJ-2464 hybrid partitioned table 지원
     *  - 매체 구성에 따라서 결정하도록 수정한다.
     *  - Index를 나중에 생성해야만 하는 매체가 존재하기 때문에, 매체에 따라서 moveRow하는 시점이 다르다.
     *  - 따라서, 두 매체를 모두 지니는 Partitioned는 한 매체의 방안으로 고정 시킨다.
     */
    if ( ( sCountMemType + sCountVolType ) == 0 )
    {
        IDE_TEST( qdbCommon::reorganizeForHashPartition(
                      aStatement,
                      sTableInfo,
                      sSrcPartInfoList,
                      sDstPartCount,
                      sNewPartitionOID,
                      sNewIndices,
                      sParseTree->newIndexTables )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing To Do */
    }

    // ---------------------------------------------
    // 인덱스 생성
    // ---------------------------------------------
    if( sTableInfo->indices != NULL )
    {
        for( i = 0, sPartInfoList = sSrcPartInfoList;
             sPartInfoList->next != NULL;
             sPartInfoList = sPartInfoList->next, i++ )
        {
            sSrcPartInfo = sPartInfoList->partitionInfo;

            for( sIndexCount = 0;
                 sIndexCount < sSrcPartInfo->indexCount;
                 sIndexCount++ )
            {
                // 인덱스 생성을 위한 flag
                sFlag = smiTable::getIndexInfo( sSrcPartInfo->indices[sIndexCount].indexHandle );
                sSegAttr = smiTable::getIndexSegAttr(sSrcPartInfo->indices[sIndexCount].indexHandle);
                sSegStoAttr = smiTable::getIndexSegStoAttr(sSrcPartInfo->indices[sIndexCount].indexHandle);

                // 인덱스 생성을 위한 키 컬럼 정보를 구한다.
                IDE_TEST( qdx::getKeyColumnList(
                              aStatement,
                              & sSrcPartInfo->indices[sIndexCount],
                              & sColumnListAtKey )
                          != IDE_SUCCESS );

                /* PROJ-2464 hybrid partitioned table 지원
                 *  - 관련내용 : PROJ-2433
                 */
                IDE_TEST( smiTable::createIndex(
                              aStatement->mStatistics,
                              QC_SMI_STMT( aStatement ),
                              sSrcPartInfo->indices[sIndexCount].TBSID,
                              smiGetTable( sNewPartitionOID[i]),
                              (SChar*)sSrcPartInfo->indices[sIndexCount].name,
                              sSrcPartInfo->indices[sIndexCount].indexId,
                              sSrcPartInfo->indices[sIndexCount].indexTypeId,
                              sColumnListAtKey,
                              sFlag,
                              QD_INDEX_DEFAULT_PARALLEL_DEGREE,
                              SMI_INDEX_BUILD_UNCOMMITTED_ROW_ENABLE,
                              sSegAttr,
                              sSegStoAttr,
                              0, /* BUG-42124 : direct key index는 partitioned table를 지원하지 않는다. */
                              & sIndexHandle )
                          != IDE_SUCCESS );
                
                // BUG-44814 ddl 구문 수행시 통계정보 복사를 해야함
                smiStatistics::copyIndexStats( sIndexHandle, sSrcPartInfo->indices[sIndexCount].indexHandle );
            }
        }
    }

    // ---------------------------------------------
    // PROJ-2334 PMT
    // MEMORY PARTITIONED TABLE 데이터 재구성
    // ---------------------------------------------
    /* PROJ-2464 hybrid partitioned table 지원
     *  - 매체 구성에 따라서 결정하도록 수정한다.
     *  - Index를 나중에 생성해야만 하는 매체가 존재하기 때문에, 매체에 따라서 moveRow하는 시점이 다르다.
     *  - 따라서, 두 매체를 모두 지니는 Partitioned는 한 매체의 방안으로 고정 시킨다.
     */
    if ( ( sCountMemType + sCountVolType ) != 0 )
    {
        IDE_TEST( qdbCommon::reorganizeForHashPartition(
                      aStatement,
                      sTableInfo,
                      sSrcPartInfoList,
                      sDstPartCount,
                      sNewPartitionOID,
                      sNewIndices,
                      sParseTree->newIndexTables )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing To Do */
    }
    for( sPartInfoList = sSrcPartInfoList;
         sPartInfoList->next != NULL;
         sPartInfoList = sPartInfoList->next )
    {
        sSrcPartInfo = sPartInfoList->partitionInfo;
        IDE_TEST( smiTable::dropTable( QC_SMI_STMT( aStatement ),
                                       sSrcPartInfo->tableHandle,
                                       SMI_TBSLV_DDL_DML )
                  != IDE_SUCCESS );
    }

    // ------------------------------------------------
    // 메타 테이블에서 해당 파티션에 관련된 정보 삭제
    // 파티션 삭제
    // ------------------------------------------------
    sSrcPartInfo = sPartInfoList->partitionInfo;
    IDE_TEST(qdd::dropTablePartition( aStatement,
                                      sSrcPartInfo,
                                      ID_FALSE, /* aIsDropTablespace */
                                      ID_FALSE )
             != IDE_SUCCESS );

    IDU_LIMITPOINT("qdbAlter::executeCoalescePartition::malloc3");
    IDE_TEST(aStatement->qmxMem->cralloc( ID_SIZEOF(qcmTableInfo*)
                                          * (sDstPartCount+1),
                                          (void**)&sNewPartInfoArr)
             != IDE_SUCCESS);

    // ---------------------------------------------
    // 메타 캐시 재생성(DstPart)
    // ---------------------------------------------
    
    // non-partitioned index의 변경으로 tableInfo를 재생성한다.
    sTableOID = smiGetTableId(sTableInfo->tableHandle);
    
    IDE_TEST(qcm::touchTable(QC_SMI_STMT( aStatement ),
                             sTableInfo->tableID,
                             SMI_TBSLV_DDL_DML )
             != IDE_SUCCESS);

    IDE_TEST(qcm::makeAndSetQcmTableInfo(
                 QC_SMI_STMT( aStatement ),
                 sTableInfo->tableID,
                 sTableOID)
             != IDE_SUCCESS);

    IDE_TEST(qcm::getTableInfoByID(aStatement,
                                   sTableInfo->tableID,
                                   &sNewTableInfo,
                                   &sSCN,
                                   &sTableHandle)
             != IDE_SUCCESS);
    
    for( i = 0, sPartInfoList = sSrcPartInfoList;
         sPartInfoList->next != NULL;
         sPartInfoList = sPartInfoList->next, i++ )
    {
        IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                      QC_SMI_STMT( aStatement ),
                      sPartitionID[i],
                      sNewPartitionOID[i],
                      sTableInfo,
                      NULL )
                  != IDE_SUCCESS );

        IDE_TEST( smiGetTableTempInfo( smiGetTable( sNewPartitionOID[i] ),
                                       (void**)&sNewPartInfoArr[i] )
                  != IDE_SUCCESS );
    }

    // fix BUG-14394
    IDE_TEST(qdbCommon::updateTableSpecFromMeta(
                 aStatement,
                 sParseTree->userName,
                 sParseTree->tableName,
                 sParseTree->tableInfo->tableID,
                 smiGetTableId(sParseTree->tableInfo->tableHandle),
                 sParseTree->tableInfo->columnCount,
                 sParseTree->tableInfo->parallelDegree )
             != IDE_SUCCESS);

    IDE_TEST(qcmView::setInvalidViewOfRelated(
                 aStatement,
                 sParseTree->userID,
                 sTableInfo->name,
                 idlOS::strlen((SChar*)sTableInfo->name),
                 QS_TABLE) != IDE_SUCCESS);

    IDE_TEST(qcmView::recompileAndSetValidViewOfRelated(
                 aStatement,
                 sParseTree->userID,
                 sTableInfo->name,
                 idlOS::strlen((SChar*)sTableInfo->name),
                 QS_TABLE)
             != IDE_SUCCESS);

    // ---------------------------------------------
    // 메타 캐시 삭제
    // ---------------------------------------------
    (void)qcmPartition::destroyQcmPartitionInfoList( sSrcPartInfoList );

    for ( sIndexTable = sParseTree->oldIndexTables;
          sIndexTable != NULL;
          sIndexTable = sIndexTable->next )
    {
        (void)qcm::destroyQcmTableInfo(sIndexTable->tableInfo);
    }
    
    (void)qcm::destroyQcmTableInfo(sTableInfo);
    
    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    // 메타 캐시 삭제 및 원복
    if ( sNewPartInfoArr != NULL )
    {
        for( i = 0, sPartInfoList = sSrcPartInfoList;
             sPartInfoList != NULL;
             sPartInfoList = sPartInfoList->next, i++ )
        {
            (void)qcmPartition::destroyQcmPartitionInfo( sNewPartInfoArr[i] );
        }
    }

    for ( sIndexTable = sParseTree->newIndexTables;
          sIndexTable != NULL;
          sIndexTable = sIndexTable->next )
    {
        (void)qcm::destroyQcmTableInfo(sIndexTable->tableInfo);
    }
    
    (void)qcm::destroyQcmTableInfo( sNewTableInfo );

    // on fail, must restore temp info.
    qcmPartition::restoreTempInfo( sTableInfo,
                                   sSrcPartInfoList,
                                   NULL );
    
    return IDE_FAILURE;
}

IDE_RC qdbAlter::makeNewRow(qcTemplate        * aTemplate,
                            qcmTableInfo      * aTableInfo,
                            qcmColumn         * aSrcTblColumn,
                            qcmColumn         * aDstTblColumn,
                            const void        * aOldRow,
                            smiValue          * aNewRow,
                            smiTableCursor    * aSrcTblCursor,
                            scGRID              aRowGRID,
                            qmxLobInfo        * aLobInfo,
                            qdbConvertContext * aConvertContextList)
{
/***********************************************************************
 *
 * 이 함수는 디스크 테이블에 대해서만 호출됨.
 *
 **********************************************************************/

    SInt                sColumnOrder;
    qcmColumn         * sDestCol;
    qcmColumn         * sSrcCol;
    mtvConvert        * sConvert;
    mtcColumn         * sValueColumn;
    void              * sValue;
    void              * sCanonizedValue;
    smLobLocator        sLocator = MTD_LOCATOR_NULL;
    UInt                sInfo = 0;
    qdbConvertContext * sConvertContext;
    UInt                sStoringSize = 0;
    void              * sStoringValue;

    sConvertContext = aConvertContextList;
    sDestCol = aDstTblColumn;
    sInfo = MTC_LOB_LOCATOR_CLOSE_TRUE;

    while (sDestCol != NULL)
    {
        sColumnOrder = (sDestCol->basicInfo->column.id & SMI_COLUMN_ID_MASK);
        sSrcCol = aSrcTblColumn;
        while (sSrcCol != NULL)
        {
            if ( idlOS::strMatch( sSrcCol->name,
                                  idlOS::strlen( sSrcCol->name ),
                                  sDestCol->name,
                                  idlOS::strlen( sDestCol->name ) ) == 0 )
            {
                break;
            }
            else
            {
                sSrcCol = sSrcCol->next;
            }
        }

        if (sSrcCol != NULL)
        {
            if ((sSrcCol->basicInfo->column.flag & SMI_COLUMN_TYPE_MASK)
                == SMI_COLUMN_TYPE_LOB)
            {
                // PROJ-1362

                // SrcCol과 DestCol은 동일 type이다.
                IDE_DASSERT( sSrcCol->basicInfo->type.dataTypeId
                             == sDestCol->basicInfo->type.dataTypeId );
                
                if( SMI_GRID_IS_VIRTUAL_NULL(aRowGRID) )
                {
                    // GRID가 virtual null인 경우.
                    // Nothing to do.
                }
                else
                {
                    if ( smiIsNullLobColumn(aOldRow, &sSrcCol->basicInfo->column)
                         == ID_TRUE )
                    {
                        // Nothing to do.
                    }
                    else
                    {
                        /* PROJ-2334 PMT */
                        if ( (sSrcCol->basicInfo->column.flag & SMI_COLUMN_STORAGE_MASK)
                             == SMI_COLUMN_STORAGE_MEMORY )
                        {
                            IDE_TEST( smiLob::openLobCursorWithRow(
                                          aSrcTblCursor,
                                          (void*)aOldRow,
                                          & sSrcCol->basicInfo->column,
                                          sInfo,
                                          SMI_LOB_READ_MODE,
                                          & sLocator )
                                      != IDE_SUCCESS );
                        }
                        else
                        {
                            // null이 아닌 것만
                            //fix BUG-19687
                            IDE_TEST( smiLob::openLobCursorWithGRID(
                                          aSrcTblCursor,
                                          aRowGRID,
                                          & sSrcCol->basicInfo->column,
                                          sInfo,
                                          SMI_LOB_READ_MODE,
                                          & sLocator )
                                      != IDE_SUCCESS );
                        }
                        
                        IDE_TEST( qmx::addLobInfoForCopy(
                                      aLobInfo,
                                      & sDestCol->basicInfo->column,
                                      sLocator)
                                  != IDE_SUCCESS );

                        sLocator = MTD_LOCATOR_NULL;
                    }
                }

                // null을 저장한다.
                aNewRow[sColumnOrder].value = NULL;
                aNewRow[sColumnOrder].length = 0;
            }
            else
            {
                sValueColumn = sSrcCol->basicInfo;
                sValue       = (void*) mtc::value( sSrcCol->basicInfo,
                                                   aOldRow,
                                                   MTD_OFFSET_USE );

                if ( aConvertContextList != NULL )
                {
                    //-------------------------------------------------
                    // type 변환이 필요한 경우 (conversion이 필요한 경우)
                    //
                    // a. modify decrypt의 경우
                    // b. modify encrypt의 경우
                    // c. data type의 변환
                    // d. length 변환
                    //-------------------------------------------------

                    while ( 1 )
                    {
                        //-----------------------------------------
                        // a. modify decrypt (echar->char, evarchar->varchar)
                        //-----------------------------------------

                        if ( sConvertContext->needDecrypt == ID_TRUE )
                        {
                            //-------------------------------
                            // 1. decrypt
                            //-------------------------------

                            IDE_DASSERT( sConvertContext->encBuf != NULL );

                            sColumnOrder = sValueColumn->column.id & SMI_COLUMN_ID_MASK;

                            IDE_TEST( qcsModule::decryptColumn(
                                          aTemplate->stmt,
                                          aTableInfo,
                                          sColumnOrder,
                                          sValueColumn,
                                          sValue,
                                          sDestCol->basicInfo,
                                          sConvertContext->encBuf )
                                      != IDE_SUCCESS );

                            sValueColumn = sDestCol->basicInfo;
                            sValue       = sConvertContext->encBuf;

                            //-------------------------------
                            // 2. assign
                            //-------------------------------

                            // PROJ-1877
                            // alter table modify colum 기능으로 type이나 length를 변경시
                            // null이 아닌 value가 null로 변경되는 경우가 있어서는 안된다.
                            // 만일 이런 경우가 있다면 not null constraint가 있는 컬럼에
                            // 대하여 type이나 length 변경후 value가 null이 된다면 이를
                            // 검사하여 에러처리해야 한다.
                            // 다행히도 현재까지는 이런 경우가 없다. default_date_format을
                            // 이용하는 varchar->date의 경우도 default_date_format을 ''로
                            // 설정할 수 없기 때문에 문제가 발생하지 않는다.

                            // PROJ-1705
                            IDE_TEST( qdbCommon::mtdValue2StoringValue(
                                          sDestCol->basicInfo,
                                          sValueColumn,
                                          (void*)sValue,
                                          &sStoringValue )
                                      !=IDE_SUCCESS );
                            aNewRow[sColumnOrder].value = sStoringValue;

                            IDE_TEST( qdbCommon::storingSize(
                                          sDestCol->basicInfo,
                                          sValueColumn,
                                          (void*)sValue,
                                          &sStoringSize )
                                      != IDE_SUCCESS );
                            aNewRow[sColumnOrder].length = sStoringSize;

                            break;
                        }
                        else
                        {
                            // Nothing to do.
                        }

                        //-----------------------------------------
                        // b. modify encrypt (char->echar, varchar->evarchar)
                        //-----------------------------------------

                        if ( sConvertContext->needEncrypt == ID_TRUE )
                        {
                            //-------------------------------
                            // 1. encrypt
                            //-------------------------------

                            IDE_DASSERT( sConvertContext->encBuf != NULL );

                            sColumnOrder = sValueColumn->column.id & SMI_COLUMN_ID_MASK;

                            IDE_TEST( qcsModule::encryptColumn(
                                          aTemplate->stmt,
                                          aTableInfo,
                                          sColumnOrder,
                                          sValueColumn,
                                          sValue,
                                          sDestCol->basicInfo,
                                          sConvertContext->encBuf )
                                      != IDE_SUCCESS );

                            sValueColumn = sDestCol->basicInfo;
                            sValue       = sConvertContext->encBuf;

                            //-------------------------------
                            // 2. assign
                            //-------------------------------

                            // PROJ-1877
                            // alter table modify colum 기능으로 type이나 length를 변경시
                            // null이 아닌 value가 null로 변경되는 경우가 있어서는 안된다.
                            // 만일 이런 경우가 있다면 not null constraint가 있는 컬럼에
                            // 대하여 type이나 length 변경후 value가 null이 된다면 이를
                            // 검사하여 에러처리해야 한다.
                            // 다행히도 현재까지는 이런 경우가 없다. default_date_format을
                            // 이용하는 varchar->date의 경우도 default_date_format을 ''로
                            // 설정할 수 없기 때문에 문제가 발생하지 않는다.

                            // PROJ-1705
                            IDE_TEST( qdbCommon::mtdValue2StoringValue(
                                          sDestCol->basicInfo,
                                          sValueColumn,
                                          (void*)sValue,
                                          &sStoringValue )
                                      != IDE_SUCCESS );
                            aNewRow[sColumnOrder].value = sStoringValue;

                            IDE_TEST( qdbCommon::storingSize( sDestCol->basicInfo,
                                                              sValueColumn,
                                                              (void*)sValue,
                                                              &sStoringSize )
                                      != IDE_SUCCESS );
                            aNewRow[sColumnOrder].length = sStoringSize;

                            break;
                        }
                        else
                        {
                            // Nothing to do.
                        }

                        //-----------------------------------------
                        // c. data type 변환
                        //-----------------------------------------

                        if ( (sConvertContext->needConvert == ID_TRUE) &&
                             (sConvertContext->needCanonize == ID_TRUE) )
                        {
                            //-------------------------------
                            // 1. conversion
                            //-------------------------------

                            IDE_DASSERT( sConvertContext->convert != NULL );

                            sConvert = sConvertContext->convert;

                            // source value pointer
                            sConvert->stack[sConvert->count].value = sValue;

                            // destination value pointer
                            sValueColumn = sConvert->stack[0].column;
                            sValue       = sConvert->stack[0].value;

                            IDE_TEST( mtv::executeConvert( sConvert,
                                                           & aTemplate->tmplate )
                                      != IDE_SUCCESS );

                            //-------------------------------
                            // 2. canonize (without echar, evarchar)
                            //-------------------------------

                            if ( ( sDestCol->basicInfo->module->flag & MTD_CANON_MASK )
                                 == MTD_CANON_NEED )
                            {
                                sCanonizedValue = sValue;

                                IDE_TEST( sDestCol->basicInfo->module->canonize(
                                              sDestCol->basicInfo,
                                              & sCanonizedValue,  // canonized value
                                              NULL,
                                              sValueColumn,
                                              sValue,            // original value
                                              NULL,
                                              & aTemplate->tmplate )
                                          != IDE_SUCCESS );

                                sValue = sCanonizedValue;
                            }
                            else if ( (sDestCol->basicInfo->module->flag & MTD_CANON_MASK)
                                      == MTD_CANON_NEED_WITH_ALLOCATION )
                            {
                                IDE_DASSERT( sConvertContext->canonBuf != NULL );

                                sCanonizedValue = sConvertContext->canonBuf;

                                IDE_TEST( sDestCol->basicInfo->module->canonize(
                                              sDestCol->basicInfo,
                                              & sCanonizedValue,  // canonized value
                                              NULL,
                                              sValueColumn,
                                              sValue,            // original value
                                              NULL,
                                              & aTemplate->tmplate )
                                          != IDE_SUCCESS );

                                sValue = sCanonizedValue;
                            }
                            else
                            {
                                // Nothing to do.
                            }

                            //-------------------------------
                            // 3. assign
                            //-------------------------------

                            // PROJ-1877
                            // alter table modify colum 기능으로 type이나 length를 변경시
                            // null이 아닌 value가 null로 변경되는 경우가 있어서는 안된다.
                            // 만일 이런 경우가 있다면 not null constraint가 있는 컬럼에
                            // 대하여 type이나 length 변경후 value가 null이 된다면 이를
                            // 검사하여 에러처리해야 한다.
                            // 다행히도 현재까지는 이런 경우가 없다. default_date_format을
                            // 이용하는 varchar->date의 경우도 default_date_format을 ''로
                            // 설정할 수 없기 때문에 문제가 발생하지 않는다.

                            // PROJ-1705
                            IDE_TEST( qdbCommon::mtdValue2StoringValue(
                                          sDestCol->basicInfo,
                                          sValueColumn,
                                          (void*)sValue,
                                          &sStoringValue )
                                      != IDE_SUCCESS );
                            aNewRow[sColumnOrder].value = sStoringValue;

                            IDE_TEST( qdbCommon::storingSize( sDestCol->basicInfo,
                                                              sValueColumn,
                                                              (void*)sValue,
                                                              &sStoringSize )
                                      != IDE_SUCCESS );
                            aNewRow[sColumnOrder].length = sStoringSize;

                            break;
                        }

                        //-------------------------------------------------
                        // d. length 변환이 필요한 경우 (canonize가 필요한 경우)
                        //-------------------------------------------------

                        if ( (sConvertContext->needConvert == ID_FALSE) &&
                             (sConvertContext->needCanonize == ID_TRUE) )
                        {
                            //-------------------------------
                            // 1. canonize
                            //-------------------------------

                            if ( ( sDestCol->basicInfo->module->flag & MTD_CANON_MASK )
                                 == MTD_CANON_NEED )
                            {
                                sCanonizedValue = sValue;

                                IDE_TEST( sDestCol->basicInfo->module->canonize(
                                              sDestCol->basicInfo,
                                              & sCanonizedValue,  // canonized value
                                              NULL,
                                              sValueColumn,
                                              sValue,            // original value
                                              NULL,
                                              & aTemplate->tmplate )
                                          != IDE_SUCCESS );

                                sValue = sCanonizedValue;
                            }
                            else if ( (sDestCol->basicInfo->module->flag & MTD_CANON_MASK)
                                      == MTD_CANON_NEED_WITH_ALLOCATION )
                            {
                                IDE_DASSERT( sConvertContext->canonBuf != NULL );

                                sCanonizedValue = sConvertContext->canonBuf;

                                IDE_TEST( sDestCol->basicInfo->module->canonize(
                                              sDestCol->basicInfo,
                                              & sCanonizedValue,  // canonized value
                                              NULL,
                                              sValueColumn,
                                              sValue,            // original value
                                              NULL,
                                              & aTemplate->tmplate )
                                          != IDE_SUCCESS );

                                sValue = sCanonizedValue;
                            }
                            else
                            {
                                // Nothing to do.
                            }

                            //-------------------------------
                            // 2. assign
                            //-------------------------------

                            // PROJ-1877
                            // alter table modify colum 기능으로 type이나 length를 변경시
                            // null이 아닌 value가 null로 변경되는 경우가 있어서는 안된다.
                            // 만일 이런 경우가 있다면 not null constraint가 있는 컬럼에
                            // 대하여 type이나 length 변경후 value가 null이 된다면 이를
                            // 검사하여 에러처리해야 한다.
                            // 다행히도 현재까지는 이런 경우가 없다. default_date_format을
                            // 이용하는 varchar->date의 경우도 default_date_format을 ''로
                            // 설정할 수 없기 때문에 문제가 발생하지 않는다.

                            // PROJ-1705
                            IDE_TEST( qdbCommon::mtdValue2StoringValue(
                                          sDestCol->basicInfo,
                                          sValueColumn,
                                          (void*)sValue,
                                          &sStoringValue )
                                      != IDE_SUCCESS );
                            aNewRow[sColumnOrder].value = sStoringValue;

                            IDE_TEST( qdbCommon::storingSize( sDestCol->basicInfo,
                                                              sValueColumn,
                                                              (void*)sValue,
                                                              &sStoringSize )
                                      != IDE_SUCCESS );
                            aNewRow[sColumnOrder].length = sStoringSize;

                            break;
                        }
                        else
                        {
                            // Nothing to do.
                        }

                        //-------------------------------------------------
                        // 그대로 복사하는 경우
                        //-------------------------------------------------

                        //-------------------------------
                        // 1. assign
                        //-------------------------------

                        // PROJ-1877
                        // alter table modify colum 기능으로 type이나 length를 변경시
                        // null이 아닌 value가 null로 변경되는 경우가 있어서는 안된다.
                        // 만일 이런 경우가 있다면 not null constraint가 있는 컬럼에
                        // 대하여 type이나 length 변경후 value가 null이 된다면 이를
                        // 검사하여 에러처리해야 한다.
                        // 다행히도 현재까지는 이런 경우가 없다. default_date_format을
                        // 이용하는 varchar->date의 경우도 default_date_format을 ''로
                        // 설정할 수 없기 때문에 문제가 발생하지 않는다.

                        // PROJ-1705
                        IDE_TEST( qdbCommon::mtdValue2StoringValue(
                                      sDestCol->basicInfo,
                                      sValueColumn,
                                      (void*)sValue,
                                      &sStoringValue )
                                  != IDE_SUCCESS );
                        aNewRow[sColumnOrder].value = sStoringValue;

                        IDE_TEST( qdbCommon::storingSize( sDestCol->basicInfo,
                                                          sValueColumn,
                                                          (void*)sValue,
                                                          &sStoringSize )
                                  != IDE_SUCCESS );
                        aNewRow[sColumnOrder].length = sStoringSize;

                        break;
                    }
                }
                else /* aConvertContextList == NULL */
                {
                    //-------------------------------------------------
                    // 그대로 복사하는 경우
                    //-------------------------------------------------

                    //-------------------------------
                    // 1. assign
                    //-------------------------------

                    // PROJ-1877
                    // alter table modify colum 기능으로 type이나 length를 변경시
                    // null이 아닌 value가 null로 변경되는 경우가 있어서는 안된다.
                    // 만일 이런 경우가 있다면 not null constraint가 있는 컬럼에
                    // 대하여 type이나 length 변경후 value가 null이 된다면 이를
                    // 검사하여 에러처리해야 한다.
                    // 다행히도 현재까지는 이런 경우가 없다. default_date_format을
                    // 이용하는 varchar->date의 경우도 default_date_format을 ''로
                    // 설정할 수 없기 때문에 문제가 발생하지 않는다.

                    // PROJ-1705
                    IDE_TEST( qdbCommon::mtdValue2StoringValue(
                                  sDestCol->basicInfo,
                                  sValueColumn,
                                  (void*)sValue,
                                  &sStoringValue )
                              != IDE_SUCCESS );
                    aNewRow[sColumnOrder].value = sStoringValue;

                    IDE_TEST( qdbCommon::storingSize( sDestCol->basicInfo,
                                                      sValueColumn,
                                                      (void*)sValue,
                                                      &sStoringSize )
                              != IDE_SUCCESS );
                    aNewRow[sColumnOrder].length = sStoringSize;
                }

                /* PROJ-2465 Tablespace Alteration for Table
                 *  여기에서는 Dictionary Table의 OID를 그대로 유지한다.
                 *  이후에, qcmDictionary::rebuildDictionaryTable()에서 Dictionary Table에 Value를 추가하고,
                 *  Data Table에 있는 OID를 갱신한다.
                 */
                if ( (sDestCol->basicInfo->column.flag & SMI_COLUMN_COMPRESSION_MASK)
                     == SMI_COLUMN_COMPRESSION_TRUE )
                {
                    IDE_DASSERT( sDestCol->basicInfo->column.mDictionaryTableOID != SM_NULL_OID );

                    sValue = (void*)( (UChar*) aOldRow + sSrcCol->basicInfo->column.offset );

                    // smiValue 가 dictionary table 의 OID 를 가리키도록 한다.
                    // OID 는 canonize가 필요없다.
                    // OID 는 memory table 이므로 mtd value 와 storing value 가 동일하다.
                    aNewRow[sColumnOrder].value  = sValue;
                    aNewRow[sColumnOrder].length = ID_SIZEOF(smOID);
                }
                else
                {
                    // Nothing to do.
                }
            }

            if ( aConvertContextList != NULL )
            {
                IDE_DASSERT( sConvertContext != NULL );

                sConvertContext = sConvertContext->next;
            }
            else
            {
                // Nothing to do.
            }
        }
        else
        {
            // Nothing to do.
        }

        sDestCol = sDestCol->next;
    }
    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    (void) qmx::closeLobLocator( sLocator );

    return IDE_FAILURE;
}

// PR-13725
IDE_RC qdbAlter::checkOperatable( qcStatement  * aStatement,
                                  qcmTableInfo * aTableInfo )
{
/***********************************************************************
 *
 * Description :
 *
 * Implementation :
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::checkOperatable"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY(IDE_FN));

    qdTableParseTree    * sParseTree;
    qcuSqlSourceInfo      sqlInfo;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // PR-13725
    // CHECK OPERATABLE
    if( QCM_IS_OPERATABLE_QP_ALTER_TABLE( aTableInfo->operatableFlag )
        != ID_TRUE )
    {
        sqlInfo.setSourceInfo( aStatement,
                               & sParseTree->tableName );
        IDE_RAISE(ERR_NOT_EXIST_TABLE);
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_NOT_EXIST_TABLE);
    {
        (void)sqlInfo.init(aStatement->qmeMem);
        IDE_SET(
            ideSetErrorCode(qpERR_ABORT_QCV_NOT_EXISTS_TABLE,
                            sqlInfo.getErrMessage() ));
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::updateLobStorageAttr( qcStatement       * aStatement,
                                       qdLobAttribute    * aLobAttr,
                                       smiColumnList     * aColumnList,
                                       qcmColumn         * aColumn,
                                       SChar             * aSqlStr,
                                       UInt                aPartID,
                                       UInt              * aUpdateCount )
{
#define IDE_FN "qdbAlter::updateLobStorageAttr"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY(IDE_FN));

    qdLobStorageAttribute * sLobStorageAttr;
    mtcColumn             * sMtcColumn;
    UInt                    sColOrder;
    vSLong                  sRowCnt;
    SChar                 * sTrueFalse[2] = {(SChar*)"T", (SChar*)"F"};
    SChar                 * sLogging;
    SChar                 * sBuffer;
    idBool                  sUpdateFlag;

    for (sLobStorageAttr = aLobAttr->storageAttr;
         sLobStorageAttr != NULL;
         sLobStorageAttr = sLobStorageAttr->next)
    {
        if (sLobStorageAttr->type == QD_LOB_STORAGE_ATTR_LOGGING)
        {
            // make logging column
            sColOrder = aColumn->basicInfo->column.id & SMI_COLUMN_ID_MASK;
            sMtcColumn = (mtcColumn*)(aColumnList[sColOrder].column);
            sUpdateFlag = ID_FALSE;

            if(sLobStorageAttr->logging == ID_TRUE)
            {
                sMtcColumn->column.flag &= ~SMI_COLUMN_LOGGING_MASK;
                sMtcColumn->column.flag |= SMI_COLUMN_LOGGING;
                sLogging = sTrueFalse[0];
                sUpdateFlag = ID_TRUE;
                (*aUpdateCount)++;
            }
            else if(sLobStorageAttr->logging == ID_FALSE)
            {
                sMtcColumn->column.flag &= ~SMI_COLUMN_LOGGING_MASK;
                sMtcColumn->column.flag |= SMI_COLUMN_NOLOGGING;
                sLogging = sTrueFalse[1];
                sUpdateFlag = ID_TRUE;
                (*aUpdateCount)++;
            }
            else
            {
                // Nothing to do.
            }

            if (sUpdateFlag == ID_TRUE)
            {
                if( aPartID == 0 )
                {
                    // update meta table
                    idlOS::snprintf(aSqlStr, QD_MAX_SQL_LENGTH,
                                    "UPDATE SYS_LOBS_ SET "
                                    "LOGGING = '%s'  "
                                    "WHERE COLUMN_ID = %"ID_INT32_FMT"",
                                    sLogging,
                                    aColumn->basicInfo->column.id );
                }
                else
                {
                    // update meta table
                    idlOS::snprintf(aSqlStr, QD_MAX_SQL_LENGTH,
                                    "UPDATE SYS_PART_LOBS_ SET "
                                    "LOGGING = '%s'  "
                                    "WHERE COLUMN_ID = %"ID_INT32_FMT""
                                    " AND PARTITION_ID = %"ID_INT32_FMT"",
                                    sLogging,
                                    aColumn->basicInfo->column.id,
                                    aPartID );
                }

                IDE_TEST(qcg::runDMLforDDL(QC_SMI_STMT(aStatement),
                                           aSqlStr,
                                           & sRowCnt )
                         != IDE_SUCCESS);

                IDE_TEST_RAISE(sRowCnt != 1, ERR_META_CRASH);
            }
            else
            {
                // Nothing to do.
            }
        }
        else if (sLobStorageAttr->type == QD_LOB_STORAGE_ATTR_BUFFER)
        {
            // make buffer column
            sColOrder = aColumn->basicInfo->column.id & SMI_COLUMN_ID_MASK;
            sMtcColumn = (mtcColumn*)(aColumnList[sColOrder].column);
            sUpdateFlag = ID_FALSE;

            if(sLobStorageAttr->buffer == ID_TRUE)
            {
                sMtcColumn->column.flag &= ~SMI_COLUMN_USE_BUFFER_MASK;
                sMtcColumn->column.flag |= SMI_COLUMN_USE_BUFFER;
                sBuffer = sTrueFalse[0];
                sUpdateFlag = ID_TRUE;
                (*aUpdateCount)++;
            }
            else if(sLobStorageAttr->buffer == ID_FALSE)
            {
                sMtcColumn->column.flag &= ~SMI_COLUMN_USE_BUFFER_MASK;
                sMtcColumn->column.flag |= SMI_COLUMN_USE_NOBUFFER;
                sBuffer = sTrueFalse[1];
                sUpdateFlag = ID_TRUE;
                (*aUpdateCount)++;
            }
            else
            {
                // Nothing to do.
            }

            if (sUpdateFlag == ID_TRUE)
            {
                if( aPartID == 0 )
                {
                    // update meta table
                    idlOS::snprintf(aSqlStr, QD_MAX_SQL_LENGTH,
                                    "UPDATE SYS_LOBS_ SET "
                                    "BUFFER = '%s'  "
                                    "WHERE COLUMN_ID = %"ID_INT32_FMT"",
                                    sBuffer,
                                    aColumn->basicInfo->column.id );
                }
                else
                {
                    // update meta table
                    idlOS::snprintf(aSqlStr, QD_MAX_SQL_LENGTH,
                                    "UPDATE SYS_PART_LOBS_ SET "
                                    "BUFFER = '%s'  "
                                    "WHERE COLUMN_ID = %"ID_INT32_FMT""
                                    " AND PARTITION_ID = %"ID_INT32_FMT"",
                                    sBuffer,
                                    aColumn->basicInfo->column.id,
                                    aPartID );
                }

                IDE_TEST(qcg::runDMLforDDL(QC_SMI_STMT(aStatement),
                                           aSqlStr,
                                           & sRowCnt )
                         != IDE_SUCCESS);

                IDE_TEST_RAISE(sRowCnt != 1, ERR_META_CRASH);
            }
            else
            {
                // Nothing to do.
            }
        }
        else
        {
            // Nothing to do.
        }
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_META_CRASH)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QCM_META_CRASH));
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::checkAdjPartition(
    qcStatement      * aStatement,
    qcmTableInfo     * aTableInfo )
{
/***********************************************************************
 *
 * Description :
 *    PROJ-1502 PARTITIONED DISK TABLE
 *
 *    범위 파티션드 테이블에서 MERGE할 경우
 *    두개의 파티션이 서로 인졉해있는 파티션인지 체크한다.
 *
 *
 * Implementation :
 *
 ***********************************************************************/

    qmsPartCondValList   * sPartCondMinVal;
    qmsPartCondValList   * sPartCondMaxVal;
    mtdCharType          * sPartKeyCondMinValueStr;
    mtdCharType          * sPartKeyCondMaxValueStr;

    qmsPartCondValList   * sPartCondMinVal2;
    qmsPartCondValList   * sPartCondMaxVal2;
    mtdCharType          * sPartKeyCondMinValueStr2;
    mtdCharType          * sPartKeyCondMaxValueStr2;

    qdTableParseTree     * sParseTree;
    idBool                 sIsLeftPartIsLess = ID_FALSE;
    qdPartitionAttribute * sSrcPartAttr1;
    qdPartitionAttribute * sSrcPartAttr2;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    sSrcPartAttr1 = sParseTree->partTable->partAttr;
    sSrcPartAttr2 = sParseTree->partTable->partAttr->next;

    // 파스트리에서 가져온다.
    sPartCondMinVal         = sSrcPartAttr1->alterPart->partCondMinVal;
    sPartCondMaxVal         = sSrcPartAttr1->alterPart->partCondMaxVal;
    sPartKeyCondMinValueStr = sSrcPartAttr1->alterPart->partKeyCondMinValStr;
    sPartKeyCondMaxValueStr = sSrcPartAttr1->alterPart->partKeyCondMaxValStr;

    sPartCondMinVal2         = sSrcPartAttr2->alterPart->partCondMinVal;
    sPartCondMaxVal2         = sSrcPartAttr2->alterPart->partCondMaxVal;
    sPartKeyCondMinValueStr2 = sSrcPartAttr2->alterPart->partKeyCondMinValStr;
    sPartKeyCondMaxValueStr2 = sSrcPartAttr2->alterPart->partKeyCondMaxValStr;

    // ---------------------------------------------------
    // SrcPart1의 max value와 SrcPart2의 min value가 같거나
    // SrcPart2의 max value와 SrcPart1의 max value가 같으면
    // 서로 인접한 파티션이다.
    // ---------------------------------------------------
    if( (sPartKeyCondMinValueStr->length == 0) ||
        (sPartKeyCondMaxValueStr2->length == 0) )
    {
        sIsLeftPartIsLess = ID_TRUE;

        IDE_TEST_RAISE( qmoPartition::compareRangePartition(
                            aTableInfo->partKeyColumns,
                            sPartCondMaxVal,
                            sPartCondMinVal2 ) != 0,
                        ERR_MERGE_NOT_ADJACENT_PARTITIONS_IN_RANGE_PART_TABLE );
    }
    else if( (sPartKeyCondMaxValueStr->length == 0) ||
             (sPartKeyCondMinValueStr2->length == 0) )
    {
        sIsLeftPartIsLess = ID_FALSE;

        IDE_TEST_RAISE( qmoPartition::compareRangePartition(
                            aTableInfo->partKeyColumns,
                            sPartCondMinVal,
                            sPartCondMaxVal2 ) != 0,
                        ERR_MERGE_NOT_ADJACENT_PARTITIONS_IN_RANGE_PART_TABLE );
    }
    else
    {
        if( qmoPartition::compareRangePartition(
                aTableInfo->partKeyColumns,
                sPartCondMaxVal,
                sPartCondMinVal2 ) == 0 )
        {
            sIsLeftPartIsLess = ID_TRUE;
        }
        else if( qmoPartition::compareRangePartition(
                     aTableInfo->partKeyColumns,
                     sPartCondMaxVal2,
                     sPartCondMinVal ) == 0 )
        {
            sIsLeftPartIsLess = ID_FALSE;
        }
        else
        {
            IDE_RAISE( ERR_MERGE_NOT_ADJACENT_PARTITIONS_IN_RANGE_PART_TABLE );
        }
    }

    // SrcPart1과 SrcPart2의 순서를 파스트리에 저장해 놓는다.
    sParseTree->partTable->partAttr->alterPart->isLeftPartIsLess = sIsLeftPartIsLess;

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_MERGE_NOT_ADJACENT_PARTITIONS_IN_RANGE_PART_TABLE)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_CANNOT_MERGE_NOT_ADJ_PARTITIONS_IN_RANGE_PART_TABLE));
    }

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

/*
    Table의 Flag를 변경하는 Alter구문에 대한 Validation

    ex> ALTER TABLE TABLENAME COMPRESSED LOGGING
    ex> ALTER TABLE TABLENAME UNCOMPRESSED LOGGING

    [IN] aStatement - Validation을 수행할 Statement
 */
IDE_RC qdbAlter::validateAttrFlag( qcStatement * aStatement )
{
    qdTableParseTree     * sParseTree    = NULL;
    qcmPartitionInfoList * sPartInfoList = NULL;
    SInt                   sCountVolType = 0;
    UInt                   sTableType    = 0;
    UInt                   sFlag         = 0;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    /* ALTER TABLE 구문의 공통적인 validation 수행 - 테이블에 LOCK(IS) */
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_TRUE )
              != IDE_SUCCESS );

    IDE_ASSERT( sParseTree->tableAttrFlagList != NULL );

    /* List내에 오직 하나의 Attribuate Flag만 있어야 함 */
    IDE_ASSERT( sParseTree->tableAttrFlagList->next == NULL );

    /* PROJ-2464 hybrid partitioned table 지원
     *  - Table Partition을 고려한 추가 검사이다.
     *  - Volatile Partition이 있는 경우, Uncompressed Logging 옵션만 지원한다.
     *     1. Partition List를 가져온다.
     *     2. Volatile 매체는 Uncompressed Logging 옵션만 지원한다.
     */
    sTableType = sParseTree->tableInfo->tableFlag & SMI_TABLE_TYPE_MASK;
    sFlag      = sParseTree->tableAttrFlagList->attrValue;

    if ( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        /* 1. Partition List를 가져온다. */
        IDE_TEST( qdbCommon::checkAndSetAllPartitionInfo( aStatement,
                                                          sParseTree->tableInfo->tableID,
                                                          &( sParseTree->partTable->partInfoList ) )
                  != IDE_SUCCESS );

        sPartInfoList = sParseTree->partTable->partInfoList;
    }
    else
    {
        /* Nothing to do */
    }

    if ( ( sFlag & SMI_TABLE_LOG_COMPRESS_MASK ) == SMI_TABLE_LOG_COMPRESS_TRUE )
    {
        /* 2. Volatile 매체는 Uncompressed Logging 옵션만 지원한다. */
        qdbCommon::getTableTypeCountInPartInfoList( & sTableType,
                                                    sPartInfoList,
                                                    NULL,
                                                    NULL,
                                                    & sCountVolType );

        IDE_TEST_RAISE( sCountVolType > 0, ERR_VOLATILE_LOG_COMPRESS );
    }
    else
    {
        /* Nothing to do */
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_VOLATILE_LOG_COMPRESS );
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDT_UNABLE_TO_COMPRESS_VOLATILE_TBS_LOG ) );
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

/*
    Table의 Flag를 변경하는 Alter구문에 대한 Validation

    ex> ALTER TABLE TABLENAME COMPRESSED LOGGING
    ex> ALTER TABLE TABLENAME UNCOMPRESSED LOGGING

    [IN] aStatement - Validation을 수행할 Statement
 */

IDE_RC qdbAlter::executeAttrFlag( qcStatement * aStatement )
{
    qdTableParseTree     * sParseTree       = NULL;
    smOID                  sTableOID        = SMI_NULL_OID;
    qcmPartitionInfoList * sPartInfoList    = NULL;
    UInt                   sPartID          = 0;
    smOID                  sPartOID         = SMI_NULL_OID;
    qcmTableInfo         * sTableInfo       = NULL;
    qcmTableInfo         * sNewTableInfo    = NULL;
    smSCN                  sNewSCN;
    void                 * sNewTableHandle  = NULL;
    qcmPartitionInfoList * sOldPartInfoList = NULL;
    qcmPartitionInfoList * sNewPartInfoList = NULL;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    /* TASK-2176 Table에 대한 Lock을 획득한다. */
    IDE_TEST( qcm::validateAndLockTable( aStatement,
                                         sParseTree->tableHandle,
                                         sParseTree->tableSCN,
                                         SMI_TABLE_LOCK_X )
              != IDE_SUCCESS );

    sTableInfo = sParseTree->tableInfo;
    sTableOID  = smiGetTableId( sTableInfo->tableHandle );

    /* PROJ-2464 hybrid partitioned table 지원 */
    if ( sTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        /* 1. 모든 파티션에 LOCK(X) */
        IDE_TEST( qcmPartition::validateAndLockPartitionInfoList( aStatement,
                                                                  sParseTree->partTable->partInfoList,
                                                                  SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                                  SMI_TABLE_LOCK_X,
                                                                  ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                                    ID_ULONG_MAX :
                                                                    smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );

        // 예외 처리를 위하여, Lock을 잡은 후에 Partition List를 설정한다.
        sOldPartInfoList = sParseTree->partTable->partInfoList;
    }
    else
    {
        /* Nothing to do */
    }

    IDE_TEST( smiTable::alterTableFlag( QC_SMI_STMT( aStatement ),
                                        sTableInfo->tableHandle,
                                        sParseTree->tableAttrFlagList->attrMask,
                                        sParseTree->tableAttrFlagList->attrValue )
              != IDE_SUCCESS );

    /* PROJ-2464 hybrid partitioned table 지원 */
    if ( sTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        /* 2. 모든 파티션에 작업을 수행한다. */
        for ( sPartInfoList  = sOldPartInfoList;
              sPartInfoList != NULL;
              sPartInfoList  = sPartInfoList->next )
        {
            IDE_TEST( smiTable::alterTableFlag( QC_SMI_STMT( aStatement ),
                                                sPartInfoList->partHandle,
                                                sParseTree->tableAttrFlagList->attrMask,
                                                sParseTree->tableAttrFlagList->attrValue )
                      != IDE_SUCCESS );
        }
    }
    else
    {
        /* Nothing to do */
    }

    /* fix BUG-14394 */
    IDE_TEST( qdbCommon::updateTableSpecFromMeta( aStatement,
                                                  sParseTree->userName,
                                                  sParseTree->tableName,
                                                  sTableInfo->tableID,
                                                  sTableOID,
                                                  sTableInfo->columnCount,
                                                  sTableInfo->parallelDegree )
              != IDE_SUCCESS );

    /* PROJ-2464 hybrid partitioned table 지원 */
    if ( sTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        /* 3. 모든 파티션의 Last DDL Time를 수정한다. */
        for ( sPartInfoList  = sOldPartInfoList;
              sPartInfoList != NULL;
              sPartInfoList  = sPartInfoList->next )
        {
            sPartID  = sPartInfoList->partitionInfo->partitionID;
            sPartOID = smiGetTableId( sPartInfoList->partHandle );

            IDE_TEST( qdbCommon::updatePartTableSpecFromMeta( aStatement,
                                                              sTableInfo->tableID,
                                                              sPartID,
                                                              sPartOID )
                      != IDE_SUCCESS );
        }
    }
    else
    {
        /* Nothing to do */
    }

    IDE_TEST( qcm::makeAndSetQcmTableInfo( QC_SMI_STMT( aStatement ),
                                           sTableInfo->tableID,
                                           sTableOID )
              != IDE_SUCCESS );

    IDE_TEST( qcm::getTableInfoByID( aStatement,
                                     sTableInfo->tableID,
                                     & sNewTableInfo,
                                     & sNewSCN,
                                     & sNewTableHandle )
              != IDE_SUCCESS );

    if ( sTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST( qcmPartition::makeAndSetAndGetQcmPartitionInfoList( aStatement,
                                                                      sNewTableInfo,
                                                                      sOldPartInfoList,
                                                                      & sNewPartInfoList )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    /* Touch와 Commit 사이의 간격을 줄이기 위해, Touch를 마지막에 수행한다. */
    IDE_TEST( qcm::touchTable( QC_SMI_STMT( aStatement ),
                               sTableInfo->tableID,
                               SMI_TBSLV_DDL_DML )
              != IDE_SUCCESS );

    if ( sTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST( qcmPartition::touchPartitionInfoList( QC_SMI_STMT( aStatement ),
                                                        sOldPartInfoList )
                  != IDE_SUCCESS );

        (void)qcmPartition::destroyQcmPartitionInfoList( sOldPartInfoList );
    }
    else
    {
        /* Nothing to do */
    }

    (void)qcm::destroyQcmTableInfo( sTableInfo );

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    (void)qcm::destroyQcmTableInfo( sNewTableInfo );
    (void)qcmPartition::destroyQcmPartitionInfoList( sNewPartInfoList );

    qcmPartition::restoreTempInfo( sTableInfo,
                                   sOldPartInfoList,
                                   NULL );

    return IDE_FAILURE;
}

/*
    Supplemental Logging할지 여부에 대한
    Table의 Flag를 변경하는 Alter구문에 대한 Validation

    PROJ-1723 [MDW/INTEGRATOR] Altibase Plugin 개발

    ALTER TABLE table_name DROP SUPPLEMENTAL LOG DATA ( PRIMARY KEY ) COLUMNS
    ALTER TABLE table_name ADD SUPPLEMENTAL LOG DATA ( PRIMARY KEY ) COLUMNS

    [IN] aStatement - Validation을 수행할 Statement
 */
IDE_RC qdbAlter::validateAlterTableSuppLogging( qcStatement * aStatement )
{
    qdTableParseTree     * sParseTree    = NULL;
    UInt                   sTableType    = 0;
    qcmPartitionInfoList * sPartInfoList = NULL;
    SInt                   sCountVolType = 0;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    /* ALTER TABLE 구문의 공통적인 validation 수행 - 테이블에 LOCK(IS) */
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_FALSE )
              != IDE_SUCCESS );

    IDE_TEST_RAISE( sParseTree->tableInfo->primaryKey == NULL,
                    ERR_NO_SUPP_LOGGING_WITHOUT_PK );

    /* PROJ-2464 hybrid partitioned table 지원
     *  - Table Partition을 고려한 추가 검사이다.
     *  - Volatile Partition이 있는 경우, Supplemental Logging 옵션만 지원한다.
     *     1. Parser에서 할당하지 않은 PartTable를 여기서 할당한다.
     *     2. Partition List를 가져온다.
     *     3. Volatile 매체는 Supplemental Logging 옵션만 지원한다.
     */
    sTableType = sParseTree->tableInfo->tableFlag & SMI_TABLE_TYPE_MASK;

    if ( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_DASSERT( sParseTree->partTable == NULL );

        /* 1. Parser에서 할당하지 않은 PartTable를 여기서 할당한다. */
        IDU_FIT_POINT( "qdbAlter::validateAlterTableSuppLogging::alloc::sParseTree->partTable",
                       idERR_ABORT_InsufficientMemory );

        IDE_TEST( QC_QMP_MEM( aStatement )->alloc( ID_SIZEOF( qdPartitionedTable ),
                                                   (void**)&( sParseTree->partTable ) )
                  != IDE_SUCCESS );

        /* 2. Partition List를 가져온다. */
        IDE_TEST( qdbCommon::checkAndSetAllPartitionInfo( aStatement,
                                                          sParseTree->tableInfo->tableID,
                                                          &( sParseTree->partTable->partInfoList ) )
                  != IDE_SUCCESS );

        sPartInfoList = sParseTree->partTable->partInfoList;
    }
    else
    {
        /* Nothing to do */
    }

    /* 3. Volatile 매체는 Supplemental Logging 옵션만 지원한다. */
    qdbCommon::getTableTypeCountInPartInfoList( & sTableType,
                                                sPartInfoList,
                                                NULL,
                                                NULL,
                                                & sCountVolType );

    IDE_TEST_RAISE( sCountVolType > 0, ERR_NO_SUPP_LOGGING_ON_VOLATILE_TABLE );

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_NO_SUPP_LOGGING_ON_VOLATILE_TABLE )
    {
        IDE_SET(ideSetErrorCode(
                    qpERR_ABORT_QDB_NO_SUPP_LOGGING_ON_VOLATILE_TABLE));
    }
    IDE_EXCEPTION( ERR_NO_SUPP_LOGGING_WITHOUT_PK )
    {
        IDE_SET(ideSetErrorCode(
                    qpERR_ABORT_QDB_NO_SUPP_LOGGING_WITHOUT_PK));
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

/*
    Supplemental Logging할지 여부에 대한
    Table의 Flag를 변경하는 Alter구문에 대한 Execution

    PROJ-1723 [MDW/INTEGRATOR] Altibase Plugin 개발

    ALTER TABLE table_name DROP SUPPLEMENTAL LOG DATA ( PRIMARY KEY ) COLUMNS
    ALTER TABLE table_name ADD SUPPLEMENTAL LOG DATA ( PRIMARY KEY ) COLUMNS

    [IN] aStatement - Validation을 수행할 Statement
 */

IDE_RC qdbAlter::executeAlterTableSuppLogging( qcStatement * aStatement )
{
    qdTableParseTree     * sParseTree       = NULL;
    UInt                   sNewAttrValue    = 0;
    smOID                  sTableOID        = SMI_NULL_OID;
    qcmPartitionInfoList * sPartInfoList    = NULL;
    UInt                   sPartID          = 0;
    smOID                  sPartOID         = SMI_NULL_OID;
    qcmTableInfo         * sTableInfo       = NULL;
    qcmTableInfo         * sNewTableInfo    = NULL;
    smSCN                  sNewSCN;
    void                 * sNewTableHandle  = NULL;
    qcmPartitionInfoList * sOldPartInfoList = NULL;
    qcmPartitionInfoList * sNewPartInfoList = NULL;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    if ( sParseTree->isSuppLogging == ID_TRUE )
    {
        sNewAttrValue = SMI_TABLE_SUPPLEMENTAL_LOGGING_TRUE;
    }
    else
    {
        sNewAttrValue = SMI_TABLE_SUPPLEMENTAL_LOGGING_FALSE;
    }

    /* TASK-2176 Table에 대한 Lock을 획득한다. */
    IDE_TEST( qcm::validateAndLockTable( aStatement,
                                         sParseTree->tableHandle,
                                         sParseTree->tableSCN,
                                         SMI_TABLE_LOCK_X )
              != IDE_SUCCESS );

    sTableInfo = sParseTree->tableInfo;
    sTableOID  = smiGetTableId( sTableInfo->tableHandle );

    /* PROJ-2464 hybrid partitioned table 지원 */
    if ( sTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        /* 1. 모든 파티션에 LOCK(X) */
        IDE_TEST( qcmPartition::validateAndLockPartitionInfoList( aStatement,
                                                                  sParseTree->partTable->partInfoList,
                                                                  SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                                  SMI_TABLE_LOCK_X,
                                                                  ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                                    ID_ULONG_MAX :
                                                                    smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );

        // 예외 처리를 위하여, Lock을 잡은 후에 Partition List를 설정한다.
        sOldPartInfoList = sParseTree->partTable->partInfoList;
    }
    else
    {
        /* Nothing to do */
    }

    IDE_TEST( smiTable::alterTableFlag( QC_SMI_STMT( aStatement ),
                                        sTableInfo->tableHandle,
                                        SMI_TABLE_SUPPLEMENTAL_LOGGING_MASK,
                                        sNewAttrValue )
              != IDE_SUCCESS );

    /* PROJ-2464 hybrid partitioned table 지원 */
    if ( sTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        /* 2. 모든 파티션에 작업을 수행한다. */
        for ( sPartInfoList  = sOldPartInfoList;
              sPartInfoList != NULL;
              sPartInfoList  = sPartInfoList->next )
        {
            IDE_TEST( smiTable::alterTableFlag( QC_SMI_STMT( aStatement ),
                                                sPartInfoList->partHandle,
                                                SMI_TABLE_SUPPLEMENTAL_LOGGING_MASK,
                                                sNewAttrValue )
                      != IDE_SUCCESS );
        }
    }
    else
    {
        /* Nothing to do */
    }

    /* fix BUG-14394 */
    IDE_TEST( qdbCommon::updateTableSpecFromMeta( aStatement,
                                                  sParseTree->userName,
                                                  sParseTree->tableName,
                                                  sTableInfo->tableID,
                                                  sTableOID,
                                                  sTableInfo->columnCount,
                                                  sTableInfo->parallelDegree )
              != IDE_SUCCESS );

    /* PROJ-2464 hybrid partitioned table 지원 */
    if ( sTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        /* 3. 모든 파티션의 Last DDL Time를 수정한다. */
        for ( sPartInfoList  = sOldPartInfoList;
              sPartInfoList != NULL;
              sPartInfoList  = sPartInfoList->next )
        {
            sPartID  = sPartInfoList->partitionInfo->partitionID;
            sPartOID = smiGetTableId( sPartInfoList->partHandle );

            IDE_TEST( qdbCommon::updatePartTableSpecFromMeta( aStatement,
                                                              sTableInfo->tableID,
                                                              sPartID,
                                                              sPartOID )
                      != IDE_SUCCESS );
        }
    }
    else
    {
        /* Nothing to do */
    }

    IDE_TEST( qcm::makeAndSetQcmTableInfo( QC_SMI_STMT( aStatement ),
                                           sTableInfo->tableID,
                                           sTableOID )
              != IDE_SUCCESS );

    IDE_TEST( qcm::getTableInfoByID( aStatement,
                                     sTableInfo->tableID,
                                     & sNewTableInfo,
                                     & sNewSCN,
                                     & sNewTableHandle )
              != IDE_SUCCESS );

    if ( sTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST( qcmPartition::makeAndSetAndGetQcmPartitionInfoList( aStatement,
                                                                      sNewTableInfo,
                                                                      sOldPartInfoList,
                                                                      & sNewPartInfoList )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    /* Touch와 Commit 사이의 간격을 줄이기 위해, Touch를 마지막에 수행한다. */
    IDE_TEST( qcm::touchTable( QC_SMI_STMT( aStatement ),
                               sTableInfo->tableID,
                               SMI_TBSLV_DDL_DML )
              != IDE_SUCCESS );

    if ( sTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST( qcmPartition::touchPartitionInfoList( QC_SMI_STMT( aStatement ),
                                                        sOldPartInfoList )
                  != IDE_SUCCESS );

        (void)qcmPartition::destroyQcmPartitionInfoList( sOldPartInfoList );
    }
    else
    {
        /* Nothing to do */
    }

    (void)qcm::destroyQcmTableInfo( sTableInfo );

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    (void)qcm::destroyQcmTableInfo( sNewTableInfo );
    (void)qcmPartition::destroyQcmPartitionInfoList( sNewPartInfoList );

    qcmPartition::restoreTempInfo( sTableInfo,
                                   sOldPartInfoList,
                                   NULL );

    return IDE_FAILURE;
}

/*
    Table의 Insert Limit을 변경하는 Alter구문에 대한 실행

    ex> ALTER TABLE TABLENAME INSERT HIGH LIMIT .. INSERT LOW LIMIT;
    ex> ALTER TABLE TABLENAME INSERT LOW LIMIT ..;

    [IN] aStatement - Validation을 수행할 Statement
 */

IDE_RC qdbAlter::executeAlterTableSegAttr(qcStatement * aStatement)
{
    qdTableParseTree     * sParseTree    = NULL;
    SChar                * sSqlStr       = NULL;
    vSLong                 sRowCnt       = 0;
    qcmTableInfo         * sTableInfo    = NULL;
    UInt                   sTableID      = 0;
    smOID                  sTableOID     = 0;
    qcmPartitionInfoList * sPartInfoList = NULL;
    UInt                   sPartID       = 0;
    smOID                  sPartOID      = 0 ;
    qdIndexTableList     * sIndexTable   = NULL;

    qcmPartitionInfoList * sOldPartInfoList = NULL;
    qcmPartitionInfoList * sNewPartInfoList = NULL;
    qcmTableInfo         * sNewTableInfo    = NULL;
    void                 * sNewTableHandle  = NULL;
    smSCN                  sNewSCN          = SM_SCN_INIT;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    /* TASK-2176 - Table에 대한 Lock을 획득한다. */
    IDE_TEST( qcm::validateAndLockTable( aStatement,
                                         sParseTree->tableHandle,
                                         sParseTree->tableSCN,
                                         SMI_TABLE_LOCK_X )
              != IDE_SUCCESS );

    sTableInfo = sParseTree->tableInfo;

    if ( sTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        /* 모든 파티션에 LOCK(X) */
        IDE_TEST( qcmPartition::validateAndLockPartitionInfoList( aStatement,
                                                                  sParseTree->partTable->partInfoList,
                                                                  SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                                  SMI_TABLE_LOCK_X,
                                                                  ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                                    ID_ULONG_MAX :
                                                                    smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );

        // 예외 처리를 위하여, Lock을 잡은 후에 Partition List를 설정한다.
        sOldPartInfoList = sParseTree->partTable->partInfoList;

        /* PROJ-1624 non-partitioned index */
        IDE_TEST( qdx::validateAndLockIndexTableList( aStatement,
                                                      sParseTree->oldIndexTables,
                                                      SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                      SMI_TABLE_LOCK_X,
                                                      ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                        ID_ULONG_MAX :
                                                        smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    IDE_TEST( smiTable::alterTableSegAttr( QC_SMI_STMT( aStatement ),
                                           sTableInfo->tableHandle,
                                           sParseTree->segAttr )
              != IDE_SUCCESS );

    if ( sTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        for ( sPartInfoList  = sOldPartInfoList;
              sPartInfoList != NULL;
              sPartInfoList  = sPartInfoList->next )
        {
            /* PROJ-2464 hybrid partitioned table 지원
             *  - Disk Partition의 SegAttr
             */
            if ( ( sPartInfoList->partitionInfo->tableFlag & SMI_TABLE_TYPE_MASK ) == SMI_TABLE_DISK )
            {
                IDE_TEST( smiTable::alterTableSegAttr( QC_SMI_STMT( aStatement ),
                                                       sPartInfoList->partHandle,
                                                       sParseTree->segAttr )
                          != IDE_SUCCESS );
            }
            else
            {
                /* Nothing to do */
            }
        }

        /* PROJ-1624 non-partitioned index */
        for ( sIndexTable  = sParseTree->oldIndexTables;
              sIndexTable != NULL;
              sIndexTable  = sIndexTable->next )
        {
            IDE_TEST( smiTable::alterTableSegAttr( QC_SMI_STMT( aStatement ),
                                                   sIndexTable->tableHandle,
                                                   sParseTree->segAttr )
                      != IDE_SUCCESS );
        }
    }
    else
    {
        /* Nothing to do */
    }

    sTableID  = sTableInfo->tableID;
    sTableOID = smiGetTableId( sTableInfo->tableHandle );

    IDU_LIMITPOINT( "qdbAlter::executeAlterTableSegAttr::malloc" );
    IDE_TEST( STRUCT_ALLOC_WITH_SIZE( aStatement->qmxMem,
                                      SChar,
                                      QD_MAX_SQL_LENGTH,
                                      & sSqlStr )
              != IDE_SUCCESS );

    idlOS::snprintf( sSqlStr, QD_MAX_SQL_LENGTH,
                     "UPDATE SYS_TABLES_ "
                     "SET PCTFREE= INTEGER'%"ID_INT32_FMT"', "
                     "    PCTUSED= INTEGER'%"ID_INT32_FMT"', "
                     "    INIT_TRANS= INTEGER'%"ID_INT32_FMT"', "
                     "    MAX_TRANS= INTEGER'%"ID_INT32_FMT"', "
                     "    LAST_DDL_TIME = SYSDATE "
                     "WHERE TABLE_ID = INTEGER'%"ID_INT32_FMT"'",
                     sParseTree->segAttr.mPctFree,
                     sParseTree->segAttr.mPctUsed,
                     sParseTree->segAttr.mInitTrans,
                     sParseTree->segAttr.mMaxTrans,
                     sTableID );

    IDE_TEST( qcg::runDMLforDDL( QC_SMI_STMT( aStatement ),
                                 sSqlStr,
                                 & sRowCnt )
              != IDE_SUCCESS );

    IDE_TEST_RAISE( sRowCnt != 1, ERR_META_CRASH );

    IDE_TEST( qcm::touchTable( QC_SMI_STMT( aStatement ),
                               sTableID,
                               SMI_TBSLV_DDL_DML )
              != IDE_SUCCESS );

    /* PROJ-2464 hybrid partitioned table 지원 */
    if ( sTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        /* 모든 파티션의 Last DDL Time를 수행한다. */
        for ( sPartInfoList  = sOldPartInfoList;
              sPartInfoList != NULL;
              sPartInfoList  = sPartInfoList->next )
        {
            sPartID  = sPartInfoList->partitionInfo->partitionID;
            sPartOID = smiGetTableId( sPartInfoList->partHandle );

            IDE_TEST( qdbCommon::updatePartTableSpecFromMeta( aStatement,
                                                              sTableInfo->tableID,
                                                              sPartID,
                                                              sPartOID )
                      != IDE_SUCCESS );
        }
    }
    else
    {
        /* Nothing to do */
    }

    IDE_TEST( qcm::makeAndSetQcmTableInfo( QC_SMI_STMT( aStatement ),
                                           sTableID,
                                           sTableOID )
              != IDE_SUCCESS );

    IDE_TEST( qcm::getTableInfoByID( aStatement,
                                     sTableID,
                                     & sNewTableInfo,
                                     & sNewSCN,
                                     & sNewTableHandle )
              != IDE_SUCCESS );

    if ( sTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST( qcmPartition::touchPartitionInfoList( QC_SMI_STMT( aStatement ),
                                                        sOldPartInfoList )
                  != IDE_SUCCESS );

        IDE_TEST( qcmPartition::makeAndSetAndGetQcmPartitionInfoList( aStatement,
                                                                      sNewTableInfo,
                                                                      sOldPartInfoList,
                                                                      & sNewPartInfoList )
                  != IDE_SUCCESS );

        (void)qcmPartition::destroyQcmPartitionInfoList( sOldPartInfoList );
    }
    else
    {
        /* Nothing to do */
    }

    (void)qcm::destroyQcmTableInfo( sTableInfo );

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_META_CRASH )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QCM_META_CRASH ) );
    }
    IDE_EXCEPTION_END;

    (void)qcm::destroyQcmTableInfo( sNewTableInfo );
    (void)qcmPartition::destroyQcmPartitionInfoList( sNewPartInfoList );

    qcmPartition::restoreTempInfo( sTableInfo,
                                   sOldPartInfoList,
                                   NULL );

    return IDE_FAILURE;
}


/*
    Table의 STORAGE을 변경하는 Alter 구문에 대한 실행

    ex> ALTER TABLE TABLENAME STORAGE( .. );

    [IN] aStatement - Validation을 수행할 Statement
 */

IDE_RC qdbAlter::executeAlterTableSegStoAttr( qcStatement * aStatement )
{

    qdTableParseTree     * sParseTree    = NULL;
    SChar                * sSqlStr       = NULL;
    vSLong                 sRowCnt       = 0;
    qcmTableInfo         * sTableInfo    = NULL;
    UInt                   sTableID      = 0;
    smOID                  sTableOID     = 0;
    qcmPartitionInfoList * sPartInfoList = NULL;
    UInt                   sPartID       = 0;
    smOID                  sPartOID      = 0;
    qdIndexTableList     * sIndexTable   = NULL;

    qcmPartitionInfoList * sOldPartInfoList = NULL;
    qcmPartitionInfoList * sNewPartInfoList = NULL;
    qcmTableInfo         * sNewTableInfo    = NULL;
    void                 * sNewTableHandle  = NULL;
    smSCN                  sNewSCN          = SM_SCN_INIT;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    /* TASK-2176 Table에 대한 Lock을 획득한다. */
    IDE_TEST( qcm::validateAndLockTable( aStatement,
                                         sParseTree->tableHandle,
                                         sParseTree->tableSCN,
                                         SMI_TABLE_LOCK_X )
              != IDE_SUCCESS );

    sTableInfo = sParseTree->tableInfo;

    /* Partitioned Table의 각 Partition에 대한 Lock을 획득한다. */
    if ( sTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        /* 모든 파티션에 LOCK(X) */
        IDE_TEST( qcmPartition::validateAndLockPartitionInfoList( aStatement,
                                                                  sParseTree->partTable->partInfoList,
                                                                  SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                                  SMI_TABLE_LOCK_X,
                                                                  ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                                    ID_ULONG_MAX :
                                                                    smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );
        
        // 예외 처리를 위하여, Lock을 잡은 후에 Partition List를 설정한다.
        sOldPartInfoList = sParseTree->partTable->partInfoList;

        /* PROJ-1624 non-partitioned index */
        IDE_TEST( qdx::validateAndLockIndexTableList( aStatement,
                                                      sParseTree->oldIndexTables,
                                                      SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                      SMI_TABLE_LOCK_X,
                                                      ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                        ID_ULONG_MAX :
                                                        smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    IDE_TEST( smiTable::alterTableSegStoAttr( QC_SMI_STMT( aStatement ),
                                              sTableInfo->tableHandle,
                                              sParseTree->segStoAttr )
              != IDE_SUCCESS );

    if ( sTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        for ( sPartInfoList  = sOldPartInfoList;
              sPartInfoList != NULL;
              sPartInfoList  = sPartInfoList->next )
        {
            /* PROJ-2464 hybrid partitioned table 지원
             *  - Disk Partition의 SegStoAttr
             */
            if ( ( sPartInfoList->partitionInfo->tableFlag & SMI_TABLE_TYPE_MASK ) == SMI_TABLE_DISK )
            {
                IDE_TEST( smiTable::alterTableSegStoAttr( QC_SMI_STMT( aStatement ),
                                                          sPartInfoList->partHandle,
                                                          sParseTree->segStoAttr )
                          != IDE_SUCCESS );
            }
            else
            {
                /* Nothing to do */
            }
        }

        /* PROJ-1624 non-partitioned index */
        for ( sIndexTable  = sParseTree->oldIndexTables;
              sIndexTable != NULL;
              sIndexTable  = sIndexTable->next )
        {
            IDE_TEST( smiTable::alterTableSegStoAttr( QC_SMI_STMT( aStatement ),
                                                      sIndexTable->tableHandle,
                                                      sParseTree->segStoAttr )
                      != IDE_SUCCESS );
        }
    }
    else
    {
        /* Nothing to do */
    }
    
    sTableID  = sTableInfo->tableID;
    sTableOID = smiGetTableId( sTableInfo->tableHandle );

    IDU_LIMITPOINT( "qdbAlter::executeAlterTableSegStoAttr::malloc" );
    IDE_TEST( STRUCT_ALLOC_WITH_SIZE( aStatement->qmxMem,
                                      SChar,
                                      QD_MAX_SQL_LENGTH,
                                      & sSqlStr )
              != IDE_SUCCESS );

    idlOS::snprintf( sSqlStr, QD_MAX_SQL_LENGTH,
                     "UPDATE SYS_TABLES_ "
                     "SET INITEXTENTS = BIGINT'%"ID_INT64_FMT"', "
                     "    NEXTEXTENTS = BIGINT'%"ID_INT64_FMT"', "
                     "    MINEXTENTS  = BIGINT'%"ID_INT64_FMT"', "
                     "    MAXEXTENTS  = BIGINT'%"ID_INT64_FMT"', "
                     "    LAST_DDL_TIME = SYSDATE "
                     "WHERE TABLE_ID = INTEGER'%"ID_INT32_FMT"'",
                     (ULong)sParseTree->segStoAttr.mInitExtCnt,
                     (ULong)sParseTree->segStoAttr.mNextExtCnt,
                     (ULong)sParseTree->segStoAttr.mMinExtCnt,
                     (ULong)sParseTree->segStoAttr.mMaxExtCnt,
                     sTableID );

    IDE_TEST( qcg::runDMLforDDL( QC_SMI_STMT( aStatement ),
                                 sSqlStr,
                                 & sRowCnt )
              != IDE_SUCCESS );

    IDE_TEST_RAISE( sRowCnt != 1, ERR_META_CRASH );


    IDE_TEST( qcm::touchTable( QC_SMI_STMT( aStatement ),
                               sTableID,
                               SMI_TBSLV_DDL_DML )
              != IDE_SUCCESS );

    /* PROJ-2464 hybrid partitioned table 지원 */
    if ( sTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        /* 모든 파티션의 Last DDL Time를 수정한다. */
        for ( sPartInfoList  = sOldPartInfoList;
              sPartInfoList != NULL;
              sPartInfoList  = sPartInfoList->next )
        {
            sPartID  = sPartInfoList->partitionInfo->partitionID;
            sPartOID = smiGetTableId( sPartInfoList->partHandle );

            IDE_TEST( qdbCommon::updatePartTableSpecFromMeta( aStatement,
                                                              sTableInfo->tableID,
                                                              sPartID,
                                                              sPartOID )
                      != IDE_SUCCESS );
        }
    }
    else
    {
        /* Nothing to do */
    }

    IDE_TEST( qcm::makeAndSetQcmTableInfo( QC_SMI_STMT( aStatement ),
                                           sTableID,
                                           sTableOID )
              != IDE_SUCCESS );

    IDE_TEST( qcm::getTableInfoByID( aStatement,
                                     sTableID,
                                     & sNewTableInfo,
                                     & sNewSCN,
                                     & sNewTableHandle )
              != IDE_SUCCESS );

    if ( sTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST( qcmPartition::touchPartitionInfoList( QC_SMI_STMT( aStatement ),
                                                        sOldPartInfoList )
                  != IDE_SUCCESS );

        IDE_TEST( qcmPartition::makeAndSetAndGetQcmPartitionInfoList( aStatement,
                                                                      sNewTableInfo,
                                                                      sOldPartInfoList,
                                                                      & sNewPartInfoList )
                  != IDE_SUCCESS );

        (void)qcmPartition::destroyQcmPartitionInfoList( sOldPartInfoList );
    }
    else
    {
        /* Nothing to do */
    }

    (void)qcm::destroyQcmTableInfo( sTableInfo );

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_META_CRASH )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QCM_META_CRASH ) );
    }
    IDE_EXCEPTION_END;

    (void)qcm::destroyQcmTableInfo( sNewTableInfo );
    (void)qcmPartition::destroyQcmPartitionInfoList( sNewPartInfoList );

    qcmPartition::restoreTempInfo( sTableInfo,
                                   sOldPartInfoList,
                                   NULL );

    return IDE_FAILURE;
}

/*
    Table에 Extent를 할당하는 Alter 구문에 대한 실행

    ex> ALTER TABLE TABLENAME ALLOCATE EXTENT ( SIZE .. );

    [IN] aStatement - Validation을 수행할 Statement
 */

IDE_RC qdbAlter::executeAlterTableAllocExtent( qcStatement * aStatement )
{
    qdTableParseTree     * sParseTree    = NULL;
    UInt                   sTableID      = 0;
    smOID                  sTableOID     = 0;
    qcmPartitionInfoList * sPartInfoList = NULL;
    UInt                   sPartID       = 0;
    smOID                  sPartOID      = 0;
    qdIndexTableList     * sIndexTable   = NULL;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    /* TASK-2176 Table에 대한 Lock을 획득한다. */
    IDE_TEST( qcm::validateAndLockTable( aStatement,
                                         sParseTree->tableHandle,
                                         sParseTree->tableSCN,
                                         SMI_TABLE_LOCK_X )
              != IDE_SUCCESS );

    /* Partitioned Table의 각 Partition에 대한 Lock을 획득한다. */
    if ( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        /* 모든 파티션에 LOCK(X) */
        IDE_TEST( qcmPartition::validateAndLockPartitionInfoList( aStatement,
                                                                  sParseTree->partTable->partInfoList,
                                                                  SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                                  SMI_TABLE_LOCK_X,
                                                                  ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                                    ID_ULONG_MAX :
                                                                    smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );

        /* PROJ-1624 non-partitioned index */
        IDE_TEST( qdx::validateAndLockIndexTableList( aStatement,
                                                      sParseTree->oldIndexTables,
                                                      SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                      SMI_TABLE_LOCK_X,
                                                      ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                        ID_ULONG_MAX :
                                                        smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    IDE_TEST( smiTable::alterTableAllocExts( QC_SMI_STMT( aStatement ),
                                             sParseTree->tableInfo->tableHandle,
                                             sParseTree->altAllocExtSize )
              != IDE_SUCCESS );

    if ( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        /* 모든 파티션에 LOCK(X) */
        for ( sPartInfoList  = sParseTree->partTable->partInfoList;
              sPartInfoList != NULL;
              sPartInfoList  = sPartInfoList->next )
        {
            /* PROJ-2464 hybrid partitioned table 지원
             *  - Disk Partition의 Allocate Extent
             */
            if ( ( sPartInfoList->partitionInfo->tableFlag & SMI_TABLE_TYPE_MASK ) == SMI_TABLE_DISK )
            {
                IDE_TEST( smiTable::alterTableAllocExts( QC_SMI_STMT( aStatement ),
                                                         sPartInfoList->partHandle,
                                                         sParseTree->altAllocExtSize )
                          != IDE_SUCCESS );
            }
            else
            {
                /* Nothing to do */
            }
        }

        /* PROJ-1624 non-partitioned index */
        for ( sIndexTable  = sParseTree->oldIndexTables;
              sIndexTable != NULL;
              sIndexTable  = sIndexTable->next )
        {
            IDE_TEST( smiTable::alterTableAllocExts( QC_SMI_STMT( aStatement ),
                                                     sIndexTable->tableHandle,
                                                     sParseTree->altAllocExtSize )
                      != IDE_SUCCESS );
        }
    }
    else
    {
        /* Nothing to do */
    }

    sTableID  = sParseTree->tableInfo->tableID;
    sTableOID = smiGetTableId( sParseTree->tableInfo->tableHandle );

    /* fix BUG-14394 */
    IDE_TEST( qdbCommon::updateTableSpecFromMeta( aStatement,
                                                  sParseTree->userName,
                                                  sParseTree->tableName,
                                                  sTableID,
                                                  sTableOID,
                                                  sParseTree->tableInfo->columnCount,
                                                  sParseTree->tableInfo->parallelDegree )
              != IDE_SUCCESS );

    /* PROJ-2464 hybrid partitioned table 지원 */
    if ( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        /* 모든 파티션의 Last DDL Time를 수정한다. */
        for ( sPartInfoList  = sParseTree->partTable->partInfoList;
              sPartInfoList != NULL;
              sPartInfoList  = sPartInfoList->next )
        {
            sPartID  = sPartInfoList->partitionInfo->partitionID;
            sPartOID = smiGetTableId( sPartInfoList->partHandle );

            IDE_TEST( qdbCommon::updatePartTableSpecFromMeta( aStatement,
                                                              sParseTree->tableInfo->tableID,
                                                              sPartID,
                                                              sPartOID )
                      != IDE_SUCCESS );
        }
    }
    else
    {
        /* Nothing to do */
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::validateModifyCol( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description : PROJ-1877
 *    ALTER TABLE ... MODIFY COLUMN ...;
 *
 *    modify column은 다음 네가지 기능을 제공한다.
 *      1. column type 변환
 *      2. column length 변환
 *      3. column (not)null constraint 추가 (단 constraint name은 미지원)
 *      4. column default 추가/변경
 *
 * Implementation :
 *    1. 존재하는 테이블인지 체크
 *    2. ALTER 하려는 테이블이 메타 테이블이면 에러 반환
 *    3. ALTER TABLE 권한이 있는지 체크
 *    4. 명시한 컬럼이 존재하는지 체크
 *    6. (not)null constraint가 이미 존재하는지 체크
 *    7. 테이블 컬럼이 blob, clob, timestamp type이면 에러 반환
 *    8. 변경할 컬럼이 blob, clob, timestamp type이면 에러 반환
 *    9. 테이블 컬럼이 참조하고 있는 foreign key가 있다면 length 확대만 가능
 *    10. 테이블 컬럼을 참조하고 있는 foreign key가 있다면 length 확대만 가능
 *    14. partition key인 경우 length 확대만 가능
 *    11. 타입 변환 matrix에 따라 적용여부 검사
 *        a. MISC GROUP type은 동일 type으로만 변환 가능하다.
 *           - byte<->byte
 *           - nibble<->nibble
 *        b. 저장옵션 변경 flag 설정
 *    12. 컬럼에 대한 modify 기능 flag 설정
 *    13. 컬럼, not null constraint validation
 *    15. check constraint를 가진 컬럼의 Data Type/Length를 변경하면 에러 반환
 *    16. Hidden Column을 변경할 수 없다.
 *        Hidden Column의 Expression에 포함된 Column을 변경할 수 없다.
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::validateModifyCol"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY("qdbAlter::validateModifyCol"));

    qdTableParseTree    * sParseTree;
    qcmColumn           * sParseColumn;
    qcmColumn           * sModifyColumn;
    qcmColumn           * sTableColumn;
    mtcColumn           * sTableColumnInfo;
    mtcColumn           * sModifyColumnInfo;
    qcmIndex            * sIndexInfo;
    qcmRefChildInfo     * sChildInfo;  // BUG-28049
    qdConstraintSpec    * sCheckConstrSpecList = NULL;
    UInt                  i;
    qcuSqlSourceInfo      sqlInfo;
    idBool                sIsValid;

    /* PROJ-1090 Function-based Index */
    qcmColumn           * sDefaultExprColumns = NULL;

    SInt                  sCountDiskType = 0;
    SInt                  sCountMemType  = 0;
    SInt                  sCountVolType  = 0;
    SInt                  sTotalCount    = 0;
    UInt                  sTableType     = 0;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    //-----------------------------------------
    // ALTER TABLE 구문의 공통적인 validation 수행
    // 1. 존재하는 테이블인지 체크
    // 2. ALTER 하려는 테이블이 메타 테이블이면 에러 반환
    // 3. ALTER TABLE 권한이 있는지 체크
    //-----------------------------------------

    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_FALSE )
              != IDE_SUCCESS );

    /* PROJ-2464 hybrid partitioned table 지원 */
    sTableType = sParseTree->tableInfo->tableFlag & SMI_TABLE_TYPE_MASK;

    //-----------------------------------------
    // partitioned table의 partInfo를 달아준다.
    //-----------------------------------------

    // PROJ-1502 PARTITIONED DISK TABLE
    if ( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        // 모든 파티션에 LOCK(IS)
        // 파티션 리스트를 파스트리에 달아놓는다.
        IDE_TEST( qdbCommon::checkAndSetAllPartitionInfo(
                      aStatement,
                      sParseTree->tableInfo->tableID,
                      & (sParseTree->partTable->partInfoList) )
                  != IDE_SUCCESS );
        
        // PROJ-1624 non-partitioned index
        IDE_TEST( qdx::makeAndLockIndexTableList(
                      aStatement,
                      ID_FALSE,
                      sParseTree->tableInfo,
                      &(sParseTree->oldIndexTables) )
                  != IDE_SUCCESS );

        /* 1. Partition 구성을 검사한다. */
        qdbCommon::getTableTypeCountInPartInfoList( & sTableType,
                                                    sParseTree->partTable->partInfoList,
                                                    & sCountDiskType,
                                                    & sCountMemType,
                                                    & sCountVolType );

        /* 2. Hybrid Partitioned Table 에서는 Modify Column를 지원하지 않는다. */
        sTotalCount = sCountDiskType + sCountMemType + sCountVolType;

        /* 2.1. 모두 같은 Type인지 검사한다. Hybrid Partitioned Table가 아니다. */
        IDE_TEST_RAISE( !( ( sTotalCount == sCountDiskType ) ||
                           ( sTotalCount == sCountMemType ) ||
                           ( sTotalCount == sCountVolType ) ),
                        ERR_UNSUPPORT_ON_HYBRID_PARTITIONED_TABLE );
    }
    else
    {
        // Nothing to do.
    }

    sParseColumn = sParseTree->columns;
    sModifyColumn = sParseTree->modifyColumns;

    while ( sParseColumn != NULL )
    {
        IDE_DASSERT( sModifyColumn != NULL );

        sqlInfo.setSourceInfo( aStatement,
                               & sParseColumn->namePos );

        //-----------------------------------------
        // 4. 명시한 컬럼이 존재하는지 체크
        //-----------------------------------------

        IDE_TEST( qcmCache::getColumn( aStatement,
                                       sParseTree->tableInfo,
                                       sParseColumn->namePos,
                                       & sTableColumn )
                  != IDE_SUCCESS );

        // basicInfo를 기록한다.
        QDB_SET_QCM_COLUMN( sParseColumn, sTableColumn );

        // default value를 기록한다.
        sParseColumn->defaultValueStr = sTableColumn->defaultValueStr;

        if ( sModifyColumn->basicInfo == NULL )
        {
            // data type을 명시하지 않았음을 설정한다.
            sModifyColumn->flag &= ~QCM_COLUMN_MODIFY_DATA_TYPE_MASK;
            sModifyColumn->flag |= QCM_COLUMN_MODIFY_DATA_TYPE_FALSE;

            // basicInfo는 복사 생성한다.
            IDU_LIMITPOINT("qdbAlter::validateModifyCol::malloc2");
            IDE_TEST( QC_QMP_MEM(aStatement)->alloc(
                          ID_SIZEOF(mtcColumn),
                          (void**) & sModifyColumn->basicInfo )
                      != IDE_SUCCESS );

            idlOS::memcpy( (void*) sModifyColumn->basicInfo,
                           (void*) sTableColumn->basicInfo,
                           ID_SIZEOF(mtcColumn) );

            // encryption을 설정한 경우
            if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_ENCRYPT_COLUMN_MASK)
                 == QCM_COLUMN_MODIFY_ENCRYPT_COLUMN_TRUE )
            {
                IDE_TEST( qtc::changeColumn4Encrypt(
                              aStatement,
                              sModifyColumn->encryptAttr,
                              sModifyColumn->basicInfo )
                          != IDE_SUCCESS );

                // modify column name을 설정한다.
                idlOS::strncpy( sModifyColumn->name,
                                sTableColumn->name,
                                QC_MAX_OBJECT_NAME_LEN + 1 );
                sModifyColumn->name[QC_MAX_OBJECT_NAME_LEN] = '\0';
            }
            else
            {
                // Nothing to do.
            }

            // decryption을 설정한 경우
            if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_DECRYPT_COLUMN_MASK)
                 == QCM_COLUMN_MODIFY_DECRYPT_COLUMN_TRUE )
            {
                IDE_TEST( qtc::changeColumn4Decrypt(
                              sModifyColumn->basicInfo )
                          != IDE_SUCCESS );

                // modify column name을 설정한다.
                idlOS::strncpy( sModifyColumn->name,
                                sTableColumn->name,
                                QC_MAX_OBJECT_NAME_LEN + 1 );
            }
            else
            {
                // Nothing to do.
            }
        }
        else
        {
            // data type을 명시했음을 설정한다.
            sModifyColumn->flag &= ~QCM_COLUMN_MODIFY_DATA_TYPE_MASK;
            sModifyColumn->flag |= QCM_COLUMN_MODIFY_DATA_TYPE_TRUE;

            // basicInfo의 column.id를 설정한다.
            sModifyColumn->basicInfo->column.id =
                sTableColumn->basicInfo->column.id;

            // modify column name을 설정한다.
            idlOS::strncpy( sModifyColumn->name,
                            sTableColumn->name,
                            QC_MAX_OBJECT_NAME_LEN + 1 );
        }

        sTableColumnInfo = sParseColumn->basicInfo;
        sModifyColumnInfo = sModifyColumn->basicInfo;

        //-----------------------------------------
        // 5.1. PROJ-2264 Dictionary table
        //      Compression column 은 default value 변경만 가능하다.
        //-----------------------------------------

        if ( (sTableColumnInfo->column.flag & SMI_COLUMN_COMPRESSION_MASK)
             == SMI_COLUMN_COMPRESSION_TRUE )
        {
            if ( ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_DATA_TYPE_MASK)
                   == QCM_COLUMN_MODIFY_DATA_TYPE_FALSE ) &&
                 ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_NULLABLE_MASK)
                   == QCM_COLUMN_MODIFY_NULLABLE_NONE ) &&
                 ( sModifyColumn->defaultValue != NULL ) )
            {
                // type 변경 혹은 length 변경이 아니고
                // (not)null 변경이 아니고
                // default value만 변경하는 경우

                // Nothing to do.
            }
            else
            {
                sqlInfo.setSourceInfo( aStatement,
                                       &(sModifyColumn->namePos) );
                IDE_RAISE( ERR_MODIFY_COMPRESSION_COLUMN );
            }
        }
        else
        {
            // Nothing to do.
        }

        //-----------------------------------------
        // 6. (not)null constraint가 이미 존재하는지 체크
        //-----------------------------------------

        if  ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_NULLABLE_MASK)
              == QCM_COLUMN_MODIFY_NULLABLE_NULL )
        {
            // 이미 nullable인데 null을 설정하면 에러
            IDE_TEST_RAISE( (sTableColumnInfo->flag & MTC_COLUMN_NOTNULL_MASK)
                            == MTC_COLUMN_NOTNULL_FALSE,
                            ERR_NOT_EXIST_NOT_NULL );

            // primary key에 null을 설정하면 에러
            if ( sParseTree->tableInfo->primaryKey != NULL )
            {
                IDE_TEST_RAISE(
                    qdn::intersectColumn(
                        (UInt*) smiGetIndexColumns(sParseTree->tableInfo->primaryKey->indexHandle),
                        sParseTree->tableInfo->primaryKey->keyColCount,
                        & sModifyColumnInfo->column.id, 1 ) == ID_TRUE,
                    ERR_NOT_ALLOWED_DROP_NOT_NULL );
            }
            else
            {
                // Nothing to do.
            }
        }
        else if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_NULLABLE_MASK)
                  == QCM_COLUMN_MODIFY_NULLABLE_NOTNULL )
        {
            // 이미 not null인데 not null을 설정하면 에러
            IDE_TEST_RAISE( (sTableColumnInfo->flag & MTC_COLUMN_NOTNULL_MASK)
                            == MTC_COLUMN_NOTNULL_TRUE,
                            ERR_EXIST_NOT_NULL );
        }
        else
        {
            // Nothing to do.
        }

        //-----------------------------------------
        // 7. 테이블 컬럼이 blob, clob, timestamp type이면 에러 반환
        // 8. 변경할 컬럼이 blob, clob, timestamp type이면 에러 반환
        //-----------------------------------------

        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_DATA_TYPE_MASK)
             == QCM_COLUMN_MODIFY_DATA_TYPE_TRUE )
        {
            // blob, clob, geometry
            IDE_TEST_RAISE( (sTableColumnInfo->module->id == MTD_BLOB_ID) ||
                            (sTableColumnInfo->module->id == MTD_CLOB_ID),
                            ERR_ABORT_QDB_INVALID_MODIFICATION );

            // timestamp
            IDE_TEST_RAISE( (sTableColumnInfo->flag & MTC_COLUMN_TIMESTAMP_MASK)
                            == MTC_COLUMN_TIMESTAMP_TRUE,
                            ERR_ABORT_QDB_INVALID_MODIFICATION );

            // blob, clob, geometry
            IDE_TEST_RAISE( (sModifyColumnInfo->module->id == MTD_BLOB_ID) ||
                            (sModifyColumnInfo->module->id == MTD_CLOB_ID),
                            ERR_ABORT_QDB_INVALID_MODIFICATION );

            // timestamp
            IDE_TEST_RAISE( (sModifyColumnInfo->flag & MTC_COLUMN_TIMESTAMP_MASK)
                            == MTC_COLUMN_TIMESTAMP_TRUE,
                            ERR_ABORT_QDB_INVALID_MODIFICATION );

            // geometry 타입은 data type 변경할 수 없고,
            // length 변경만 가능함
            IDE_TEST_RAISE(
                ( ( (sTableColumnInfo->module->id == MTD_GEOMETRY_ID) &&
                    (sModifyColumnInfo->module->id != MTD_GEOMETRY_ID) ) ||
                  ( (sTableColumnInfo->module->id != MTD_GEOMETRY_ID) &&
                    (sModifyColumnInfo->module->id == MTD_GEOMETRY_ID) ) ),
                ERR_ABORT_QDB_INVALID_MODIFICATION );
        }
        else
        {
            // Nothing to do.
        }

        //-----------------------------------------
        // 8.5.1 char, varchar 이외의 type은 encrypt로 modify할 수 없음
        //-----------------------------------------

        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_ENCRYPT_COLUMN_MASK)
             == QCM_COLUMN_MODIFY_ENCRYPT_COLUMN_TRUE )
        {
            // char, varchar
            IDE_TEST_RAISE( (sTableColumnInfo->module->id != MTD_CHAR_ID) &&
                            (sTableColumnInfo->module->id != MTD_VARCHAR_ID),
                            ERR_ABORT_QDB_INVALID_MODIFICATION );

            sIsValid = ID_FALSE;

            // BUG-26877 DDL구문에 대한 보안 권한 추가
            IDE_TEST( qcsModule::checkSecurityPrivilege( aStatement,
                                                         sParseTree->tableInfo,
                                                         sModifyColumn,
                                                         ID_TRUE,
                                                         ID_TRUE,
                                                         ID_FALSE,
                                                         & sIsValid )
                      != IDE_SUCCESS );

            IDE_TEST_RAISE( sIsValid != ID_TRUE,
                            ERR_NOT_ALLOWED_ENCRYPTED_COLUMN_ACCESS );
        }
        else
        {
            // Nothing to do.
        }

        //-----------------------------------------
        // 8.5.2 echar, evarchar 이외의 type은 decrypt로 modify할 수 없음
        //-----------------------------------------

        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_DECRYPT_COLUMN_MASK)
             == QCM_COLUMN_MODIFY_DECRYPT_COLUMN_TRUE )
        {
            // echar, evarchar
            IDE_TEST_RAISE( (sTableColumnInfo->module->id != MTD_ECHAR_ID) &&
                            (sTableColumnInfo->module->id != MTD_EVARCHAR_ID),
                            ERR_ABORT_QDB_INVALID_MODIFICATION );

            sIsValid = ID_FALSE;

            // BUG-26877 DDL구문에 대한 보안 권한 추가
            IDE_TEST( qcsModule::checkSecurityPrivilege( aStatement,
                                                         sParseTree->tableInfo,
                                                         sModifyColumn,
                                                         ID_TRUE,
                                                         ID_FALSE,
                                                         ID_TRUE,
                                                         & sIsValid )
                      != IDE_SUCCESS );

            IDE_TEST_RAISE( sIsValid != ID_TRUE,
                            ERR_NOT_ALLOWED_ENCRYPTED_COLUMN_ACCESS );
        }
        else
        {
            // Nothing to do.
        }

        //-----------------------------------------
        // 8.5.3. echar, evarchar type은 type, length 변경 불가
        //-----------------------------------------

        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_DATA_TYPE_MASK)
             == QCM_COLUMN_MODIFY_DATA_TYPE_TRUE )
        {
            // echar, evarchar
            IDE_TEST_RAISE( (sTableColumnInfo->module->id == MTD_ECHAR_ID) ||
                            (sTableColumnInfo->module->id == MTD_EVARCHAR_ID),
                            ERR_ABORT_QDB_INVALID_MODIFICATION );
        }
        else
        {
            // Nothing to do.
        }

        //-----------------------------------------
        // 9. 테이블 컬럼이 참조하고 있는 foreign key가 있다면 length 확대만 가능
        //-----------------------------------------

        // BUGBUG
        // foreign key가 걸려있다고해서 length 확대만 가능한 것이 아니라
        // data loss가 발생하지 않으면 모두 가능하다.

        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_DATA_TYPE_MASK)
             == QCM_COLUMN_MODIFY_DATA_TYPE_TRUE )
        {
            for ( i = 0; i < sParseTree->tableInfo->foreignKeyCount; i++ )
            {
                if ( qdn::intersectColumn(
                         sParseTree->tableInfo->foreignKeys[i].referencingColumn,
                         sParseTree->tableInfo->foreignKeys[i].constraintColumnCount,
                         & sTableColumnInfo->column.id,
                         1 )
                     == ID_TRUE )
                {
                    if ( sTableColumnInfo->module->id != sModifyColumnInfo->module->id )
                    {
                        // type 변경은 불가능하다.
                        IDE_RAISE( ERR_ABORT_QDB_INVALID_MODIFICATION );
                    }
                    else
                    {
                        // length 변경은 확대만 가능하다.
                        // (padding type이라하더라도 equal 연산시 padding 문자는 비교되지
                        // 않으므로 char(5)가 char(10)으로 변경되더라도 fk constraint는
                        // 깨지지 않는다.)
                        if ( (sTableColumnInfo->module->flag & MTD_CREATE_PARAM_MASK)
                             == MTD_CREATE_PARAM_PRECISION )
                        {
                            IDE_TEST_RAISE( sTableColumnInfo->precision >
                                            sModifyColumnInfo->precision,
                                            ERR_ABORT_QDB_INVALID_MODIFICATION );
                        }
                        else if ( (sTableColumnInfo->module->flag & MTD_CREATE_PARAM_MASK)
                                  == MTD_CREATE_PARAM_PRECISIONSCALE )
                        {
                            IDE_TEST_RAISE( isEnlargingLengthForNumericType(
                                                sTableColumnInfo->precision,
                                                sTableColumnInfo->scale,
                                                sModifyColumnInfo->precision,
                                                sModifyColumnInfo->scale )
                                            == ID_FALSE,
                                            ERR_ABORT_QDB_INVALID_MODIFICATION );
                        }
                        else
                        {
                            // Nothing to do.
                        }
                    }
                }
                else
                {
                    // Nothing to do.
                }
            }
        }
        else
        {
            // Nothing to do.
        }

        //-----------------------------------------
        // 10. 테이블 컬럼을 참조하고 있는 foreign key가 있다면 length 확대만 가능
        //-----------------------------------------

        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_DATA_TYPE_MASK)
             == QCM_COLUMN_MODIFY_DATA_TYPE_TRUE )
        {
            for ( i = 0; i < sParseTree->tableInfo->uniqueKeyCount; i++ )
            {
                sIndexInfo = sParseTree->tableInfo->uniqueKeys[i].constraintIndex;

                if ( qdn::intersectColumn(
                         (UInt*) smiGetIndexColumns(sIndexInfo->indexHandle),
                         sIndexInfo->keyColCount,
                         & sTableColumnInfo->column.id,
                         1 )
                     == ID_TRUE )
                {
                    IDE_TEST( qcm::getChildKeys( aStatement,
                                                 sIndexInfo,
                                                 sParseTree->tableInfo,
                                                 & sChildInfo )
                              != IDE_SUCCESS );

                    if ( sChildInfo != NULL )
                    {
                        if ( sTableColumnInfo->module->id != sModifyColumnInfo->module->id )
                        {
                            // type 변경은 불가능하다.
                            IDE_RAISE( ERR_ABORT_QDB_INVALID_MODIFICATION );
                        }
                        else
                        {
                            // length 변경은 확대만 가능하다.
                            // (padding type이라하더라도 equal 연산시 padding 문자는 비교되지
                            // 않으므로 char(5)가 char(10)으로 변경되더라도 fk constraint는
                            // 깨지지 않는다.)
                            if ( (sTableColumnInfo->module->flag & MTD_CREATE_PARAM_MASK)
                                 == MTD_CREATE_PARAM_PRECISION )
                            {
                                IDE_TEST_RAISE( sTableColumnInfo->precision >
                                                sModifyColumnInfo->precision,
                                                ERR_ABORT_QDB_INVALID_MODIFICATION );
                            }
                            else if ( (sTableColumnInfo->module->flag & MTD_CREATE_PARAM_MASK)
                                      == MTD_CREATE_PARAM_PRECISIONSCALE )
                            {
                                IDE_TEST_RAISE( isEnlargingLengthForNumericType(
                                                    sTableColumnInfo->precision,
                                                    sTableColumnInfo->scale,
                                                    sModifyColumnInfo->precision,
                                                    sModifyColumnInfo->scale )
                                                == ID_FALSE,
                                                ERR_ABORT_QDB_INVALID_MODIFICATION );
                            }
                            else
                            {
                                // Nothing to do.
                            }
                        }
                    }
                    else
                    {
                        // Nothing to do.
                    }
                }
                else
                {
                    // Nothing to do.
                }
            }
        }
        else
        {
            // Nothing to do.
        }

        //-----------------------------------------
        // 14. partition key인 경우 length 확대만 가능
        //-----------------------------------------

        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_DATA_TYPE_MASK)
             == QCM_COLUMN_MODIFY_DATA_TYPE_TRUE )
        {
            if ( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
            {
                for ( i = 0; i < sParseTree->tableInfo->partKeyColCount; i++ )
                {
                    if ( sParseTree->tableInfo->partKeyColBasicInfo[i].column.id
                         == sTableColumnInfo->column.id )
                    {
                        if ( sTableColumnInfo->module->id != sModifyColumnInfo->module->id )
                        {
                            // type 변경은 불가능하다.
                            IDE_RAISE( ERR_ABORT_QDB_INVALID_MODIFICATION );
                        }
                        else
                        {
                            // length 변경은 확대만 가능하다.
                            // (padding type이라하더라도 equal 연산시 padding 문자는 비교되지
                            // 않으므로 char(5)가 char(10)으로 변경되더라도 값은
                            // 깨지지 않는다.)
                            if ( (sTableColumnInfo->module->flag & MTD_CREATE_PARAM_MASK)
                                 == MTD_CREATE_PARAM_PRECISION )
                            {
                                IDE_TEST_RAISE( sTableColumnInfo->precision >
                                                sModifyColumnInfo->precision,
                                                ERR_ABORT_QDB_INVALID_MODIFICATION );
                            }
                            else if ( (sTableColumnInfo->module->flag & MTD_CREATE_PARAM_MASK)
                                      == MTD_CREATE_PARAM_PRECISIONSCALE )
                            {
                                IDE_TEST_RAISE( isEnlargingLengthForNumericType(
                                                    sTableColumnInfo->precision,
                                                    sTableColumnInfo->scale,
                                                    sModifyColumnInfo->precision,
                                                    sModifyColumnInfo->scale )
                                                == ID_FALSE,
                                                ERR_ABORT_QDB_INVALID_MODIFICATION );
                            }
                            else
                            {
                                // Nothing to do.
                            }
                        }
                    }
                    else
                    {
                        // Nothing to do.
                    }
                }
            }
            else
            {
                // Nothing to do.
            }
        }
        else
        {
            // Nothing to do.
        }

        //-----------------------------------------
        // 11. 타입 변환 matrix에 따라 적용여부 검사
        //-----------------------------------------

        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_DATA_TYPE_MASK)
             == QCM_COLUMN_MODIFY_DATA_TYPE_TRUE )
        {
            //-----------------------------------------
            // a. MISC GROUP type 검사
            //-----------------------------------------

            // binary, blob, byte, clob, nibble type은 type 변경 불가하다.
            if ( sTableColumnInfo->module->id != sModifyColumnInfo->module->id )
            {
                IDE_TEST_RAISE( (sTableColumnInfo->module->flag & MTD_GROUP_MASK)
                                == MTD_GROUP_MISC,
                                ERR_ABORT_QDB_INVALID_MODIFICATION );
            }
            else
            {
                // Nothing to do.
            }
        }
        else
        {
            // Nothing to do.
        }

        //-----------------------------------------
        // 12. 컬럼에 대한 modify 기능 flag 설정
        //-----------------------------------------

        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_DATA_TYPE_MASK)
             == QCM_COLUMN_MODIFY_DATA_TYPE_TRUE )
        {
            if ( sTableColumnInfo->module->id != sModifyColumnInfo->module->id )
            {
                // type 변경
                sModifyColumn->flag &= ~QCM_COLUMN_MODIFY_TYPE_MASK;
                sModifyColumn->flag |= QCM_COLUMN_MODIFY_TYPE_TRUE;

                // type 변경이지만 자료구조가 동일한 경우 length 변경으로
                // 간주할 수 있다.
                if ( ( (sTableColumnInfo->module->id == MTD_NCHAR_ID) &&
                       (sModifyColumnInfo->module->id == MTD_NVARCHAR_ID) )
                     ||
                     ( (sTableColumnInfo->module->id == MTD_NVARCHAR_ID) &&
                       (sModifyColumnInfo->module->id == MTD_NCHAR_ID) )
                     ||
                     ( (sTableColumnInfo->module->id == MTD_CHAR_ID) &&
                       (sModifyColumnInfo->module->id == MTD_VARCHAR_ID) )
                     ||
                     ( (sTableColumnInfo->module->id == MTD_VARCHAR_ID) &&
                       (sModifyColumnInfo->module->id == MTD_CHAR_ID) )
                     ||
                     ( (sTableColumnInfo->module->id == MTD_BIT_ID) &&
                       (sModifyColumnInfo->module->id == MTD_VARBIT_ID) )
                     ||
                     ( (sTableColumnInfo->module->id == MTD_VARBIT_ID) &&
                       (sModifyColumnInfo->module->id == MTD_BIT_ID) )
                     ||
                     ( (sTableColumnInfo->module->id == MTD_FLOAT_ID) &&
                       (sModifyColumnInfo->module->id == MTD_NUMERIC_ID) )
                     ||
                     ( (sTableColumnInfo->module->id == MTD_NUMERIC_ID) &&
                       (sModifyColumnInfo->module->id == MTD_FLOAT_ID) )
                     )
                {
                    // length 변경
                    sModifyColumn->flag &= ~QCM_COLUMN_MODIFY_LENGTH_MASK;
                    sModifyColumn->flag |= QCM_COLUMN_MODIFY_LENGTH_TRUE;
                }
                else
                {
                    // Nothing to do.
                }
            }
            else
            {
                if ( (sTableColumnInfo->module->flag & MTD_CREATE_PARAM_MASK)
                     != MTD_CREATE_PARAM_NONE )
                {
                    // length 변경
                    sModifyColumn->flag &= ~QCM_COLUMN_MODIFY_LENGTH_MASK;
                    sModifyColumn->flag |= QCM_COLUMN_MODIFY_LENGTH_TRUE;
                }
                else
                {
                    // Nothing to do.
                }
            }
        }
        else
        {
            // Nothing to do.
        }

        sParseColumn = sParseColumn->next;
        sModifyColumn = sModifyColumn->next;
    }

    //-----------------------------------------
    // 13. 컬럼, not null constraint validation
    //-----------------------------------------

    // decide column type
    IDE_TEST( qdbCommon::validateColumnListForModifyCol( aStatement,
                                                         sParseTree->tableInfo,
                                                         sParseTree->modifyColumns )
              != IDE_SUCCESS);

    // check not null constraint
    // (tableInfo에서 constraints의 column 정보를 채운다.)
    IDE_TEST( qdn::validateConstraints( aStatement,
                                        sParseTree->tableInfo,
                                        sParseTree->tableInfo->tableOwnerID,
                                        sParseTree->tableInfo->TBSID,
                                        sParseTree->tableInfo->TBSType,
                                        sParseTree->constraints,
                                        QDN_ON_MODIFY_COLUMN,
                                        NULL )
              != IDE_SUCCESS );

    //-----------------------------------------
    // 15. check constraint를 가진 컬럼의 Data Type/Length를 변경하면 에러 반환
    //-----------------------------------------
    /* PROJ-1107 Check Constraint 지원 */
    for ( sModifyColumn = sParseTree->modifyColumns;
          sModifyColumn != NULL;
          sModifyColumn = sModifyColumn->next )
    {
        if ( ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_TYPE_MASK)
                                   != QCM_COLUMN_MODIFY_TYPE_TRUE ) &&
             ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_LENGTH_MASK)
                                   != QCM_COLUMN_MODIFY_LENGTH_TRUE ) )
        {
            continue;
        }
        else
        {
            /* Nothing to do */
        }

        IDE_TEST( qdnCheck::addCheckConstrSpecRelatedToColumn(
                                aStatement,
                                &sCheckConstrSpecList,
                                sParseTree->tableInfo->checks,
                                sParseTree->tableInfo->checkCount,
                                sModifyColumn->basicInfo->column.id )
                  != IDE_SUCCESS );

        if ( sCheckConstrSpecList != NULL )
        {
            sqlInfo.setSourceInfo( aStatement,
                                   &(sModifyColumn->namePos) );
            IDE_RAISE( ERR_MODIFY_COLUMN_HAVING_CHECK_CONSTRAINT );
        }
        else
        {
            /* Nothing to do */
        }
    }

    //-----------------------------------------
    // 16. Hidden Column을 변경할 수 없다.
    //     Hidden Column의 Expression에 포함된 Column을 변경할 수 없다.
    //-----------------------------------------
    
    /* PROJ-1090 Function-based Index */
    for ( sModifyColumn = sParseTree->modifyColumns,
              sParseColumn = sParseTree->columns;
          sModifyColumn != NULL;
          sModifyColumn = sModifyColumn->next,
              sParseColumn = sParseColumn->next )
    {
        if ( ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_TYPE_MASK)
               != QCM_COLUMN_MODIFY_TYPE_TRUE ) &&
             ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_LENGTH_MASK)
               != QCM_COLUMN_MODIFY_LENGTH_TRUE ) )
        {
            continue;
        }
        else
        {
            /* Nothing to do */
        }

        /* Hidden Column을 변경할 수 없다. */
        if ( (sParseColumn->flag & QCM_COLUMN_HIDDEN_COLUMN_MASK)
             == QCM_COLUMN_HIDDEN_COLUMN_TRUE )
        {
            sqlInfo.setSourceInfo( aStatement,
                                   &(sModifyColumn->namePos) );
            IDE_RAISE( ERR_MODIFY_HIDDEN_COLUMN );
        }
        else
        {
            /* Nothing to do */
        }

        /* Hidden Column의 Expression에 포함된 Column을 변경할 수 없다. */
        IDE_TEST( qmsDefaultExpr::addDefaultExpressionColumnsRelatedToColumn(
                      aStatement,
                      & sDefaultExprColumns,
                      sParseTree->tableInfo,
                      sParseColumn->basicInfo->column.id )
                  != IDE_SUCCESS );
        
        if ( sDefaultExprColumns != NULL )
        {
            sqlInfo.setSourceInfo( aStatement,
                                   &(sModifyColumn->namePos) );
            IDE_RAISE( ERR_MODIFY_HIDDEN_COLUMN );
        }
        else
        {
            /* Nothing to do */
        }
    }
    
    //-----------------------------------------
    // 11. 타입 변환 matrix에 따라 적용여부 검사
    //-----------------------------------------

    sParseColumn = sParseTree->columns;
    sModifyColumn = sParseTree->modifyColumns;

    while ( sParseColumn != NULL )
    {
        IDE_DASSERT( sModifyColumn != NULL );

        sqlInfo.setSourceInfo( aStatement,
                               & sParseColumn->namePos );

        sTableColumnInfo = sParseColumn->basicInfo;
        sModifyColumnInfo = sModifyColumn->basicInfo;

        //-----------------------------------------
        // b. 저장옵션 변경 flag 설정
        //-----------------------------------------

        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_DATA_TYPE_MASK)
             == QCM_COLUMN_MODIFY_DATA_TYPE_TRUE )
        {
            // 저장 옵션의 경우 type에 상관없이 모두 동일하다.

            // 예)
            // char variable -> varchar fixed
            // char variable -> char fixed
            // int variable -> double fixed

            if ( ( (sTableColumnInfo->column.flag & SMI_COLUMN_TYPE_MASK)
                   != (sModifyColumnInfo->column.flag & SMI_COLUMN_TYPE_MASK) ) ||
                 ( sTableColumnInfo->column.vcInOutBaseSize
                   != sModifyColumnInfo->column.vcInOutBaseSize ) )
            {
                // column option 변경
                sModifyColumn->flag &= ~QCM_COLUMN_MODIFY_COLUMN_OPTION_MASK;
                sModifyColumn->flag |= QCM_COLUMN_MODIFY_COLUMN_OPTION_TRUE;
            }
            else
            {
                // Nothing to do.
            }
        }
        else
        {
            // Nothing to do.
        }

        //-----------------------------------------
        // c. encrypt 혹은 decrypt인 경우
        //-----------------------------------------

        if ( ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_ENCRYPT_COLUMN_MASK)
               == QCM_COLUMN_MODIFY_ENCRYPT_COLUMN_TRUE ) ||
             ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_DECRYPT_COLUMN_MASK)
               == QCM_COLUMN_MODIFY_DECRYPT_COLUMN_TRUE ) )
        {
            // encrypt 혹은 decrypt로의 modify인 경우도 저장 옵션이
            // 변경되는 것으로 간주하여 recreate table을 수행한다.

            // 예)
            // char -> echar
            // evarchar -> varchar

            // column option 변경
            sModifyColumn->flag &= ~QCM_COLUMN_MODIFY_COLUMN_OPTION_MASK;
            sModifyColumn->flag |= QCM_COLUMN_MODIFY_COLUMN_OPTION_TRUE;
        }
        else
        {
            // Nothing to do.
        }

        sParseColumn = sParseColumn->next;
        sModifyColumn = sModifyColumn->next;
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_EXIST_NOT_NULL );
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_EXIST_NOT_NULL));
    }
    IDE_EXCEPTION( ERR_NOT_EXIST_NOT_NULL );
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_NOT_EXIST_NOT_NULL));
    }
    IDE_EXCEPTION( ERR_NOT_ALLOWED_DROP_NOT_NULL );
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_NOT_ALLOWED_DROP_NOT_NULL));
    }
    IDE_EXCEPTION(ERR_NOT_ALLOWED_ENCRYPTED_COLUMN_ACCESS)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_NOT_ALLOWED_ENCRYPTED_COLUMN_ACCESS));
    }
    IDE_EXCEPTION( ERR_ABORT_QDB_INVALID_MODIFICATION )
    {
        (void)sqlInfo.init(aStatement->qmeMem);
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_INVALID_MODIFICATION,
                                sqlInfo.getErrMessage()));
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION( ERR_MODIFY_COLUMN_HAVING_CHECK_CONSTRAINT );
    {
        (void)sqlInfo.init( aStatement->qmeMem );
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_NOT_ALLOWED_COLUMN_HAVING_CHECK_CONSTRAINT,
                                  sqlInfo.getErrMessage() ) );
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION( ERR_MODIFY_HIDDEN_COLUMN );
    {
        (void)sqlInfo.init( aStatement->qmeMem );
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_CANNOT_ALTER_HIDDEN_COLUMN,
                                  sqlInfo.getErrMessage() ) );
        (void)sqlInfo.fini();
    }
    // PROJ-2264 Dictionary table
    IDE_EXCEPTION( ERR_MODIFY_COMPRESSION_COLUMN );
    {
        (void)sqlInfo.init( aStatement->qmeMem );
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_CANNOT_ALTER_COMPRESSION_COLUMN,
                                  sqlInfo.getErrMessage() ) );
        (void)sqlInfo.fini();
    }
    /* PROJ-2464 hybrid partitioned table 지원 */
    IDE_EXCEPTION( ERR_UNSUPPORT_ON_HYBRID_PARTITIONED_TABLE );
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_CANNOT_SUPPORT_ON_HYBRID_PARTITIONED_TABLE ) );
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::executeModifyCol( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description : PROJ-1877
 *    ALTER TABLE ... MODIFY COLUMN ...;
 *
 * Implementation :
 *    1. modify method 결정 - 1단계
 *       table schema만으로 modify method를 결정한다.
 *       a. method 1: alter meta
 *       b. method 2: alter meta and index
 *       c. method 3: recreate table
 *
 *    2. modify method 결정 - 2단계
 *       table scan으로 column의 value를 확인하고
 *       modify method를 최종 결졍한다.
 *
 *    3. modify method 수행
 *
 *    type 변환시 data loss 옵션을 사용하는 경우 서로 다른 type간의
 *    변환이 가능하다. 이는 data loss 에러를 실시간으로 detect할 수
 *    없기 때문에 추가된 기능이다. 이것은 다음과 같은 단점이 있다.
 *      a. data loss 에러가 발생하지만 사용자는 알 수 없다.
 *      b. column이 unique index, uk, pk에 속한 경우 type 변환후
 *         data loss에 의해 index 생성이 불가능하여 DDL이 실패할 수 있다.
 *
 ***********************************************************************/

    qdTableParseTree      * sParseTree;
    qcmPartitionInfoList  * sPartInfoList;
    qcmPartitionInfoList  * sOldPartInfoList = NULL;
    qcmPartitionInfoList  * sNewPartInfoList = NULL;
    qcmTableInfo          * sPartInfo;
    UInt                    sPartCount = 0;
    qdTblColModifyMethod    sMethod;      // for non-partitioned table
    qdTblColModifyMethod  * sPartMethod;  // for partitioned table
    qdVerifyColumn        * sVerifyColumn;
    qcmTableInfo          * sOldTableInfo = NULL;
    qcmTableInfo          * sNewTableInfo = NULL;
    qcmTableInfo         ** sNewPartInfo = NULL;
    qcmColumn             * sColumn;
    qdIndexTableList      * sIndexTable;
    qdIndexTableList      * sDelIndexTables = NULL;
    smOID                 * sOldPartitionOID = NULL;
    UInt                    sOldPartitionCount = 0;
    UInt                    i = 0;
    smOID                   sOldTableOID = 0;
    smOID                   sNewTableOID = 0;
    idBool                  sIsReplicatedTable = ID_FALSE;
    smOID                 * sOldTableOIDArray = NULL;
    smOID                 * sNewTableOIDArray = NULL;
    UInt                    sTableOIDCount = 0;
    UInt                    sDDLSupplementalLog = QCU_DDL_SUPPLEMENTAL_LOG;
    idBool                  sCheckReplication = ID_FALSE;

    sParseTree    = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // BUG-43292 DDL / DDL partiton 연산시 최신 viewSCN을 보지 못함
    IDU_FIT_POINT( "qdbAlter::executeModifyCol::beforeXLock" );

    // TASK-2176
    // Table에 대한 Lock을 획득한다.
    IDE_TEST( qcm::validateAndLockTable( aStatement,
                                         sParseTree->tableHandle,
                                         sParseTree->tableSCN,
                                         SMI_TABLE_LOCK_X )
              != IDE_SUCCESS );

    sOldTableInfo = sParseTree->tableInfo;
    sOldTableOID = smiGetTableId( sOldTableInfo->tableHandle );

    // PROJ-1407 Temporary table
    // session temporary table이 존재하는 경우 DDL을 할 수 없다.
    IDE_TEST_RAISE( qcuTemporaryObj::existSessionTable( sOldTableInfo ) == ID_TRUE,
                    ERR_SESSION_TEMPORARY_TABLE_EXIST );

    // Partitioned Table의 각 Partition에 대한 Lock을 획득한다.
    if ( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        /* BUG-42681 valgrind split 중 add column 동시성 문제 */
        IDE_TEST( qcmPartition::checkPartitionCount4Execute( aStatement,
                                                             sParseTree->partTable->partInfoList,
                                                             sOldTableInfo->tableID )
                  != IDE_SUCCESS );

        // 모든 파티션에 LOCK(X)
        IDE_TEST( qcmPartition::validateAndLockPartitionInfoList( aStatement,
                                                                  sParseTree->partTable->partInfoList,
                                                                  SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                                  SMI_TABLE_LOCK_X,
                                                                  ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                                    ID_ULONG_MAX :
                                                                    smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );
        
        // 예외 처리를 위하여, Lock을 잡은 후에 Partition List를 설정한다.
        sOldPartInfoList = sParseTree->partTable->partInfoList;

        // PROJ-1624 non-partitioned index
        IDE_TEST( qdx::validateAndLockIndexTableList( aStatement,
                                                      sParseTree->oldIndexTables,
                                                      SMI_TBSLV_DDL_DML,
                                                      SMI_TABLE_LOCK_X,
                                                      ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                        ID_ULONG_MAX :
                                                        smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );

        if ( ( sOldTableInfo->replicationCount > 0 ) ||
             ( sDDLSupplementalLog == 1 ) )
        {
            IDE_TEST( qcmPartition::getAllPartitionOID( QC_QMX_MEM(aStatement),
                                                        sOldPartInfoList,
                                                        &sOldPartitionOID,
                                                        &sOldPartitionCount )
                      != IDE_SUCCESS );
        }
        else
        {
            /* do nothing */
        }
    }
    else
    {
        // Nothing to do.
    }

    // PROJ-2642 Table on Replication Allow DDL
    if ( sOldTableInfo->replicationCount > 0 )
    {
        sCheckReplication = ID_FALSE;
        sColumn = sParseTree->modifyColumns;
        while ( sColumn != NULL )
        {
            /* primaryKey 는 변경 불가 */
            IDE_TEST_RAISE( qdn::intersectColumn( 
                    (UInt*)smiGetIndexColumns( sParseTree->tableInfo->primaryKey->indexHandle ),
                    sParseTree->tableInfo->primaryKey->keyColCount,
                    &(sColumn->basicInfo->column.id),
                    1 ) == ID_TRUE, ERR_MODIFY_COLUMN_IN_PRIMARY_KEY );

            if ( ( ( sColumn->flag & QCM_COLUMN_MODIFY_DATA_TYPE_MASK ) 
                   == QCM_COLUMN_MODIFY_DATA_TYPE_FALSE ) &&
                 ( ( sColumn->flag & QCM_COLUMN_MODIFY_NULLABLE_MASK ) 
                   == QCM_COLUMN_MODIFY_NULLABLE_NONE ) &&
                 ( sColumn->defaultValue != NULL ) &&
                 ( sCheckReplication == ID_FALSE ) )
            {
                /* do nothing */
            }
            else
            {
                /* 이중화 대상 테이블의 경우 보안 컬럼으로 변경 불가 */
                IDE_TEST_RAISE( (sColumn->flag & QCM_COLUMN_MODIFY_ENCRYPT_COLUMN_MASK)
                                == QCM_COLUMN_MODIFY_ENCRYPT_COLUMN_TRUE,
                                ERR_MODIFY_COLUMN_TO_ENCRYPT );

                sCheckReplication = ID_TRUE;
            }

            sColumn = sColumn->next;
        }

        if ( sCheckReplication == ID_TRUE )
        {
            IDE_TEST( qci::mManageReplicationCallback.mIsDDLEnableOnReplicatedTable( 1,
                                                                                     sOldTableInfo )
                      != IDE_SUCCESS );

            IDE_TEST_RAISE( QC_SMI_STMT( aStatement )->getTrans()->getReplicationMode() == SMI_TRANSACTION_REPL_NONE,
                            ERR_CANNOT_WRITE_REPL_INFO );

            if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
            {
                sOldTableOIDArray = sOldPartitionOID;
                sTableOIDCount = sOldPartitionCount;
            }
            else
            {
                sOldTableOIDArray = &sOldTableOID;
                sTableOIDCount = 1;
            }

            IDE_TEST( qciMisc::checkRunningEagerReplicationByTableOID( aStatement,
                                                                       sOldTableOIDArray,
                                                                       sTableOIDCount )
                      != IDE_SUCCESS );

            IDE_TEST( qci::mManageReplicationCallback.mStopReceiverThreads( QC_SMI_STMT(aStatement),
                                                                            aStatement->mStatistics,
                                                                            sOldTableOIDArray,
                                                                            sTableOIDCount )
                      != IDE_SUCCESS );

            sIsReplicatedTable = ID_TRUE;
        }
        else
        {
            /* do nothing */
        }
    }
    else
    {
        /* do nothing */
    }

    // BUG-43292 DDL / DDL partiton 연산시 최신 viewSCN을 보지 못함
    IDE_TEST( smiStatement::setViewSCNOfAllStmt( QC_SMI_STMT( aStatement ) )
              != IDE_SUCCESS );

    //-----------------------------------------
    // modify method 결정 - 1단계
    //-----------------------------------------
    if ( ( smiTableSpace::isMemTableSpaceType( sParseTree->tableInfo->TBSType )
           == ID_TRUE ) ||
         ( smiTableSpace::isVolatileTableSpaceType( sParseTree->tableInfo->TBSType )
           == ID_TRUE ) )
    {
        // modify schema만으로 modify method 결정
        IDE_TEST( decideModifyMethodForMemory( aStatement,
                                               sParseTree->columns,
                                               sParseTree->modifyColumns,
                                               & sMethod,
                                               & sVerifyColumn )
                  != IDE_SUCCESS );
    }
    else
    {
        IDE_DASSERT( smiTableSpace::isDiskTableSpaceType(
                         sParseTree->tableInfo->TBSType )
                     == ID_TRUE );
        
        // modify schema만으로 modify method 결정
        IDE_TEST( decideModifyMethodForDisk( aStatement,
                                             sParseTree->columns,
                                             sParseTree->modifyColumns,
                                             & sMethod,
                                             & sVerifyColumn )
                  != IDE_SUCCESS );
    }

        if ( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
        {
            // partitioned table의 경우 각 partition에 대하여
            // 서로 다른 modify method가 결정될 수 있다.

            // sPartMethod를 sMethod로 초기화한다.
            sPartCount = 0;

            for( sPartInfoList = sOldPartInfoList;
                 sPartInfoList != NULL;
                 sPartInfoList = sPartInfoList->next )
            {
                sPartCount++;
            }

            IDE_DASSERT( sPartCount > 0 );

            IDU_LIMITPOINT( "qdbAlter::executeModifyCol::malloc1");
            IDE_TEST( aStatement->qmxMem->alloc(
                    ID_SIZEOF(qdTblColModifyMethod) * sPartCount,
                    (void**) & sPartMethod )
                != IDE_SUCCESS);

            // null로 초기화한다.
            IDU_LIMITPOINT( "qdbAlter::executeModifyCol::malloc2");
            IDE_TEST( aStatement->qmxMem->cralloc(
                    ID_SIZEOF(qcmTableInfo*) * sPartCount,
                    (void**) & sNewPartInfo )
                != IDE_SUCCESS);

            sPartCount = 0;

            for( sPartInfoList = sOldPartInfoList;
                 sPartInfoList != NULL;
                 sPartInfoList = sPartInfoList->next )
            {
                sPartMethod[sPartCount] = sMethod;

                sPartCount++;
            }

    }
    else
    {
        /* Nothing To Do */
    }

    //-----------------------------------------
    // modify method 결정 - 2단계
    //-----------------------------------------
    if ( ( smiTableSpace::isMemTableSpaceType( sParseTree->tableInfo->TBSType )
           == ID_TRUE ) ||
         ( smiTableSpace::isVolatileTableSpaceType( sParseTree->tableInfo->TBSType )
           == ID_TRUE ) )
    {
        if ( sVerifyColumn != NULL )
        {
            // memory table의 column을 읽어 modify가 가능한지 검사
            // memory table은 항상 recreate이므로 최종 modify method 결정하지 않는다.
            IDE_TEST( verifyColumnValue( aStatement,
                                         sParseTree->tableInfo,
                                         sVerifyColumn,
                                         & sMethod )
                      != IDE_SUCCESS );
        }
        else
        {
            // Nothing to do.
        }

        //-----------------------------------------
        // PROJ-2334 PMT
        // partitioned table modify method 결정 - 2단계
        // memory table은 column의 변경이 발생 하면 항상 recreate
        // not null, default 와 같은 변경시에만 meta modify로 수행.
        // 아래의 verifyColumnValue에서 파티션에대한 외의 처리만수행 하고
        // 파티션드 테이블의 method를 따라 수행 된다.
        //-----------------------------------------
        if ( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
        {    
            if ( sVerifyColumn != NULL )
            {
                // partition별로 column을 읽어 modify가 가능한지 검사하고
                // 최종 modify method 결정
                sPartCount = 0;

                for ( sPartInfoList = sOldPartInfoList;
                      sPartInfoList != NULL;
                      sPartInfoList = sPartInfoList->next )
                {
                    IDE_TEST( verifyColumnValue(
                                  aStatement,
                                  sPartInfoList->partitionInfo,
                                  sVerifyColumn,
                                  & sPartMethod[sPartCount] )
                              != IDE_SUCCESS );

                    sPartCount++;
                }
            }
            else
            {
                // Nothing to do.
            }
        }
        else
        {
            /* Nothing To Do */
        }
        
        //-----------------------------------------
        // modify method 수행
        // partitioned table인 경우에도 base table의 method 에 의해
        // 수행 된다.
        // 이유는 memory table은 column변경시 항상 recreate되기 때문이다.
        //-----------------------------------------

        switch ( sMethod )
        {
            case QD_TBL_COL_MODIFY_METHOD_NONE:

                // 아무것도 하지 않는다.
                break;

            case QD_TBL_COL_MODIFY_METHOD_ALTER_META:
                
                // meta 변경만으로 alter table modify column 기능수행
                IDE_TEST( alterMetaForMemory( aStatement,
                                              sParseTree,
                                              & sNewTableInfo,
                                              sNewPartInfo )
                          != IDE_SUCCESS );
                break;

            case QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE:

                // table 재생성으로 alter table modify column 기능수행
                IDE_TEST( recreateTableForMemory( aStatement,
                                                  sParseTree,
                                                  & sNewTableInfo,
                                                  sNewPartInfo )
                          != IDE_SUCCESS );
                break;

            default:
                IDE_DASSERT( 0 );
        }
    }
    else
    {
        if ( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
        {
            if ( sVerifyColumn != NULL )
            {
                // partition별로 column을 읽어 modify가 가능한지 검사하고
                // 최종 modify method 결정
                sPartCount = 0;

                for( sPartInfoList = sOldPartInfoList;
                     sPartInfoList != NULL;
                     sPartInfoList = sPartInfoList->next )
                {
                    IDE_TEST( verifyColumnValue(
                                  aStatement,
                                  sPartInfoList->partitionInfo,
                                  sVerifyColumn,
                                  & sPartMethod[sPartCount] )
                              != IDE_SUCCESS );

                    sPartCount++;
                }
            }
            else
            {
                // Nothing to do.
            }

            //-----------------------------------------
            // modify method 수행
            //-----------------------------------------

            // meta 변경만으로 alter table modify column 기능수행
            IDE_TEST( alterMetaForDisk( aStatement,
                                        sParseTree,
                                        & sNewTableInfo,
                                        sNewPartInfo )
                      != IDE_SUCCESS );

            // partition별로 modify method를 수행한다.
            sPartCount = 0;

            for( sPartInfoList = sOldPartInfoList;
                 sPartInfoList != NULL;
                 sPartInfoList = sPartInfoList->next )
            {
                sPartInfo = sPartInfoList->partitionInfo;

                switch ( sPartMethod[sPartCount] )
                {
                    case QD_TBL_COL_MODIFY_METHOD_NONE:
                        //PROJ-2399 rowTemplate
                        IDE_TEST( smiTable::modifyRowTemplate( QC_SMI_STMT( aStatement ), 
                                                               sPartInfo->tableHandle )
                                  != IDE_SUCCESS );                        
                        break;

                    case QD_TBL_COL_MODIFY_METHOD_ALTER_META:
                        //PROJ-2399 rowTemplate
                        IDE_TEST( smiTable::modifyRowTemplate( QC_SMI_STMT( aStatement ), 
                                                               sPartInfo->tableHandle )
                                  != IDE_SUCCESS );                        

                        // column 관련 meta 변경은 위에서 수행하였고,
                        // index가 존재하면 index의 column 정보를
                        // 변경하도록 한다.

                        if ( sPartInfo->indexCount > 0 )
                        {
                            // PROJ-1911
                            // index가 있으면 index도 변경시켜줌
                            IDE_TEST(
                                modifyIndexColumnInfo(
                                    aStatement,
                                    sVerifyColumn,
                                    ID_TRUE, // partitioned table의 partition
                                    & sNewPartInfo[sPartCount] )
                                != IDE_SUCCESS );
                        }
                        else
                        {
                            // nothing to do
                        }

                        break;

                    case QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE:

                        // table 재생성으로 alter table modify column
                        // 기능수행
                        IDE_TEST( recreateTableForDisk( aStatement,
                                                        sParseTree,
                                                        & sNewTableInfo,
                                                        sPartInfo,
                                                        sNewPartInfo,
                                                        sPartCount )
                                  != IDE_SUCCESS );
                        break;

                    default:
                        IDE_DASSERT( 0 );
                }

                sPartCount++;
            }

            // PROJ-1624 non-partitioned index
            // partitioned table의 index는 항상 재생성한다.
            IDE_TEST( recreateIndexColumnInfo( aStatement,
                                               sParseTree->modifyColumns,
                                               & sNewTableInfo,
                                               sParseTree->oldIndexTables,
                                               & sParseTree->newIndexTables,
                                               & sDelIndexTables )
                      != IDE_SUCCESS );
        }
        else
        {
            // non-partitioned table

            //-----------------------------------------
            // modify method 결정 - 2단계
            //-----------------------------------------

            if ( sVerifyColumn != NULL )
            {
                // disk table의 column을 읽어 modify가 가능한지 검사하고
                // 최종 modify method 결정
                IDE_TEST( verifyColumnValue(
                              aStatement,
                              sParseTree->tableInfo,
                              sVerifyColumn,
                              & sMethod )
                          != IDE_SUCCESS );
            }
            else
            {
                // Nothing to do.
            }

            //-----------------------------------------
            // modify method 수행
            //-----------------------------------------

            // meta 변경만으로 alter table modify column 기능수행
            IDE_TEST( alterMetaForDisk( aStatement,
                                        sParseTree,
                                        & sNewTableInfo,
                                        NULL )
                      != IDE_SUCCESS );

            switch ( sMethod )
            {
                case QD_TBL_COL_MODIFY_METHOD_NONE:
                    // PROJ-2399 rowTemplate 
                    IDE_TEST( smiTable::modifyRowTemplate( QC_SMI_STMT( aStatement ), 
                                                           sParseTree->tableInfo->tableHandle )
                              != IDE_SUCCESS );                        
                    break;

                case QD_TBL_COL_MODIFY_METHOD_ALTER_META:
                    //PROJ-2399 rowTemplate
                    IDE_TEST( smiTable::modifyRowTemplate( QC_SMI_STMT( aStatement ), 
                                                           sParseTree->tableInfo->tableHandle )
                              != IDE_SUCCESS );                        

                    // column 관련 meta 변경은 위에서 수행하였고,
                    // index가 존재하면 index의 column 정보를
                    // 변경하도록 한다.

                    if ( sNewTableInfo->indexCount > 0 )
                    {
                        // PROJ-1911
                        // index가 있으면 index도 변경시켜줌
                        IDE_TEST(
                            modifyIndexColumnInfo(
                                aStatement,
                                sVerifyColumn,
                                ID_FALSE, // partitioned table이 아님
                                & sNewTableInfo )
                            != IDE_SUCCESS );
                    }
                    else
                    {
                        // nothing to do
                    }

                    break;

                case QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE:

                    // table 재생성으로 alter table modify column 기능수행
                    IDE_TEST( recreateTableForDisk( aStatement,
                                                    sParseTree,
                                                    & sNewTableInfo,
                                                    NULL,
                                                    NULL,
                                                    0 )
                              != IDE_SUCCESS );
                    break;

                default:
                    IDE_DASSERT( 0 );
            }
        }
    }

    //-----------------------------------------
    // 기타 변경 작업
    //-----------------------------------------

    if ( sNewTableInfo != NULL )
    {
        IDE_TEST( qcmView::setInvalidViewOfRelated(
                      aStatement,
                      sParseTree->userID,
                      sOldTableInfo->name,
                      idlOS::strlen((SChar*)sOldTableInfo->name),
                      QS_TABLE )
                  != IDE_SUCCESS );

        IDE_TEST( qcmView::recompileAndSetValidViewOfRelated(
                      aStatement,
                      sParseTree->userID,
                      sOldTableInfo->name,
                      idlOS::strlen((SChar*)sOldTableInfo->name),
                      QS_TABLE )
                  != IDE_SUCCESS );

        // BUG-16543
        IDE_TEST( qdnTrigger::setInvalidTriggerCache4Table( sOldTableInfo )
                  != IDE_SUCCESS );
    }
    else
    {
        // Nothing to do.
    }

    /* BUG-44230 ADD, DROP, MODIFY, REORGANIZE DDL의 INDEX, CONSTRAINT 생성 순서 변경 */
    IDU_FIT_POINT( "qdbAlter::executeModifyCol::BUG-44230" );

    // PROJ-2642 Table on Replication Allow DDL
    if ( ( sIsReplicatedTable == ID_TRUE ) ||
         ( sDDLSupplementalLog == 1 ) )
    {
        if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
        {
            sOldTableOIDArray = sOldPartitionOID;

            if ( sNewTableInfo != NULL )
            {
                IDE_TEST( qcmPartition::getPartitionInfoList( aStatement,
                                                              QC_SMI_STMT(aStatement),
                                                              QC_QMX_MEM(aStatement),
                                                              sNewTableInfo->tableID,
                                                              &sNewPartInfoList )
                          != IDE_SUCCESS );

                IDE_TEST( qcmPartition::getAllPartitionOID( QC_QMX_MEM(aStatement),
                                                            sNewPartInfoList,
                                                            &sNewTableOIDArray,
                                                            &sTableOIDCount )
                          != IDE_SUCCESS );
            }
            else
            {
                sNewTableOIDArray = sOldPartitionOID;
            }
        }
        else
        {
            if ( sNewTableInfo != NULL )
            {
                sNewTableOID = smiGetTableId( sNewTableInfo->tableHandle );
            }
            else
            {
                sNewTableOID = sOldTableOID;
            }

            sOldTableOIDArray = &sOldTableOID;
            sNewTableOIDArray = &sNewTableOID;
            sTableOIDCount = 1;
        }

        if ( sIsReplicatedTable == ID_TRUE )
        {
            for ( i = 0; i < sTableOIDCount; i++ )
            {
                if ( sOldTableOIDArray[i] != sNewTableOIDArray[i] )
                {
                    IDE_TEST( qci::mCatalogReplicationCallback.mUpdateReplItemsTableOID( QC_SMI_STMT( aStatement ),
                                                                                         sOldTableOIDArray[i],
                                                                                         sNewTableOIDArray[i] )
                              != IDE_SUCCESS);
                }
                else
                {
                    /* do nothing */
                }
            }
        }
        else
        {
            /* do nothing */
        }

        IDE_TEST( qciMisc::writeTableMetaLogForReplication( aStatement,
                                                            sOldTableOIDArray,
                                                            sNewTableOIDArray,
                                                            sTableOIDCount )
                  != IDE_SUCCESS );
    }
    else
    {
        /* do nothing */
    }

    // PROJ-2002 Column Security
    // 보안 컬럼 변경시 보안 모듈에 알린다.
    sColumn = sParseTree->modifyColumns;

    while ( sColumn != NULL )
    {
        if ( (sColumn->flag & QCM_COLUMN_MODIFY_ENCRYPT_COLUMN_MASK)
             == QCM_COLUMN_MODIFY_ENCRYPT_COLUMN_TRUE )
        {
            (void) qcsModule::setColumnPolicy(
                sOldTableInfo->tableOwnerName,
                sOldTableInfo->name,
                sColumn->name,
                sColumn->basicInfo->policy );
        }
        else if ( (sColumn->flag & QCM_COLUMN_MODIFY_DECRYPT_COLUMN_MASK)
                  == QCM_COLUMN_MODIFY_DECRYPT_COLUMN_TRUE )
        {
            (void) qcsModule::unsetColumnPolicy(
                sOldTableInfo->tableOwnerName,
                sOldTableInfo->name,
                sColumn->name );
        }
        else
        {
            // Nothing to do.
        }

        sColumn = sColumn->next;
    }

    //-----------------------------------------
    // old cached meta 삭제
    //-----------------------------------------

    if ( sNewTableInfo != NULL )
    {
        // PROJ-1502 PARTITIONED DISK TABLE
        if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
        {
            (void)qcmPartition::destroyQcmPartitionInfoList( sOldPartInfoList );
            
            for ( sIndexTable = sDelIndexTables;
                  sIndexTable != NULL;
                  sIndexTable = sIndexTable->next )
            {
                (void)qcm::destroyQcmTableInfo(sIndexTable->tableInfo);
            }
        }
        else
        {
            // Nothing to do.
        }

        (void) qcm::destroyQcmTableInfo( sOldTableInfo );
    }
    else
    {
        // Nothing to do.
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_MODIFY_COLUMN_IN_PRIMARY_KEY )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_DDL_NOT_SUPPORTED_REPLICATED_TABLE, 
                                  "Modify Column in primary Key" ) );
    }
    IDE_EXCEPTION( ERR_MODIFY_COLUMN_TO_ENCRYPT )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_DDL_NOT_SUPPORTED_REPLICATED_TABLE,
                                  "Modify Column to encrypt" ) );
    }
    IDE_EXCEPTION( ERR_SESSION_TEMPORARY_TABLE_EXIST )
    {
        IDE_SET(ideSetErrorCode( qpERR_ABORT_QDB_TEMPORARY_TABLE_DDL_DISABLE ));
    }
    IDE_EXCEPTION( ERR_CANNOT_WRITE_REPL_INFO )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_CANNOT_WRITE_REPL_INFO ) );
    }
    IDE_EXCEPTION_END;

    (void)qcm::destroyQcmTableInfo( sNewTableInfo );

    if ( sNewPartInfo != NULL )
    {
        sPartCount = 0;

        for( sPartInfoList = sOldPartInfoList;
             sPartInfoList != NULL;
             sPartInfoList = sPartInfoList->next )
        {
            (void)qcmPartition::destroyQcmPartitionInfo( sNewPartInfo[sPartCount] );

            sPartCount++;
        }
    }
    else
    {
        /* Nothing to do */
    }
        
    for ( sIndexTable = sParseTree->newIndexTables;
          sIndexTable != NULL;
          sIndexTable = sIndexTable->next )
    {
        (void)qcm::destroyQcmTableInfo( sIndexTable->tableInfo );
    }

    qcmPartition::restoreTempInfo( sOldTableInfo,
                                   sOldPartInfoList,
                                   NULL );

    return IDE_FAILURE;
}

// PROJ-2264 Dictionary table
IDE_RC qdbAlter::executeReorganizeCol( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description : PROJ-1877
 *    ALTER TABLE ... REORGANIZE COLUMN ...;
 *
 * Implementation :
 *    1. New dictionary table 생성
 *    2. New data table 재생성
 *      2-1. New data table 생성
 *      2-2. Old data table -> new data table 로 레코드 이동
 *      2-3. Old data table 삭제
 *    3. Meta table 갱신
 *    4. New dictionary table 재구성
 *    5. Old dictionary table 삭제
 *    6. Old data table의 meta cache 제거
 *
 ***********************************************************************/

    qdTableParseTree      * sParseTree;
    qcmTableInfo          * sTableInfo = NULL;
    qcmColumn             * sColumn;
    qcmDictionaryTable    * sNewDicTable;
    qcmDictionaryTable    * sNewDicIter;
    smOID                 * sOldDicOID;
    smOID                   sNewDataOID;
    qcmTableInfo          * sDicInfo;
    qcmTableInfo          * sNewDataInfo = NULL;
    UInt                    sDicID;
    UInt                    sColCnt = 0;
    UInt                    i;
    UInt                    sStage = 0;

    /* BUG-44230 ADD, DROP, MODIFY, REORGANIZE DDL의 INDEX, CONSTRAINT 생성 순서 변경 */
    SInt           sCountDiskType = 0;
    SInt           sCountMemType  = 0;
    SInt           sCountVolType  = 0;
    UInt           sTableType     = 0;

    sParseTree      = (qdTableParseTree *)aStatement->myPlan->parseTree;
    sNewDicTable    = NULL;

    // TASK-2176
    // Data Table에 대한 Lock을 획득한다.
    IDE_TEST( qcm::validateAndLockTable( aStatement,
                                         sParseTree->tableHandle,
                                         sParseTree->tableSCN,
                                         SMI_TABLE_LOCK_X )
              != IDE_SUCCESS );

    sTableInfo      = sParseTree->tableInfo;

    // Backup old dictionary table OID
    // New dictionary table 을 생성하면 smiColumn 에 담긴 mDictionaryTableOID 가 갱신된다.
    // 마지막에 old dictionary table 을 삭제하고 메타를 갱신하기 위해 미리 백업한다.
    for( sColumn = sParseTree->columns; sColumn != NULL; sColumn = sColumn->next )
    {
        sColCnt++;
    }

    IDE_TEST( aStatement->qmxMem->alloc( ID_SIZEOF(smOID) * sColCnt,
                                         (void**) &sOldDicOID )
              != IDE_SUCCESS );

    for( sColumn = sParseTree->columns, i = 0;
         sColumn != NULL;
         sColumn = sColumn->next, i++ )
    {
        sOldDicOID[i] = sColumn->basicInfo->column.mDictionaryTableOID;
    }

    //-----------------------------------------
    // 1. New dictionary table 생성
    //-----------------------------------------
    IDE_TEST( qcmDictionary::recreateDictionaryTable( aStatement,
                                                      sTableInfo,
                                                      sParseTree->columns,
                                                      sTableInfo->TBSID,
                                                      &sNewDicTable )
              != IDE_SUCCESS );

    sStage = 1;
 
    //-----------------------------------------
    // 2. New data table 생성 및
    //    레코드 이동 후 old data table 삭제
    //-----------------------------------------
    IDE_TEST( recreateTableForReorganize( aStatement,
                                          sParseTree,
                                          //sParseTree->columns, // reorganized columns
                                          &sNewDataOID,
                                          &sNewDataInfo )
              != IDE_SUCCESS );

    /* BUG-44230 ADD, DROP, MODIFY, REORGANIZE DDL의 INDEX, CONSTRAINT 생성 순서 변경 */
    sTableType = sTableInfo->tableFlag & SMI_TABLE_TYPE_MASK;

    /* - Partition 구성을 검사한다. */
    qdbCommon::getTableTypeCountInPartInfoList( & sTableType,
                                                NULL,
                                                & sCountDiskType,
                                                & sCountMemType,
                                                & sCountVolType );

    /* - Memory 매체가 있거나, Index Table이 있다면, Index를 먼저 생성한다. */
    if ( ( ( sCountMemType + sCountVolType ) > 0 ) ||
         ( sParseTree->oldIndexTables != NULL ) )
    {
        IDE_TEST( recreateIndexForReorganize ( aStatement,
                                               sParseTree,
                                               sNewDataOID,
                                               & sNewDataInfo )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    /* - 레코드를 moveRow 한다.
     *    recreateTableForReorganize에 포함된 moveRow를 상위로 옮긴다.
     */
    /* BUG-20992: TC/Server/sm4/PRJ-1548/dynmem/../suites/conc_disk/dt_dt.sql에서 서버사망
     *
     * 원인: Disk Table에 대해서 Alter Table Add, Drop시 Table을 생성하고 Record를
     * Insert하다가 비정상 종료시 Alter시 만들어지 Table은 Memory Refine시 Free되지만 Insert
     * 된 Record에 대해서는 Disk Ager가 Startup 후에 계속 삭제한다. 이 때 Disk Ager는
     * 이 Table이 Drop이 되었기 때문에 Skip을 하는데 문제는 이 Free된 Table이 할당될 경우
     * Disk Ager는 Free Record연산을 합니다. 결국 이미 삭제된 Table에 대해서 Free연산을 하게
     * 됩니다.
     *
     * 해결: 이런 문제를 피하기 위해서는 어짜피 Alter가 실패하면 생성된 Table이 Drop될 것이
     * 기 때문에 Undo Log를 기록하지 않음으로써 Ager가 Record를 Free하는 일이 없도록 합니다.
     * moverow시에 undo log가 기록되지 않도록 합니다. 그런데 문제는 이렇게 하다보니 Index에
     * Key가 Insert되지 않는 문제가 있습니다. 왜냐면 Index에 Key Insert는 insert 를 수행시
     * table에 레코드를 Insert후 Insert시 사용한 Cursor를 Close시에 Insert Undo Record를
     * 읽어서 Table에 Record를 Insert합니다. 그런데 Insert Undo Record가 기록되지 않았기 때문
     * 에 Insert가 되지 않아서 Alter시에 moverows를 먼저 수행 후 Index에 Key를 Insert하는
     * 것으로 Logic을 변경하였습니다.
     *
     * 주의: Alter Table Add Column과 같이 새로운 Table을 생성하고 Insert시에 새로운 Table에
     * Record를 삽입후에 Index를 생성해야 합니다.
     * */
    /* move row from old to new. drop old non-partitioned table */
    IDE_TEST( moveRow( aStatement,
                       NULL,
                       sTableInfo,
                       sTableInfo->tableHandle,
                       smiGetTable( sNewDataOID ),
                       sTableInfo->columns,
                       sNewDataInfo->columns, /* sOldTableInfo->columns, aNewTableColumn, */
                       NULL,
                       NULL,
                       ID_FALSE /* No Undo Logging */ )
              != IDE_SUCCESS );

    //-----------------------------------------
    // 3. New dictionary table 재구성
    //-----------------------------------------
    // Data table 을 모두 읽어 내려가면서 new dictionary table 들을 재구성한다.
    IDE_TEST( qcmDictionary::rebuildDictionaryTable( aStatement,
                                                     sTableInfo,
                                                     sNewDataInfo,
                                                     sNewDicTable )
              != IDE_SUCCESS );

    /* BUG-44230 ADD, DROP, MODIFY, REORGANIZE DDL의 INDEX, CONSTRAINT 생성 순서 변경
     *  - Memory 매체가 없고, Index Table도 없다면, Index를 나중 생성한다.
     */
    if ( ( ( sCountMemType + sCountVolType ) == 0 ) &&
         ( sParseTree->oldIndexTables == NULL ) )
    {
        IDE_TEST( recreateIndexForReorganize ( aStatement,
                                               sParseTree,
                                               sNewDataOID,
                                               & sNewDataInfo )
                  != IDE_SUCCESS );

        IDU_FIT_POINT( "qdbAlter::executeReorganizeCol::BUG-44230-1" );
    }
    else
    {
        /* Nothing to do */
    }

    //-----------------------------------------
    // 4. SYS_COMPRESSION_TABLES_ 갱신
    //-----------------------------------------
    for( sNewDicIter = sNewDicTable, i = 0;
         sNewDicIter != NULL;
         sNewDicIter = sNewDicIter->next, i++ )
    {
        sDicInfo = (qcmTableInfo *)smiGetTableRuntimeInfoFromTableOID( sOldDicOID[i] );
        sDicID = sDicInfo->tableID;

        IDE_TEST( qcmDictionary::updateCompressionTableSpecMeta( aStatement,
                                                                 sDicID,
                                                                 sNewDicIter->dictionaryTableInfo->tableID )
                  != IDE_SUCCESS );
    }

    /* BUG-44230 ADD, DROP, MODIFY, REORGANIZE DDL의 INDEX, CONSTRAINT 생성 순서 변경 */
    IDU_FIT_POINT( "qdbAlter::executeReorganizeCol::BUG-44230-2" );

    //-----------------------------------------
    // 5. Old dictionary table 삭제
    //-----------------------------------------
    sStage = 0;

    for( sNewDicIter = sNewDicTable, i = 0;
         sNewDicIter != NULL;
         sNewDicIter = sNewDicIter->next, i++ )
    {
        sDicInfo = (qcmTableInfo *)smiGetTableRuntimeInfoFromTableOID( sOldDicOID[i] );

        // Drop old dictionary table
        // BUG-36719
        // 여기서 실패하면 되돌릴 수 없다.
        // 실패하더라도 old dictionary table 이 남을 뿐이고,
        // Reorganize 작업 자체는 성공했기 때문에 old dictionary table 삭제는
        // 별도 에러 처리를 하지 않는다.
        (void) qcmDictionary::removeDictionaryTableWithInfo( aStatement,
                                                             sDicInfo );

        // Table info 를 삭제한다.
        (void)qcm::destroyQcmTableInfo(sDicInfo);
    }

    //-----------------------------------------
    // 6. Old data table의 meta cache 제거
    //-----------------------------------------
    (void)qcm::destroyQcmTableInfo( sTableInfo );

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    if( sStage == 1 )
    {
        for( sNewDicIter = sNewDicTable;
             sNewDicIter != NULL;
             sNewDicIter = sNewDicIter->next )
        {
            // BUG-36719
            // Dictionary table 과 메타테이블은 롤백되어 사라질 것이다.
            // 여기서는 table info 만 해제한다.
            (void)qcm::destroyQcmTableInfo( sNewDicIter->dictionaryTableInfo );
        }
    }

    (void)qcm::destroyQcmTableInfo( sNewDataInfo );

    return IDE_FAILURE;
}

IDE_RC qdbAlter::executeAccessPartition( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *    PROJ-2359 Table/Partition Access Option
 *
 *    ALTER TABLE table ACCESS PARTITION partition READ { ONLY | WRITE | APPEND };
 *
 * Implementation :
 *
 ***********************************************************************/

    qdTableParseTree        * sParseTree;
    qcmTableInfo            * sTableInfo     = NULL;
    qcmTableInfo            * sPartInfo      = NULL;
    qdPartitionAttribute    * sPartAttr;

    qcmTableInfo            * sNewPartInfo   = NULL;
    void                    * sNewPartHandle = NULL;
    smSCN                     sNewSCN        = SM_SCN_INIT;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // 파티션드 테이블에 LOCK(IX)
    // 파티션에 LOCK(X)
    IDE_TEST( qcmPartition::validateAndLockTableAndPartitions(
                    aStatement,
                    sParseTree->tableHandle,
                    sParseTree->tableSCN,
                    sParseTree->partTable->partInfoList,
                    SMI_TABLE_LOCK_IX,
                    ID_FALSE ) //aIsSetViewSCN
              != IDE_SUCCESS );

    sTableInfo = sParseTree->tableInfo;

    sPartInfo = sParseTree->partTable->partInfoList->partitionInfo;
    sPartAttr = sParseTree->partTable->partAttr;

    // 파티션 ACCESS 업데이트
    IDE_TEST( updatePartAccessOfTablePartMeta(
                    aStatement,
                    sPartInfo->partitionID,
                    sPartAttr->accessOption )
              != IDE_SUCCESS );

    // To fix BUG-17547
    IDE_TEST( qcmPartition::touchPartition(
                    QC_SMI_STMT( aStatement ),
                    sPartInfo->partitionID )
              != IDE_SUCCESS );

    // fix BUG-14394
    IDE_TEST( qdbCommon::updateTableSpecFromMeta(
                  aStatement,
                  sParseTree->userName,
                  sParseTree->tableName,
                  sTableInfo->tableID,
                  smiGetTableId( sTableInfo->tableHandle ),
                  sTableInfo->columnCount,
                  sTableInfo->parallelDegree)
              != IDE_SUCCESS );

    IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                  QC_SMI_STMT( aStatement ),
                  sPartInfo->partitionID,
                  smiGetTableId( sPartInfo->tableHandle ),
                  sTableInfo,
                  NULL )
              != IDE_SUCCESS );

    IDE_TEST( qcmPartition::getPartitionInfo( aStatement,
                                              sTableInfo->tableID,
                                              (UChar *)sPartInfo->name,
                                              (SInt)idlOS::strlen( sPartInfo->name ),
                                              & sNewPartInfo,
                                              & sNewSCN,
                                              & sNewPartHandle )
              != IDE_SUCCESS );

    // 메타 캐시 삭제
    (void)qcmPartition::destroyQcmPartitionInfo( sPartInfo );

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    (void)qcmPartition::destroyQcmPartitionInfo( sNewPartInfo );

    qcmPartition::restoreTempInfoForPartition( sTableInfo,
                                               sPartInfo );

    return IDE_FAILURE;
}

IDE_RC qdbAlter::decideModifyMethodForMemory(
    qcStatement           * aStatement,
    qcmColumn             * aTableColumns,
    qcmColumn             * aModifyColumns,
    qdTblColModifyMethod  * aMethod,
    qdVerifyColumn       ** aVerifyColumn )
{
 /***********************************************************************
 *
 * Description : PROJ-1877
 *    memory table에 대한 modify column시 modify method 결정
 *
 * Implementation :
 *
 *    Table의 각 column에 대하여 다음을 수행한다
 *    (1) default value 변경인 경우, modify method 결정
 *    (2) (not) null 변경인 경우, modify method 결정
 *    (3) column option을 변경한 경우, modify method 결정
 *    (4) type과 length 변경한 경우, modify method 결정
 *        - padding type -> non-padding type 변환과 length 변경
 *        - non-padding type -> padding type 변환과 length 변경
 *        - float->numeric type 변환과 length 변경
 *        - numeric->flat type 변환과 length 변경
 *    (5) length 변경으로 취급할 수 없는 경우, modify method 결정
 *        ex) char -> integer
 *    (6) type 변경없이 length만 변경한 경우, modify method 결정
 *        - non-padding type의 length 변경
 *        - padding type type의 length 변경
 *        - numeric의 length 변경
 *        - flaot의 length 변경
 *        - geometry 의 length 변경
 *
 *    위 모든 경우, modify schema만으로 modify method 결정된다.
 *
 ***********************************************************************/

    qdTblColModifyMethod    sMethod = QD_TBL_COL_MODIFY_METHOD_NONE;
    qcmColumn             * sTableColumn;
    qcmColumn             * sModifyColumn;
    mtcColumn             * sTableColumnInfo;
    mtcColumn             * sModifyColumnInfo;
    qdVerifyColumn        * sVerifyColumn = NULL;
    idBool                  sIsDataLoss   = ID_FALSE;

    sTableColumn  = aTableColumns;
    sModifyColumn = aModifyColumns;

    while ( sTableColumn != NULL )
    {
        IDE_DASSERT( sModifyColumn != NULL );

        sTableColumnInfo = sTableColumn->basicInfo;
        sModifyColumnInfo = sModifyColumn->basicInfo;

        //-----------------------------------------
        // (1) default value 변경인 경우, modify method 결정
        //-----------------------------------------

        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_DEFAULT_MASK)
             == QCM_COLUMN_MODIFY_DEFAULT_TRUE )
        {
            IDE_TEST( qdbCommon::convertDefaultValueType(
                          aStatement,
                          & sModifyColumnInfo->type,
                          sModifyColumn->defaultValue,
                          NULL )
                      != IDE_SUCCESS );

            // rebuild meta
            sMethod = sMethod > QD_TBL_COL_MODIFY_METHOD_ALTER_META ?
                sMethod : QD_TBL_COL_MODIFY_METHOD_ALTER_META;
        }
        else
        {
            // Nothing to do.
        }

        //-----------------------------------------
        // (2) (not) null 변경인 경우, modify method 결정
        //-----------------------------------------

        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_NULLABLE_MASK)
             == QCM_COLUMN_MODIFY_NULLABLE_NULL )
        {
            // rebuild meta
            sMethod = sMethod > QD_TBL_COL_MODIFY_METHOD_ALTER_META ?
                sMethod : QD_TBL_COL_MODIFY_METHOD_ALTER_META;
        }
        else if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_NULLABLE_MASK)
                  == QCM_COLUMN_MODIFY_NULLABLE_NOTNULL )
        {
            // sTableColumn에 null value가 없는지 검사해야함
            // null이 있으면 에러, 없으면 계속

            // verifyColumn 등록
            IDE_TEST( addVerifyColumn( aStatement,
                                       sTableColumn,
                                       QD_VERIFY_NOT_NULL,
                                       0,
                                       0,
                                       0,
                                       QD_CHANGE_STORED_TYPE_NONE,
                                       & sVerifyColumn )
                      != IDE_SUCCESS );

            // rebuild meta
            sMethod = sMethod > QD_TBL_COL_MODIFY_METHOD_ALTER_META ?
                sMethod : QD_TBL_COL_MODIFY_METHOD_ALTER_META;
        }
        else
        {
            // Nothing to do.
        }

        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_COLUMN_OPTION_MASK)
             == QCM_COLUMN_MODIFY_COLUMN_OPTION_TRUE )
        {
            //-----------------------------------------
            // (3) column option을 변경한 경우, modify method 결정
            //-----------------------------------------

            // recreate
            sMethod = sMethod > QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE ?
                sMethod : QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE;
        }
        else
        {
            // Nothing to do
        }

        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_TYPE_MASK)
             == QCM_COLUMN_MODIFY_TYPE_TRUE )
        {
            if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_LENGTH_MASK)
                 == QCM_COLUMN_MODIFY_LENGTH_TRUE )
            {
                //-----------------------------------------
                // (4) type과 length 변경한 경우, modify method 결정
                //
                // 아래와 같이 8가지 case가 있음
                // nchar->nvarchar
                // nvarchar->nchar
                // char->varchar
                // varchar->char
                // bit->varbit
                // varbit->bit
                // float->numeric
                // numeric->float
                //-----------------------------------------

                if ( (sTableColumnInfo->module->id == MTD_NCHAR_ID) ||
                     (sTableColumnInfo->module->id == MTD_CHAR_ID) ||
                     (sTableColumnInfo->module->id == MTD_BIT_ID) )
                {
                    //--------------------
                    // padding type -> non-padding type 변환과 length 변경
                    // 아래 3가지 case가 있음
                    // nchar->nvarchar
                    // char->varchar
                    // bit->varbit
                    //--------------------

                    if ( sTableColumnInfo->precision <=
                         sModifyColumnInfo->precision )
                    {
                        // length 변경 없거나 확대
                        // recreate table
                        // 예)
                        // char(3)->varchar(3)
                        // bit(3)->varbit(5)
                    }
                    else
                    {
                        // length 축소
                        // sTableColumn value가 모두 null이 아니면 에러
                        // 예)
                        // char(3)->varchar(1)

                        // sTableColumn의 모든 value가 null인 경우,
                        //   recreate table
                        // 그외 경우,
                        //   error

                        // BUG-28317
                        // value가 모두 NULL인지 여부를 scan하지 않고도
                        // 알수 있다면 성능향상할 수 있음

                        // verifyColumn 등록
                        IDE_TEST( addVerifyColumn(
                                      aStatement,
                                      sTableColumn,
                                      QD_VERIFY_NULL,
                                      0,
                                      0,
                                      0,
                                      QD_CHANGE_STORED_TYPE_NONE,
                                      & sVerifyColumn )
                                  != IDE_SUCCESS );
                    }
                }
                else if ( (sTableColumnInfo->module->id ==
                           MTD_NVARCHAR_ID) ||
                          (sTableColumnInfo->module->id ==
                           MTD_VARCHAR_ID) ||
                          (sTableColumnInfo->module->id ==
                           MTD_VARBIT_ID) )
                {
                    //--------------------
                    // non-padding type -> padding type 변환과 length 변경
                    // 아래 3가지 case가 있음
                    // nvarchar->nchar
                    // varchar->char
                    // varbit->bit
                    //--------------------

                    if ( sTableColumnInfo->precision ==
                         sModifyColumnInfo->precision )
                    {
                        // length 변경 없음
                        // recreate table
                        // 예)
                        // nvarchar(4)->nchar(4)
                    }
                    else if ( sTableColumnInfo->precision <
                              sModifyColumnInfo->precision )
                    {
                        // length 확대
                        // recreate table
                        // 예)
                        // varbit(4)->bit(6)
                    }
                    else
                    {
                        // length 축소
                        // 예)
                        // varchar(4)->char(3)
                        // sTableColumn value 중 그 length가
                        // sModifyColumn의 length보다 큰 것이 존재하면
                        // DDL을 수행할 수 없다.

                        // sTableColumn의 모든 value가 null 이거나
                        // sTableColumn의 모든 value의 length가
                        // sModifyColumn의 length와 같은 경우,
                        //    recreate table
                        // sTableColumn의 모든 value의 length가
                        // 변경하려는 length 이하인 경우,
                        //    recreate table
                        // 그외 경우,
                        //    error

                        // verifyColumn 등록
                        IDE_TEST(
                            addVerifyColumn(
                                aStatement,
                                sTableColumn,
                                QD_VERIFY_NULL_OR_EXACT_OR_UNDER_SIZE,
                                sModifyColumnInfo->column.size,
                                sModifyColumnInfo->precision,
                                ID_SINT_MAX,  // scale은 상관없음
                                QD_CHANGE_STORED_TYPE_NONE,
                                & sVerifyColumn )
                            != IDE_SUCCESS );
                    }
                }
                else if ( sTableColumnInfo->module->id == MTD_FLOAT_ID )
                {
                    //--------------------
                    // float->numeric의 type과 length 변경
                    //
                    // 예)
                    // float(8)->numeric(10,2)
                    // float(8)->numeric(5)
                    //--------------------

                    // float->numeric의 경우 schema로는 length 확대인지
                    // 축소인지 판단할 수 없다.
                    // data loss 옵션 없이 numeric length 축소는 불가능
                    // 하다.
                    if ( (sModifyColumn->flag &
                          QCM_COLUMN_MODIFY_DATA_LOSS_MASK)
                         == QCM_COLUMN_MODIFY_DATA_LOSS_FALSE )
                    {
                        // data loss 옵션을 명시하지 않은 경우,
                        // sTableColumn value가 sModifyColumn의
                        // length보다 크다면 DDL을 수행할 수 없다.

                        // sTableColumn의 모든 value의 length가
                        // sModifyColumn의 length 보다 작거나 같은 경우,
                        //    recreate table
                        // 그외 경우,
                        //    error

                        // verifyColumn 등록
                        IDE_TEST(
                            addVerifyColumn(
                                aStatement,
                                sTableColumn,
                                QD_VERIFY_NULL_OR_UNDER_SIZE,
                                sModifyColumnInfo->column.size,
                                sModifyColumnInfo->precision,
                                sModifyColumnInfo->scale,
                                QD_CHANGE_STORED_TYPE_NONE,
                                & sVerifyColumn )
                            != IDE_SUCCESS );
                    }
                    else
                    {
                        // Nothing to do.
                    }
                }
                else if ( sTableColumnInfo->module->id == MTD_NUMERIC_ID )
                {
                    //--------------------
                    // numeric->flat의 type과 length 변경
                    //--------------------

                    if ( sTableColumnInfo->precision <=
                         sModifyColumnInfo->precision )
                    {
                        // 예)
                        // numeric(10,2)->float(10)
                    }
                    else
                    {
                        // 예)
                        // numeric(5)->float(3)

                        // data loss 옵션 없이 numeric length 축소는
                        // 불가능하다.
                        if ( (sModifyColumn->flag &
                              QCM_COLUMN_MODIFY_DATA_LOSS_MASK)
                             == QCM_COLUMN_MODIFY_DATA_LOSS_FALSE )
                        {
                            // data loss 옵션을 명시하지 않은 경우,
                            // sTableColumn value가 sModifyColumn의
                            // length보다 크다면 DDL을 수행할 수 없다.

                            // sTableColumn의 모든 value가 NULL이거나
                            // sModifyColumn의 length 보다 작거나 같으면
                            //    recreate table
                            // 그외 경우,
                            //    error

                            // verifyColumn 등록
                            IDE_TEST(
                                addVerifyColumn(
                                    aStatement,
                                    sTableColumn,
                                    QD_VERIFY_NULL_OR_UNDER_SIZE,
                                    sModifyColumnInfo->column.size,
                                    sModifyColumnInfo->precision,
                                    ID_SINT_MAX,  // scale은 상관없음
                                    QD_CHANGE_STORED_TYPE_NONE,
                                    & sVerifyColumn )
                                != IDE_SUCCESS );
                        }
                        else
                        {
                            // Nothing to do.
                        }
                    }
                }
                else
                {
                    IDE_DASSERT( 0 );
                }
            }
            else
            {
                //-----------------------------------------
                // (5) length 변경으로 취급할 수 없는 나머지 경우,
                //     modify method 결정
                //
                // 아래와 같이 2가지 case가 있음
                // char->integer
                // varchar->date
                // 예)
                // char(4)->integer
                // varchar(8)->date
                //-----------------------------------------

                IDE_TEST( isDataLossConversion(
                              sTableColumnInfo->module->id,
                              sModifyColumnInfo->module->id,
                              & sIsDataLoss )
                          != IDE_SUCCESS );

                if ( ( sIsDataLoss == ID_TRUE ) &&
                     ( (sModifyColumn->flag &
                        QCM_COLUMN_MODIFY_DATA_LOSS_MASK)
                       == QCM_COLUMN_MODIFY_DATA_LOSS_FALSE ) )
                {
                    // data loss 옵션을 명시하지 않은 경우

                    // sTableColumn의 모든 value가 모두 null인 경우,
                    //    recreate table
                    // 그외 경우,
                    //    error

                    // BUG-28317
                    // value가 모두 NULL인지 여부를 scan하지 않고도
                    // 알수 있다면 성능향상할 수 있음

                    // verifyColumn 등록
                    IDE_TEST( addVerifyColumn( aStatement,
                                               sTableColumn,
                                               QD_VERIFY_NULL,
                                               0,
                                               0,
                                               0,
                                               QD_CHANGE_STORED_TYPE_NONE,
                                               & sVerifyColumn )
                              != IDE_SUCCESS );
                }
                else
                {
                    // Nothing to do.
                }
            }

            // type변경은 모두 recreate table
            sMethod = sMethod > QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE ?
                sMethod : QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE;
        }
        else
        {
            if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_LENGTH_MASK)
                 == QCM_COLUMN_MODIFY_LENGTH_TRUE )
            {
                //-----------------------------------------
                // (6) type 변경없이 length만 변경한 경우,
                //     modify method 결정
                //
                // 아래와 같이 10가지 case가 있음
                // nchar
                // nvarchar
                // char
                // varchar
                // bit
                // varbit
                // float
                // numeric
                // byte
                // nibble
                //-----------------------------------------

                if ( (sTableColumnInfo->module->id == MTD_NCHAR_ID) ||
                     (sTableColumnInfo->module->id == MTD_CHAR_ID)  ||
                     (sTableColumnInfo->module->id == MTD_BIT_ID)   ||
                     (sTableColumnInfo->module->id == MTD_BYTE_ID) )
                {
                    //--------------------
                    // padding type의 length 변경
                    // 아래 4가지 case가 있음
                    // nchar, char, bit, byte
                    //--------------------

                    if ( sTableColumnInfo->precision ==
                         sModifyColumnInfo->precision )
                    {
                        // length 변경 없음
                        // 예)
                        // char(3)->char(3)

                        // none
                        // sMethod = QD_MODIFY_METHOD_NONE;
                    }
                    else if ( sTableColumnInfo->precision <
                              sModifyColumnInfo->precision )
                    {
                        // length 확대
                        // 예)
                        // char(3)->char(5) length 확대

                        // recreate
                        sMethod =
                            sMethod > QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE ?
                            sMethod : QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE;
                    }
                    else
                    {
                        // length 축소
                        // sTableColumn value가 모두 null이 아니면 에러
                        // 예)
                        // char(3)->char(1) length 축소

                        // sTableColumn의 모든 value가 모두 null인 경우,
                        //    recreate table
                        // 그외 경우,
                        //    error

                        // BUG-28317
                        // value가 모두 NULL인지 여부를 scan하지 않고도
                        // 알수 있다면 성능향상할 수 있음

                        // verifyColumn 등록
                        IDE_TEST(
                            addVerifyColumn( aStatement,
                                             sTableColumn,
                                             QD_VERIFY_NULL,
                                             0,
                                             0,
                                             0,
                                             QD_CHANGE_STORED_TYPE_NONE,
                                             & sVerifyColumn )
                            != IDE_SUCCESS );

                        // recreate table
                        sMethod = sMethod > QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE ?
                            sMethod : QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE;
                    }
                }
                else if ( (sTableColumnInfo->module->id == MTD_NVARCHAR_ID) ||
                          (sTableColumnInfo->module->id == MTD_VARCHAR_ID) ||
                          (sTableColumnInfo->module->id == MTD_VARBYTE_ID) ||
                          (sTableColumnInfo->module->id == MTD_VARBIT_ID) ||
                          (sTableColumnInfo->module->id == MTD_NIBBLE_ID) )
                {
                    //--------------------
                    // non-padding type의 length 변경
                    // 아래 4가지 case가 있음
                    // nvarchar, varchar, varbit, nibble
                    //--------------------

                    if ( sTableColumnInfo->precision ==
                         sModifyColumnInfo->precision )
                    {
                        // length 변경 없음
                        // 예)
                        // varchar(5)->varchar(5)

                        // none
                        // sMethod = QD_MODIFY_METHOD_NONE;
                    }
                    else if ( sTableColumnInfo->precision <
                              sModifyColumnInfo->precision )
                    {
                        // length 확대
                        // 예)
                        // varchar(5)->varchar(10) length 확대

                        // recreate table
                        sMethod = sMethod > QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE ?
                            sMethod : QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE;
                    }
                    else
                    {
                        // length 축소
                        // sTableColumn value가 sModifyColumn의
                        // length보다 크다면 DDL을 수행할 수 없다.
                        // 예)
                        // varchar(5)->varchar(3) length 축소

                        // sTableColumn의 모든 value가 null 이거나
                        // sTableColumn의 모든 value의 length가
                        // sModifyColumn의 length 와 같거나 작은 경우,
                        //    recreate table
                        // 그외 경우
                        //    error

                        // verifyColumn 등록
                        IDE_TEST(
                            addVerifyColumn(
                                aStatement,
                                sTableColumn,
                                QD_VERIFY_NULL_OR_UNDER_SIZE,
                                sModifyColumnInfo->column.size,
                                sModifyColumnInfo->precision,
                                ID_SINT_MAX,  // scale은 상관없음
                                QD_CHANGE_STORED_TYPE_NONE,
                                & sVerifyColumn )
                            != IDE_SUCCESS );

                        // recreate table
                        sMethod = sMethod > QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE ?
                            sMethod : QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE;
                    }
                }
                else if ( sTableColumnInfo->module->id == MTD_FLOAT_ID )
                {
                    //--------------------
                    // float 의 length 변경
                    //--------------------

                    if ( sTableColumnInfo->precision ==
                         sModifyColumnInfo->precision )
                    {
                        // length 변경 없음
                        // 예)
                        // float(5)->float(5)

                        // none
                        // sMethod = QD_MODIFY_METHOD_NONE;
                    }
                    else if ( sTableColumnInfo->precision <
                              sModifyColumnInfo->precision )
                    {
                        // length 확대
                        // 예)
                        // float(5)->float(10) length 확대

                        // recreate table
                        sMethod = sMethod > QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE ?
                            sMethod : QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE;
                    }
                    else
                    {
                        // length 축소
                        // 예)
                        // float(5)->float(3) length 축소

                        if ( (sModifyColumn->flag &
                              QCM_COLUMN_MODIFY_DATA_LOSS_MASK)
                             == QCM_COLUMN_MODIFY_DATA_LOSS_FALSE )
                        {
                            // data loss 옵션을 명시하지 않은 경우,
                            // sTableColumn value가 sModifyColumn의
                            // length보다 크다면 DDL을 수행할 수 없다.

                            // sTableColumn의 모든 value가 null 이거나
                            // sTableColumn의 모든 value의 length가
                            // sModifyColumn의 length보다 작거나 같으면
                            //    recreate table
                            // 그외 경우,
                            //    error

                            // verifyColumn 등록
                            IDE_TEST(
                                addVerifyColumn(
                                    aStatement,
                                    sTableColumn,
                                    QD_VERIFY_NULL_OR_UNDER_SIZE,
                                    sModifyColumnInfo->column.size,
                                    sModifyColumnInfo->precision,
                                    ID_SINT_MAX,  // scale은 상관없음
                                    QD_CHANGE_STORED_TYPE_NONE,
                                    & sVerifyColumn )
                                != IDE_SUCCESS );
                        }
                        else
                        {
                            // Nothing to do
                        }

                        // recreate table
                        sMethod = sMethod > QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE ?
                            sMethod : QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE;
                    }
                }
                else if ( sTableColumnInfo->module->id == MTD_NUMERIC_ID )
                {
                    //--------------------
                    // numeric 의 length 변경
                    //--------------------

                    if ( ( sTableColumnInfo->precision ==
                           sModifyColumnInfo->precision ) &&
                         ( sTableColumnInfo->scale ==
                           sModifyColumnInfo->scale ) )
                    {
                        // length 변경 없음
                        // 예)
                        // numeric(10,2)->numeric(10,2)
                        // numeric(10,0)->numeric(10)

                        // none
                        // sMethod = QD_MODIFY_METHOD_NONE;
                    }
                    else if ( isEnlargingLengthForNumericType(
                                  sTableColumnInfo->precision,
                                  sTableColumnInfo->scale,
                                  sModifyColumnInfo->precision,
                                  sModifyColumnInfo->scale )
                              == ID_TRUE )
                    {
                        // length 확대
                        // 예)
                        // numeric(10,2)->numeric(12,4) length 확대

                        // recreate table
                        sMethod = sMethod > QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE ?
                            sMethod : QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE;
                    }
                    else
                    {
                        // length 축소
                        // 예)
                        // numeric(10,2)->numeric(12,8) length 축소

                        if ( (sModifyColumn->flag &
                              QCM_COLUMN_MODIFY_DATA_LOSS_MASK)
                             == QCM_COLUMN_MODIFY_DATA_LOSS_FALSE )
                        {
                            // data loss 옵션을 명시하지 않은 경우,
                            // sTableColumn value가 sModifyColumn의
                            // length보다 크다면 DDL을 수행할 수 없다.

                            // sTableColumn의 모든 value가 null 이거나
                            // sTableColumn의 모든 value의 length가
                            // sModifyColumn의 length 와 같거나 작으면,
                            //    recreate table
                            // 그 외 경우
                            //    error

                            // verifyColumn 등록
                            IDE_TEST(
                                addVerifyColumn(
                                    aStatement,
                                    sTableColumn,
                                    QD_VERIFY_NULL_OR_UNDER_SIZE,
                                    sModifyColumnInfo->column.size,
                                    sModifyColumnInfo->precision,
                                    sModifyColumnInfo->scale,
                                    QD_CHANGE_STORED_TYPE_NONE,
                                    & sVerifyColumn )
                                != IDE_SUCCESS );
                        }
                        else
                        {
                            // Nothing to do
                        }

                        // recreate table
                        sMethod = sMethod > QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE ?
                            sMethod : QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE;
                    }
                }
                else if ( sTableColumnInfo->module->id == MTD_GEOMETRY_ID )
                {
                    //--------------------
                    // geometric 의 length 변경
                    //--------------------

                    if ( sTableColumnInfo->precision ==
                         sModifyColumnInfo->precision )
                    {
                        // length 변경 없음
                        // 예)
                        // geometry(3)->geometry(3)

                        // none
                        // sMethod = QD_MODIFY_METHOD_NONE;
                    }
                    else if ( sTableColumnInfo->precision <
                              sModifyColumnInfo->precision )
                    {
                        // length 확대
                        // 예)
                        // geometry(3)->geometry(5)

                        // recreate table
                        sMethod =
                            sMethod > QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE ?
                            sMethod : QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE;
                    }
                    else
                    {
                        // length 축소
                        // 예)
                        // geometry(3)->geometry(1)

                        // sTableColumn의 모든 value가 null 이거나
                        // sTableColumn의 모든 value의 length가
                        // sModifyColumn의 length와 같거나 작은 경우,
                        //    recreate table
                        // 그 외 경우,
                        //    error

                        // verifyColumn 등록
                        IDE_TEST(
                            addVerifyColumn(
                                aStatement,
                                sTableColumn,
                                QD_VERIFY_NULL_OR_UNDER_SIZE,
                                sModifyColumnInfo->column.size,
                                sModifyColumnInfo->precision,
                                ID_SINT_MAX,  // scale은 상관없음
                                QD_CHANGE_STORED_TYPE_NONE,
                                & sVerifyColumn )
                            != IDE_SUCCESS );

                        // recreate table
                        sMethod =
                            sMethod > QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE ?
                            sMethod : QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE;
                    }
                }
                else
                {
                    IDE_DASSERT( 0 );
                }
            }
            else
            {
                // type, length를 명시하지 않은 경우
                // Nothing to do.
            }
        }

        sTableColumn = sTableColumn->next;
        sModifyColumn = sModifyColumn->next;
    }

    *aMethod = sMethod;
    *aVerifyColumn = sVerifyColumn;

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::decideModifyMethodForDisk(
    qcStatement           * aStatement,
    qcmColumn             * aTableColumns,
    qcmColumn             * aModifyColumns,
    qdTblColModifyMethod  * aMethod,
    qdVerifyColumn       ** aVerifyColumn )
{
 /***********************************************************************
 *
 * Description : PROJ-1877
 *    disk table에 대한 modify column시 modify method 결정
 *
 * Implementation :
*
 *    Table의 각 column에 대하여 다음을 수행한다
 *    (1) default value 변경인 경우, modify method 결정
 *    (2) (not) null 변경인 경우, modify method 결정
 *    (3) column option을 변경한 경우, modify method 결정
 *    (4) type과 length 변경한 경우, modify method 결정
 *        - padding type -> non-padding type 변환과 length 변경
 *        - non-padding type -> padding type 변환과 length 변경
 *        - float->numeric의 type과 length 변경
 *        - numeric->flat의 type과 length 변경
 *    (5) length 변경으로 취급할 수 없는 경우, modify method 결정
 *        ex) char -> integer
 *    (6) type 변경없이 length만 변경한 경우, modify method 결정
 *        - non-padding type의 length 변경
 *        - padding type type의 length 변경
 *        - numeric의 length 변경
 *        - flaot의 length 변경
 *        - geometry 의 length 변경
 *
 *    (1),(2),(3)은 modify schema만으로 modify method 결정
 *    그 외는 table의 column을 읽어 최종 modify method 결정
 *
 ***********************************************************************/

    qdTblColModifyMethod   sMethod = QD_TBL_COL_MODIFY_METHOD_NONE;
    qcmColumn            * sTableColumn;
    qcmColumn            * sModifyColumn;
    mtcColumn            * sTableColumnInfo;
    mtcColumn            * sModifyColumnInfo;
    qdVerifyColumn       * sVerifyColumn = NULL;
    idBool                 sIsDataLoss   = ID_FALSE;

    sTableColumn = aTableColumns;
    sModifyColumn = aModifyColumns;

    while ( sTableColumn != NULL )
    {
        IDE_DASSERT( sModifyColumn != NULL );

        sTableColumnInfo = sTableColumn->basicInfo;
        sModifyColumnInfo = sModifyColumn->basicInfo;

         //-----------------------------------------
        // (1) default value 변경인 경우, modify method 결정
        //-----------------------------------------

        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_DEFAULT_MASK)
             == QCM_COLUMN_MODIFY_DEFAULT_TRUE )
        {
            IDE_TEST( qdbCommon::convertDefaultValueType(
                          aStatement,
                          & sModifyColumnInfo->type,
                          sModifyColumn->defaultValue,
                          NULL )
                      != IDE_SUCCESS );

            // rebuild meta
            sMethod = sMethod > QD_TBL_COL_MODIFY_METHOD_ALTER_META ?
                sMethod : QD_TBL_COL_MODIFY_METHOD_ALTER_META;
        }
        else
        {
            // Nothing to do.
        }

        //-----------------------------------------
        // (2) (not) null 변경인 경우, modify method 결정
        //-----------------------------------------

        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_NULLABLE_MASK)
             == QCM_COLUMN_MODIFY_NULLABLE_NULL )
        {
            // rebuild meta
            sMethod = sMethod > QD_TBL_COL_MODIFY_METHOD_ALTER_META ?
                sMethod : QD_TBL_COL_MODIFY_METHOD_ALTER_META;
        }
        else if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_NULLABLE_MASK)
                  == QCM_COLUMN_MODIFY_NULLABLE_NOTNULL )
        {
            // sTableColumn에 null value가 없는지 검사해야함
            // null이 있으면 에러, 없으면 계속

            // verifyColumn 등록
            IDE_TEST( addVerifyColumn( aStatement,
                                       sTableColumn,
                                       QD_VERIFY_NOT_NULL,
                                       0,
                                       0,
                                       0,
                                       QD_CHANGE_STORED_TYPE_FALSE,
                                       & sVerifyColumn )
                      != IDE_SUCCESS );

            // rebuild meta
            sMethod = sMethod > QD_TBL_COL_MODIFY_METHOD_ALTER_META ?
                sMethod : QD_TBL_COL_MODIFY_METHOD_ALTER_META;
        }
        else
        {
            // Nothing to do.
        }

        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_COLUMN_OPTION_MASK)
             == QCM_COLUMN_MODIFY_COLUMN_OPTION_TRUE )
        {
            //-----------------------------------------
            // (3) column option을 변경한 경우, modify method 결정
            //-----------------------------------------

            // recreate table
            sMethod = sMethod > QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE ?
                sMethod : QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE;
        }
        else
        {
            // Nothing to do
        }

        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_TYPE_MASK)
             == QCM_COLUMN_MODIFY_TYPE_TRUE )
        {
            if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_LENGTH_MASK)
                 == QCM_COLUMN_MODIFY_LENGTH_TRUE )
            {
                //-----------------------------------------
                // (4) type과 length 변경한 경우, modify method 결정
                //     type 변환이지만, 저장 자료 구조가 동일하여
                //     length 변경과 유사하다.
                //
                // 아래와 같이 8가지 case가 있음
                // nchar->nvarchar
                // nvarchar->nchar
                // char->varchar
                // varchar->char
                // bit->varbit
                // varbit->bit
                // float->numeric
                // numeric->float
                //-----------------------------------------

                if ( (sTableColumnInfo->module->id == MTD_NCHAR_ID) ||
                     (sTableColumnInfo->module->id == MTD_CHAR_ID) ||
                     (sTableColumnInfo->module->id == MTD_BIT_ID) )
                {
                    //--------------------
                    // padding type -> non-padding type 변환과 length 변경
                    // 아래 3가지 case가 있음
                    // nchar->nvarchar
                    // char->varchar
                    // bit->varbit
                    //--------------------------------

                    if ( sTableColumnInfo->precision <=
                         sModifyColumnInfo->precision )
                    {
                        // length 변경 없거나 확대
                        // 예)
                        // char(3)->varchar(3)
                        // bit(3)->varbit(5)
                    }
                    else
                    {
                        // length 축소
                        // 예)
                        // char(3)->varchar(1)

                        // sTableColumn의 모든 value가 null인 경우,
                        //   rebuild meta
                        // 그외, 에러

                        // BUG-28317
                        // value가 모두 NULL인지 여부를 scan하지 않고도
                        // 알수 있다면 성능향상할 수 있음

                        // verifyColumn 등록
                        IDE_TEST( addVerifyColumn(
                                      aStatement,
                                      sTableColumn,
                                      QD_VERIFY_NULL,
                                      0,
                                      0,
                                      0,
                                      QD_CHANGE_STORED_TYPE_FALSE,
                                      & sVerifyColumn )
                                  != IDE_SUCCESS );
                    }
                }
                else if ( (sTableColumnInfo->module->id
                           == MTD_NVARCHAR_ID) ||
                          (sTableColumnInfo->module->id
                           == MTD_VARCHAR_ID) ||
                          (sTableColumnInfo->module->id
                           == MTD_VARBIT_ID) )
                {
                    //--------------------
                    // non-padding type -> padding type 변환과 length 변경
                    // 아래 3가지 case가 있음
                    // nvarchar->nchar
                    // varchar->char
                    // varbit->bit
                    //--------------------

                    if ( sTableColumnInfo->precision ==
                         sModifyColumnInfo->precision )
                    {
                        // length 변경 없음
                        // 예)
                        // nvarchar(4)->nchar(4)

                        // sTableColumn의 모든 value가 null 이거나
                        // sTableColumn의 모든 value의 length가
                        // sModifyColumn의 length와 같은 경우,
                        //    rebuild meta
                        // sTableColumn의 모든 value의 length가
                        // 변경하려는 length 이하인 경우,
                        //    recreate table
                        // 그외 경우,
                        //    error

                        // verifyColumn 등록
                        IDE_TEST(
                            addVerifyColumn(
                                aStatement,
                                sTableColumn,
                                QD_VERIFY_NULL_OR_EXACT_OR_UNDER_SIZE,
                                sModifyColumnInfo->column.size,
                                sModifyColumnInfo->precision,
                                ID_SINT_MAX,  // scale은 상관없음
                                QD_CHANGE_STORED_TYPE_FALSE,
                                & sVerifyColumn )
                            != IDE_SUCCESS );
                    }
                    else if ( sTableColumnInfo->precision <
                              sModifyColumnInfo->precision )
                    {
                        // length 확대
                        // 예)
                        // varbit(4)->bit(6)
                        // padding type으로 변경하는 경우 pad 문자를
                        // 생성해야 하므로
                        // sTableColumn의 value가 모두 null인 경우만
                        // 실시간완성으로 type 변경이 가능하다.

                        // sTableColumn이 모두 null value인 경우,
                        //    rebuild meta
                        // 그 외 경우,
                        //    recreate table

                        // BUG-28317
                        // value가 모두 NULL인지 여부를 scan하지 않고도
                        // 알수 있다면 성능향상할 수 있음

                        // verifyColumn 등록
                        IDE_TEST( addVerifyColumn(
                                      aStatement,
                                      sTableColumn,
                                      QD_VERIFY_NULL_ONLY,
                                      0,
                                      0,
                                      0,
                                      QD_CHANGE_STORED_TYPE_FALSE,
                                      & sVerifyColumn )
                                  != IDE_SUCCESS );
                    }
                    else
                    {
                        // length 축소
                        // 예)
                        // varchar(4)->char(3)
                        // sTableColumn value의 length가
                        // sModifyColumn의 length와 모두 같으면
                        // 실시간완성으로 type 변경이 가능하다.

                        // sTableColumn의 모든 value가 null 이거나
                        // sTableColumn의 모든 value의 length가
                        // sModifyColumn의 length와 같은 경우,
                        //    rebuild meta
                        // sTableColumn의 모든 value의 length가
                        // 변경하려는 length 이하인 경우,
                        //    recreate table
                        // 그외 경우,
                        //    error

                        // verifyColumn 등록
                        IDE_TEST(
                            addVerifyColumn(
                                aStatement,
                                sTableColumn,
                                QD_VERIFY_NULL_OR_EXACT_OR_UNDER_SIZE,
                                sModifyColumnInfo->column.size,
                                sModifyColumnInfo->precision,
                                ID_SINT_MAX,  // scale은 상관없음
                                QD_CHANGE_STORED_TYPE_FALSE,
                                & sVerifyColumn )
                            != IDE_SUCCESS );
                    }
                }
                else if ( sTableColumnInfo->module->id == MTD_FLOAT_ID )
                {
                    //--------------------
                    // float->numeric의 type과 length 변경
                    //
                    // 예)
                    // float(8)->numeric(10,2)
                    // float(3)->numeric(5)
                    //--------------------

                    // float->numeric의 경우 schema로는 length 확대인지
                    // 축소인지 판단할 수 없다.

                    // data loss 옵션 없이 numeric length 축소는 불가능
                    // 하다.
                    if ( (sModifyColumn->flag &
                          QCM_COLUMN_MODIFY_DATA_LOSS_MASK)
                         == QCM_COLUMN_MODIFY_DATA_LOSS_FALSE )
                    {
                        // data loss 옵션을 명시하지 않은 경우,
                        // sTableColumn의 value가 sModifyColumn의 length를
                        // 만족하는지 검사해야함
                        //
                        // sTableColumn의 모든 value의 length가
                        // sModifyColumn의 length 보다 작거나 같은 경우,
                        //    rebuild meta,
                        // 그외 경우,
                        //    error

                        // verifyColumn 등록
                        IDE_TEST(
                            addVerifyColumn(
                                aStatement,
                                sTableColumn,
                                QD_VERIFY_NULL_OR_UNDER_SIZE,
                                sModifyColumnInfo->column.size,
                                sModifyColumnInfo->precision,
                                sModifyColumnInfo->scale,
                                QD_CHANGE_STORED_TYPE_FALSE,
                                & sVerifyColumn )
                            != IDE_SUCCESS );
                    }
                    else
                    {
                        // sTableColumn의 모든 value가 null 인 경우,
                        //    rebuild meta
                        // 그 외 경우,
                        //    recreate table

                        // BUG-28317
                        // value가 모두 NULL인지 여부를 scan하지 않고도
                        // 알수 있다면 성능향상할 수 있음

                        // verifyColumn 등록
                        IDE_TEST( addVerifyColumn(
                                      aStatement,
                                      sTableColumn,
                                      QD_VERIFY_NULL_ONLY,
                                      0,
                                      0,
                                      0,
                                      QD_CHANGE_STORED_TYPE_FALSE,
                                      & sVerifyColumn )
                                  != IDE_SUCCESS );
                    }
                }
                else if ( sTableColumnInfo->module->id == MTD_NUMERIC_ID )
                {
                    //--------------------
                    // numeric->flat의 type과 length 변경
                    // 예)
                    // numeric(10,2)->float(10)
                    // numeric(5)->float(3)
                    //--------------------


                    if ( sTableColumnInfo->precision <=
                         sModifyColumnInfo->precision )
                    {
                        // sTableColumn value의 length가
                        // sModifyColumn의 length와
                        // 모두 같거나 작다면 실시간완성으로
                        // type 변경이 가능하다.
                        // 예)
                        // numeric(10,2)->float(10)
                        // numeric(10,2)->float(20)
                    }
                    else
                    {
                        // 예)
                        // numeric(5)->float(3)

                        // data loss 옵션 없이 numeric length 축소는
                        // 불가능하다.
                        if ( (sModifyColumn->flag &
                              QCM_COLUMN_MODIFY_DATA_LOSS_MASK)
                             == QCM_COLUMN_MODIFY_DATA_LOSS_FALSE )
                        {
                            // data loss 옵션을 명시하지 않은 경우
                            // sTableColumn의 모든 value가 NULL이거나
                            // sModifyColumn의 length 보다 작거나 같으면
                            //    rebuild meta
                            // 그 외 경우,
                            //   에러

                            // verifyColumn 등록
                            IDE_TEST(
                                addVerifyColumn(
                                    aStatement,
                                    sTableColumn,
                                    QD_VERIFY_NULL_OR_UNDER_SIZE,
                                    sModifyColumnInfo->column.size,
                                    sModifyColumnInfo->precision,
                                    ID_SINT_MAX,  // scale은 상관없음
                                    QD_CHANGE_STORED_TYPE_FALSE,
                                    & sVerifyColumn )
                                != IDE_SUCCESS );
                        }
                        else
                        {
                            // data loss 옵션을 명시한 경우
                            // sTableColumn의 모든 value가 NULL인 경우,
                            //   rebuild meta
                            // 그외 경우,
                            //   recreate table

                            // BUG-28317
                            // value가 모두 NULL인지 여부를 scan하지
                            // 않고도 알수 있다면 성능향상할 수 있음

                            // verifyColumn 등록
                            IDE_TEST( addVerifyColumn(
                                          aStatement,
                                          sTableColumn,
                                          QD_VERIFY_NULL_ONLY,
                                          0,
                                          0,
                                          0,
                                          QD_CHANGE_STORED_TYPE_FALSE,
                                          & sVerifyColumn )
                                      != IDE_SUCCESS );
                        }
                    }
                }
                else
                {
                    IDE_DASSERT( 0 );
                }
            }
            else
            {
                //-----------------------------------------
                // (5) length 변경으로 취급할 수 없는 나머지 경우,
                //     modify method 결정
                //
                // 아래와 같이 2가지 case가 있음
                // char->integer
                // varchar->date
                // 예)
                // char(4)->integer
                // varchar(8)->date
                //-----------------------------------------

                // sTableColumn의 value가 모두 null인 경우
                // 실시간완성으로 type 변경이 가능하다.

                IDE_TEST( isDataLossConversion(
                              sTableColumnInfo->module->id,
                              sModifyColumnInfo->module->id,
                              & sIsDataLoss )
                          != IDE_SUCCESS );

                if ( ( sIsDataLoss == ID_TRUE ) &&
                     ( (sModifyColumn->flag &
                        QCM_COLUMN_MODIFY_DATA_LOSS_MASK)
                       == QCM_COLUMN_MODIFY_DATA_LOSS_FALSE ) )
                {
                    // data loss 옵션을 명시하지 않은 경우

                    // sTableColumn의 모든 value가 모두 null인 경우,
                    //    rebuild meta
                    // 그 외 경우,
                    //    에러


                    // BUG-28317
                    // value가 모두 NULL인지 여부를 scan하지 않고도
                    // 알수 있다면 성능향상할 수 있음

                    // verifyColumn 등록
                    IDE_TEST( addVerifyColumn( aStatement,
                                               sTableColumn,
                                               QD_VERIFY_NULL,
                                               0,
                                               0,
                                               0,
                                               QD_CHANGE_STORED_TYPE_TRUE,
                                               & sVerifyColumn )
                              != IDE_SUCCESS );
                }
                else
                {
                    // sTableColumn의 모든 value가 모두 null인 경우,
                    //    rebuild meta
                    // 그외 경우,
                    //    recreate table

                    // BUG-28317
                    // value가 모두 NULL인지 여부를 scan하지 않고도
                    // 알수 있다면 성능향상할 수 있음

                    // verifyColumn 등록
                    IDE_TEST( addVerifyColumn( aStatement,
                                               sTableColumn,
                                               QD_VERIFY_NULL_ONLY,
                                               0,
                                               0,
                                               0,
                                               QD_CHANGE_STORED_TYPE_TRUE,
                                               & sVerifyColumn )
                              != IDE_SUCCESS );
                }
            }
        }
        else
        {
            if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_LENGTH_MASK)
                 == QCM_COLUMN_MODIFY_LENGTH_TRUE )
            {
                //-----------------------------------------
                // (6) type 변경없이 length만 변경한 경우,
                //     modify method 결정
                //
                // 아래와 같이 10가지 case가 있음
                // nchar
                // nvarchar
                // char
                // varchar
                // bit
                // varbit
                // float
                // numeric
                // byte
                // nibble
                //-----------------------------------------

                if ( (sTableColumnInfo->module->id == MTD_NCHAR_ID) ||
                     (sTableColumnInfo->module->id == MTD_CHAR_ID)  ||
                     (sTableColumnInfo->module->id == MTD_BIT_ID)   ||
                     (sTableColumnInfo->module->id == MTD_BYTE_ID) )
                {
                    //--------------------------------
                    // padding type의 length 변경
                    // 아래 4가지 case가 있음
                    // nchar, char, bit, byte
                    //--------------------------------

                    if ( sTableColumnInfo->precision ==
                         sModifyColumnInfo->precision )
                    {
                        // length 변경 없음
                        // 예)
                        // char(3)->char(3)
                    }
                    else if ( sTableColumnInfo->precision <
                              sModifyColumnInfo->precision )
                    {
                        // length 확대
                        // 예)
                        // char(3)->char(5) length 확대
                        // sTableColumn의 value가 모두 null인 경우
                        // 실시간완성으로 type 변경이 가능하다.

                        // sTableColumn의 모든 value가 모두 null인 경우,
                        //    rebuild meta,
                        // 그외 경우,
                        //    recreate table

                        // BUG-28317
                        // value가 모두 NULL인지 여부를 scan하지 않고도
                        // 알수 있다면 성능향상할 수 있음

                        // verifyColumn 등록
                        IDE_TEST( addVerifyColumn(
                                      aStatement,
                                      sTableColumn,
                                      QD_VERIFY_NULL_ONLY,
                                      0,
                                      0,
                                      0,
                                      QD_CHANGE_STORED_TYPE_FALSE,
                                      & sVerifyColumn )
                                  != IDE_SUCCESS );
                    }
                    else
                    {
                        // length 축소
                        // 예)
                        // char(3)->char(1) length 축소
                        // sTableColumn의 value가 모두 null인 경우
                        // 실시간완성으로 type 변경이 가능하다.

                        // sTableColumn의 모든 value가 모두 null인 경우,
                        //    rebuild meta,
                        // 그외 경우,
                        //    error

                        // BUG-28317
                        // value가 모두 NULL인지 여부를 scan하지 않고도
                        // 알수 있다면 성능향상할 수 있음

                        // verifyColumn 등록
                        IDE_TEST( addVerifyColumn(
                                      aStatement,
                                      sTableColumn,
                                      QD_VERIFY_NULL,
                                      0,
                                      0,
                                      0,
                                      QD_CHANGE_STORED_TYPE_FALSE,
                                      & sVerifyColumn )
                                  != IDE_SUCCESS );
                    }
                }
                else if (
                    (sTableColumnInfo->module->id == MTD_NVARCHAR_ID) ||
                    (sTableColumnInfo->module->id == MTD_VARCHAR_ID)  ||
                    (sTableColumnInfo->module->id == MTD_VARBYTE_ID)  ||
                    (sTableColumnInfo->module->id == MTD_VARBIT_ID)   ||
                    (sTableColumnInfo->module->id == MTD_NIBBLE_ID) )
                {
                    //--------------------------------
                    // non-padding type의 length 변경
                    // 아래 4가지 case가 있음
                    // nvarchar, varchar, varbit, nibble
                    //--------------------------------

                    if ( sTableColumnInfo->precision <=
                         sModifyColumnInfo->precision )
                    {
                        // length 변경 없거나 확대
                        // 예)
                        // nvarchar(5)->nvarchar(5)
                        // varchar(5)->varchar(10) length 확대
                    }
                    else
                    {
                        // length 축소
                        // 예)
                        // varchar(5)->varchar(3) length 축소

                        // sTableColumn의 모든 value가 null 이거나
                        // sTableColumn의 모든 value의 length가
                        // sModifyColumn의 length 와 같거나 작은 경우,
                        //    rebuild meta
                        // 그외 경우
                        //    error

                        // verifyColumn 등록
                        IDE_TEST(
                            addVerifyColumn(
                                aStatement,
                                sTableColumn,
                                QD_VERIFY_NULL_OR_UNDER_SIZE,
                                sModifyColumnInfo->column.size,
                                sModifyColumnInfo->precision,
                                ID_SINT_MAX,  // scale은 상관없음
                                QD_CHANGE_STORED_TYPE_FALSE,
                                & sVerifyColumn )
                            != IDE_SUCCESS );
                    }
                }
                else if ( sTableColumnInfo->module->id == MTD_FLOAT_ID )
                {
                    //--------------------------------
                    // float 의 length 변경
                    //--------------------------------

                    if ( sTableColumnInfo->precision <=
                         sModifyColumnInfo->precision )
                    {
                        // length 변경 없거나 확대
                        // 예)
                        // float(5)->float(5)
                        // float(5)->float(10) length 확대
                    }
                    else
                    {
                        // length 축소
                        // 예)
                        // float(5)->float(3) length 축소

                        // data loss 옵션 없이 float length 축소는
                        // 불가능하다.
                        if ( (sModifyColumn->flag &
                              QCM_COLUMN_MODIFY_DATA_LOSS_MASK)
                             == QCM_COLUMN_MODIFY_DATA_LOSS_FALSE )
                        {
                            // data loss 옵션을 명시하지 않은 경우

                            // sTableColumn의 모든 value가 null 이거나
                            // sTableColumn의 모든 value의 length가
                            // sModifyColumn의 length보다 작거나 같으면
                            //    rebuild meta
                            // 그외 경우,
                            //    error

                            // verifyColumn 등록
                            IDE_TEST(
                                addVerifyColumn(
                                    aStatement,
                                    sTableColumn,
                                    QD_VERIFY_NULL_OR_UNDER_SIZE,
                                    sModifyColumnInfo->column.size,
                                    sModifyColumnInfo->precision,
                                    ID_SINT_MAX,  // scale은 상관없음
                                    QD_CHANGE_STORED_TYPE_FALSE,
                                    & sVerifyColumn )
                                != IDE_SUCCESS );
                        }
                        else
                        {
                            // sTableColumn의 모든 value가 null인 경우,
                            //    rebuild meta
                            // 그외 경우,
                            //    recreate table

                            // BUG-28317
                            // value가 모두 NULL인지 여부를 scan하지
                            // 않고도 알수 있다면 성능향상할 수 있음

                            // verifyColumn 등록
                            IDE_TEST(
                                addVerifyColumn(
                                    aStatement,
                                    sTableColumn,
                                    QD_VERIFY_NULL_ONLY,
                                    0,
                                    0,
                                    0,
                                    QD_CHANGE_STORED_TYPE_FALSE,
                                    & sVerifyColumn )
                                != IDE_SUCCESS );
                        }
                    }
                }
                else if ( sTableColumnInfo->module->id == MTD_NUMERIC_ID )
                {
                    //--------------------------------
                    // numeric 의 length 변경
                    // 예)
                    // numeric(5)->numeric(10) length 확대
                    // numeric(5)->numeric(3) length 축소
                    // numeric(5)->numeric(5,0)
                    // numeric(10,2)->numeric(15,3) length 확대
                    // numeric(10,2)->numeric(10,0) length 축소
                    // numeric(10,2)->numeric(10,2)
                    //--------------------------------

                    if ( isEnlargingLengthForNumericType(
                             sTableColumnInfo->precision,
                             sTableColumnInfo->scale,
                             sModifyColumnInfo->precision,
                             sModifyColumnInfo->scale )
                         == ID_TRUE )
                    {
                        // length 확대
                        // 예)
                        // numeric(5)->numeric(10) length 확대
                        // numeric(10,2)->numeric(15,3) length 확대
                        // numeric(5)->numeric(5,0)
                        // numeric(10,2)->numeric(10,2)
                    }
                    else
                    {
                        // length 축소
                        // 예)
                        // numeric(5)->numeric(3) length 축소
                        // numeric(10,2)->numeric(10,0) length 축소

                        // data loss 옵션 없이 numeric length 축소는
                        // 불가능하다.
                        if ( (sModifyColumn->flag &
                              QCM_COLUMN_MODIFY_DATA_LOSS_MASK)
                             == QCM_COLUMN_MODIFY_DATA_LOSS_FALSE )
                        {
                            // data loss 옵션을 명시하지 않은 경우

                            // sTableColumn의 모든 value가 null 이거나
                            // sTableColumn의 모든 value의 length가
                            // sModifyColumn의 length 와 같거나 작으면,
                            //    rebuild meta
                            // 그외 경우
                            //    error

                            // verifyColumn 등록
                            IDE_TEST(
                                addVerifyColumn(
                                    aStatement,
                                    sTableColumn,
                                    QD_VERIFY_NULL_OR_UNDER_SIZE,
                                    sModifyColumnInfo->column.size,
                                    sModifyColumnInfo->precision,
                                    sModifyColumnInfo->scale,
                                    QD_CHANGE_STORED_TYPE_FALSE,
                                    & sVerifyColumn )
                                != IDE_SUCCESS );
                        }
                        else
                        {
                            // sTableColumn의 모든 value가 null인 경우,
                            //    rebuild meta
                            // 그외 경우,
                            //    recreate table

                            // BUG-28317
                            // value가 모두 NULL인지 여부를 scan하지
                            // 않고도 알수 있다면 성능향상할 수 있음

                            // verifyColumn 등록
                            IDE_TEST( addVerifyColumn(
                                          aStatement,
                                          sTableColumn,
                                          QD_VERIFY_NULL_ONLY,
                                          0,
                                          0,
                                          0,
                                          QD_CHANGE_STORED_TYPE_FALSE,
                                          & sVerifyColumn )
                                      != IDE_SUCCESS );
                        }
                    }
                }
                else if ( sTableColumnInfo->module->id == MTD_GEOMETRY_ID )
                {
                    //--------------------------------
                    // geometry 의 length 변경
                    //--------------------------------

                    if ( sTableColumnInfo->precision <=
                         sModifyColumnInfo->precision )
                    {
                        // length 변경 없거나 확대
                        // 예)
                        // geometry(3)->geometry(3)
                        // geometry(3)->geometry(5) length 확대
                    }
                    else
                    {
                        // length 축소
                        // sTableColumn의 모든 value가 null 이거나
                        // sTableColumn의 모든 value의 length가
                        // sModifyColumn의 length와 같거나 작은 경우,
                        //    rebuild meta
                        // 그외 경우,
                        //    error
                        //

                        // verifyColumn 등록
                        IDE_TEST(
                            addVerifyColumn(
                                aStatement,
                                sTableColumn,
                                QD_VERIFY_NULL_OR_UNDER_SIZE,
                                sModifyColumnInfo->column.size,
                                sModifyColumnInfo->precision,
                                ID_SINT_MAX,  // scale은 상관없음
                                QD_CHANGE_STORED_TYPE_FALSE,
                                & sVerifyColumn )
                            != IDE_SUCCESS );
                    }
                }
                else
                {
                    IDE_DASSERT( 0 );
                }
            }
            else
            {
                // Nothing to do.
            }
        }

        sMethod = sMethod > QD_TBL_COL_MODIFY_METHOD_ALTER_META ?
            sMethod : QD_TBL_COL_MODIFY_METHOD_ALTER_META;

        sTableColumn = sTableColumn->next;
        sModifyColumn = sModifyColumn->next;
    }

    *aMethod = sMethod;
    *aVerifyColumn = sVerifyColumn;

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::modifyIndexColumnInfo( qcStatement     * aStatement,
                                        qdVerifyColumn  * aVerifyColumns,
                                        idBool            aIsTablePartition,
                                        qcmTableInfo   ** aNewTableInfo )
{
 /***********************************************************************
 *
 * Description : PROJ-1911
 *    disk table 의 index 정보 변경
 *
 * Implementation :
 *
 ***********************************************************************/

    qcmTableInfo         * sTableInfo;
    UInt                   sIndexCount;
    qdIdxColModify       * sIdxColModify;
    qcmIndex             * sIndex;
    mtcColumn            * sKeyColumn = NULL;
    qdVerifyColumn       * sVerifyColumn = NULL;
    idBool                 sAlterMeta = ID_TRUE;
    const void           * sIndexHandle = NULL;
    UInt                   i;
    UInt                   j;

    sTableInfo  = *aNewTableInfo;
    sIndexCount = sTableInfo->indexCount;

    if ( sIndexCount > 0 )
    {
        IDU_LIMITPOINT("qdbAlter::modifyIndexColumnInfo::malloc");
        IDE_TEST( aStatement->qmxMem->alloc(
                      ID_SIZEOF(qdIdxColModify) * sIndexCount,
                      (void**) &sIdxColModify )
                  != IDE_SUCCESS );
    }

    /* BUG-31868
     * 실시간 Alter table 실행시, 대상 테이블내 모든 인덱스의 메타를 재구성해야 합니다.
     * 인덱스 앞의 컬럼이 수정되면 index 컬럼의 위치도 변경되므로 된다.
     * 따라서 간단하게 모든 인덱스의 정보를 수정하도록 한다.
     */
    for ( i = 0; i < sIndexCount; i++ )
    {
        sIndex                   = &sTableInfo->indices[i];
        sIdxColModify[i].indexId = sIndex->indexId;

        sAlterMeta = ID_TRUE;

        for ( j = 0; j < sIndex->keyColCount; j++ )
        {
            sKeyColumn = & sIndex->keyColumns[j];

            for ( sVerifyColumn = aVerifyColumns;
                  sVerifyColumn != NULL;
                  sVerifyColumn = sVerifyColumn->next )
            {
                if ( sVerifyColumn->column->basicInfo->column.id ==
                     sKeyColumn->column.id )
                {
                    if ( sVerifyColumn->changeStoredType ==
                         QD_CHANGE_STORED_TYPE_TRUE )
                    {
                        // key column 중 하나라도 저장 타입이
                        // 변경되는 경우
                        // index를 재생성 해야 함
                        sAlterMeta = ID_FALSE;
                        break;
                    }
                    else
                    {
                        // nothing to do
                    }
                    
                    // fix BUG-33004
                    // 저장 타입이 변경되지 않아도
                    // 컬럼의 크기가 변경되는 경우에는
                    // index를 재생성 해주어야 한다.
                    if ( sVerifyColumn->column->basicInfo->column.size !=
                         sKeyColumn->column.size )
                    {
                        sAlterMeta = ID_FALSE;
                        break;
                    }
                    else
                    {
                        // nothing to do
                    }
                }
                else
                {
                    // nothing to do
                }
            }
        }

        if ( sAlterMeta == ID_TRUE )
        {
            sIdxColModify[i].method = QD_IDX_COL_MODIFY_METHOD_ALTER_META;
        }
        else
        {
            sIdxColModify[i].method = QD_IDX_COL_MODIFY_METHOD_RECREATE_INDEX;
        }
    }

    for ( i = 0; i < sIndexCount; i++ )
    {
        //-----------------------------------------
        // Table의 Index column 정보 변경
        //-----------------------------------------

        // 이전 index가 recreate되면
        // handle이 바뀌기 때문에 SM Interface로부터 새 handle을
        // 가져와야 함

        sIndex       = &sTableInfo->indices[i];
        sIndexHandle = smiGetTableIndexByID( sTableInfo->tableHandle,
                                             sTableInfo->indices[i].indexId );

        if ( sIdxColModify[i].method == QD_IDX_COL_MODIFY_METHOD_ALTER_META )
        {
            // Meta 변경만 해도 되는 index
            IDE_TEST( alterIndexMetaForDisk(aStatement,
                                            aIsTablePartition,
                                            &sTableInfo )
                      != IDE_SUCCESS );
        }
        else // QD_IDX_COL_MODIFY_METHOD_RECREATE_INDEX
        {
            // recreate 해야 되는 index
            IDE_TEST( recreateIndexForDisk(aStatement,
                                           sIndexHandle,
                                           sIndex,
                                           ID_FALSE,
                                           aIsTablePartition,
                                           &sTableInfo,
                                           NULL,
                                           NULL,
                                           NULL )
                        != IDE_SUCCESS );
        }

        // BUG-36045
        *aNewTableInfo = sTableInfo;
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::recreateIndexColumnInfo( qcStatement       * aStatement,
                                          qcmColumn         * /*aModifyColumns*/,
                                          qcmTableInfo     ** aNewTableInfo,
                                          qdIndexTableList  * aOldIndexTables,
                                          qdIndexTableList ** aNewIndexTables,
                                          qdIndexTableList ** aDelIndexTables )
{
 /***********************************************************************
 *
 * Description : PROJ-1624 non-partitioned index
 *     alter modify column시 modify column에 속하는 non-partitioned index의
 *     index table을 재생성한다.
 *
 * Implementation :
 *
 ***********************************************************************/

    qcmTableInfo         * sTableInfo;
    UInt                   sIndexCount;
    qcmIndex             * sIndex;
    const void           * sIndexHandle = NULL;
    UInt                   i;

    sTableInfo  = *aNewTableInfo;
    sIndexCount = sTableInfo->indexCount;

    /* BUG-31868
     * 실시간 Alter table 실행시, 대상 테이블내 모든 인덱스의 메타를 재구성해야 합니다.
     * 인덱스 앞의 컬럼이 수정되면 index 컬럼의 위치도 변경되므로 된다.
     * 따라서 간단하게 모든 인덱스의 정보를 수정하도록 한다.
     */
    for ( i = 0; i < sIndexCount; i++ )
    {
        sIndex = &sTableInfo->indices[i];

        if ( sIndex->indexPartitionType == QCM_NONE_PARTITIONED_INDEX )
        {
            // 이전 index가 recreate되면
            // handle이 바뀌기 때문에 SM Interface로부터 새 handle을
            // 가져와야 함
            sIndexHandle = smiGetTableIndexByID( sTableInfo->tableHandle,
                                                 sTableInfo->indices[i].indexId );

            IDE_TEST( recreateIndexForDisk( aStatement,
                                            sIndexHandle,
                                            sIndex,
                                            ID_TRUE,  // partitioned table
                                            ID_FALSE, // table partition
                                            & sTableInfo,
                                            aOldIndexTables,
                                            aNewIndexTables,
                                            aDelIndexTables )
                      != IDE_SUCCESS );
        }
        else
        {
            // Nothing to do.
        }
    }

    *aNewTableInfo = sTableInfo;

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::alterIndexMetaForDisk( qcStatement   * aStatement,        // in
                                        idBool          aIsTablePartition, // in
                                        qcmTableInfo ** aNewTableInfo )    // in,out
{
/***********************************************************************
 *
 * Description : PROJ-1911 index meta의 column 정보 변경
 *
 * Implementation :
 *
 ***********************************************************************/

    qcmTableInfo    * sOldTableInfo = NULL;
    qcmTableInfo    * sNewTableInfo = NULL;
    void            * sTableHandle;
    smSCN             sSCN;

    sOldTableInfo = *aNewTableInfo;

    IDE_ASSERT( sOldTableInfo != NULL );    // TASK-3876 Code Sonar

    //-----------------------------------------
    // cached meta 재생성
    //-----------------------------------------

    if ( aIsTablePartition == ID_TRUE )
    {
        IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                      QC_SMI_STMT( aStatement ),
                      sOldTableInfo->partitionID,
                      smiGetTableId( sOldTableInfo->tableHandle ),
                      sOldTableInfo,
                      NULL )
                  != IDE_SUCCESS );

        IDE_TEST(
            qcmPartition::getPartitionInfoByID( aStatement,
                                                sOldTableInfo->partitionID,
                                                & sNewTableInfo,
                                                & sSCN,
                                                & sTableHandle )
            != IDE_SUCCESS );

        (void) qcmPartition::destroyQcmPartitionInfo( sOldTableInfo );
    }
    else
    {
        IDE_TEST( qcm::makeAndSetQcmTableInfo(
                      QC_SMI_STMT( aStatement ),
                      sOldTableInfo->tableID,
                      smiGetTableId( sOldTableInfo->tableHandle ) )
                  != IDE_SUCCESS );

        IDE_TEST( qcm::getTableInfoByID( aStatement,
                                         sOldTableInfo->tableID,
                                         & sNewTableInfo,
                                         & sSCN,
                                         & sTableHandle )
                  != IDE_SUCCESS);

        (void) qcm::destroyQcmTableInfo( sOldTableInfo );
    }

    *aNewTableInfo = sNewTableInfo;

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    if ( sNewTableInfo != NULL )
    {
        if ( aIsTablePartition == ID_TRUE )
        {
            (void) qcmPartition::destroyQcmPartitionInfo( sNewTableInfo );
        }
        else
        {
            (void) qcm::destroyQcmTableInfo( sNewTableInfo );
        }
    }

    return IDE_FAILURE;
}

IDE_RC qdbAlter::recreateIndexForDisk( qcStatement       * aStatement,          // in
                                       const void        * aIndexHandle,        // in
                                       qcmIndex          * aIndex,              // in
                                       idBool              aIsPartitionedTable, // in
                                       idBool              aIsTablePartition,   // in
                                       qcmTableInfo     ** aNewTableInfo,       // in,out
                                       qdIndexTableList  * aOldIndexTables,     // in
                                       qdIndexTableList ** aNewIndexTables,     // in,out
                                       qdIndexTableList ** aDelIndexTables )    // out
{
 /***********************************************************************
 *
 * Description : PROJ-1911
 *     index 재생성
 *
 * Implementation :
 *     하나의 index 재생성
 *     (1) partitioned table인 경우 partitioned table
 *     (2) partitioned table인 경우 table partition
 *     (3) non-partitioned table인 경우 table
 *
 ***********************************************************************/

    smiColumnList        * sColumnListAtKey;
    qcmTableInfo         * sOldTableInfo   = NULL;
    qcmTableInfo         * sNewTableInfo   = NULL;
    qcmTableInfo         * sIndexTableInfo = NULL;
    UInt                   sFlag;
    smiSegAttr             sSegAttr;
    smiSegStorageAttr      sSegStoAttr;
    smSCN                  sSCN;
    void                 * sTableHandle;
    const void           * sNewIndexHandle;
    qcmPartitionInfoList * sTempPartInfoList = NULL;
    qdIndexTableList     * sOldIndexTable = NULL;
    qdIndexTableList     * sNewIndexTable = NULL;
    qdIndexTableList     * sIndexTable = NULL;
    qcmIndex             * sIndexTableIndex[2];
    qcNamePosition         sIndexTableNamePos;
    UInt                   sIndexTableFlag;
    UInt                   sIndexTableParallelDegree;
    qcmColumn            * sColumns;
    UInt                   sColumnCount;
    
    sOldTableInfo = *aNewTableInfo;

    IDE_ASSERT( sOldTableInfo != NULL );    // TASK-3876 Code Sonar

    //-----------------------------------------
    // index를 재생성한다.
    //-----------------------------------------

    // 인덱스 생성을 위한 flag
    sFlag = smiTable::getIndexInfo( aIndexHandle );
    sSegAttr = smiTable::getIndexSegAttr( aIndexHandle );
    sSegStoAttr = smiTable::getIndexSegStoAttr( aIndexHandle );

    // 해당 인덱스 제거
    IDE_TEST( smiTable::dropIndex( QC_SMI_STMT( aStatement ),
                                   sOldTableInfo->tableHandle,
                                   aIndexHandle,
                                   SMI_TBSLV_DDL_DML )
              != IDE_SUCCESS);

    // 인덱스 생성을 위한 키 컬럼 정보를 구한다.
    // index keyColumn type flag는 sIndex에 이미 설정되어 있다.
    IDE_TEST( qdx::getKeyColumnList( aStatement,
                                     aIndex,
                                     & sColumnListAtKey )
              != IDE_SUCCESS );

    // 인덱스 생성
    IDE_TEST( smiTable::createIndex(
                  aStatement->mStatistics,
                  QC_SMI_STMT( aStatement ),
                  aIndex->TBSID,
                  sOldTableInfo->tableHandle,
                  (SChar*)aIndex->name,
                  aIndex->indexId,
                  aIndex->indexTypeId,
                  sColumnListAtKey,
                  sFlag,
                  QD_INDEX_DEFAULT_PARALLEL_DEGREE,
                  SMI_INDEX_BUILD_UNCOMMITTED_ROW_DISABLE,
                  sSegAttr,
                  sSegStoAttr,
                  0, /* PROJ-2433 : disk에서는 direct key index 사용안함 */
                  & sNewIndexHandle )
              != IDE_SUCCESS );

    // PROJ-1624 global non-partitioned index
    // 새로운 index table을 생성한다.
    if ( ( aIsPartitionedTable == ID_TRUE ) &&
         ( aIsTablePartition == ID_FALSE ) &&
         ( aIndex->indexPartitionType == QCM_NONE_PARTITIONED_INDEX ) )
    {
        IDE_DASSERT( aOldIndexTables != NULL );
        IDE_DASSERT( aNewIndexTables != NULL );
        IDE_DASSERT( aDelIndexTables != NULL );
        
        IDE_TEST_RAISE( aIndex->indexTableID == 0, ERR_META_CRASH );

        IDE_TEST( qdx::findIndexTableInList( aOldIndexTables,
                                             aIndex->indexTableID,
                                             & sOldIndexTable )
                  != IDE_SUCCESS );

        // drop된 index table를 생성하여 연결한다.
        IDE_TEST( aStatement->qmxMem->alloc(
                      ID_SIZEOF(qdIndexTableList),
                      (void**)&sIndexTable )
                  != IDE_SUCCESS);

        idlOS::memcpy( sIndexTable,
                       sOldIndexTable,
                       ID_SIZEOF(qdIndexTableList) );

        sIndexTable->next = *aDelIndexTables;
        *aDelIndexTables = sIndexTable;
        
        //---------------------------
        // drop old index table
        //---------------------------
            
        IDE_TEST( qdx::dropIndexTable( aStatement,
                                       sOldIndexTable,
                                       ID_FALSE /* aIsDropTablespace */ )
                  != IDE_SUCCESS );
            
        //---------------------------
        // create new index table
        //---------------------------
            
        sIndexTableFlag = sOldIndexTable->tableInfo->tableFlag;
        sIndexTableParallelDegree = sOldIndexTable->tableInfo->parallelDegree;

        sIndexTableNamePos.stmtText = sOldIndexTable->tableInfo->name;
        sIndexTableNamePos.offset   = 0;
        sIndexTableNamePos.size     =
            idlOS::strlen(sOldIndexTable->tableInfo->name);

        // modified table info로 index table column을 생성한다.
        IDE_TEST( qdx::makeColumns4ModifyColumn( aStatement,
                                                 sOldTableInfo,
                                                 aIndex->keyColumns,
                                                 aIndex->keyColCount,
                                                 aIndex->TBSID,
                                                 & sColumns,
                                                 & sColumnCount )
                  != IDE_SUCCESS );
        
        IDE_TEST( qdx::createIndexTable( aStatement,
                                         sOldIndexTable->tableInfo->tableOwnerID,
                                         sIndexTableNamePos,
                                         sColumns,
                                         sColumnCount,
                                         aIndex->TBSID,
                                         sOldIndexTable->tableInfo->segAttr, // sSegAttr는 index용이다.
                                         sSegStoAttr,
                                         QDB_TABLE_ATTR_MASK_ALL,
                                         sIndexTableFlag, /* Flag Value */
                                         sIndexTableParallelDegree,
                                         & sNewIndexTable )
                  != IDE_SUCCESS );
        
        // link new index table
        sNewIndexTable->next = *aNewIndexTables;
        *aNewIndexTables = sNewIndexTable;

        // key index, rid index를 찾는다.
        IDE_TEST( qdx::getIndexTableIndices( sOldIndexTable->tableInfo,
                                             sIndexTableIndex )
                  != IDE_SUCCESS );
            
        IDE_TEST( qdx::createIndexTableIndices(
                      aStatement,
                      sOldIndexTable->tableInfo->tableOwnerID,
                      sNewIndexTable,
                      NULL,
                      sIndexTableIndex[0]->name,
                      sIndexTableIndex[1]->name,
                      sIndexTableIndex[0]->TBSID,
                      sIndexTableIndex[0]->indexTypeId,
                      sFlag,
                      QD_INDEX_DEFAULT_PARALLEL_DEGREE,
                      SMI_INDEX_BUILD_UNCOMMITTED_ROW_DISABLE,
                      sSegAttr,
                      sSegStoAttr,
                      0 ) /* PROJ-2433 : disk에서는 direct key index 사용안함 */
                  != IDE_SUCCESS );
        
        sIndexTableInfo = sNewIndexTable->tableInfo;

        IDE_TEST(qcm::makeAndSetQcmTableInfo(QC_SMI_STMT(aStatement),
                                             sNewIndexTable->tableID,
                                             sNewIndexTable->tableOID)
                 != IDE_SUCCESS);
            
        IDE_TEST(qcm::getTableInfoByID(aStatement,
                                       sNewIndexTable->tableID,
                                       &(sNewIndexTable->tableInfo),
                                       &(sNewIndexTable->tableSCN),
                                       &(sNewIndexTable->tableHandle))
                 != IDE_SUCCESS);
        (void)qcm::destroyQcmTableInfo( sIndexTableInfo );
        
        //---------------------------
        // build new index table
        //---------------------------

        IDE_TEST( qcmPartition::getPartitionInfoList( aStatement,
                                                      QC_SMI_STMT( aStatement ),
                                                      aStatement->qmxMem,
                                                      sOldTableInfo->tableID,
                                                      & sTempPartInfoList )
                  != IDE_SUCCESS );
        
        // index key mtcColumn을 table qcmColumn으로 변환한다.
        IDE_TEST( qdx::makeColumns4BuildIndexTable( aStatement,
                                                    sOldTableInfo,
                                                    aIndex->keyColumns,
                                                    aIndex->keyColCount,
                                                    & sColumns,
                                                    & sColumnCount )
                  != IDE_SUCCESS );
        
        IDE_TEST( qdx::buildIndexTable( aStatement,
                                        sNewIndexTable,
                                        sColumns,
                                        sColumnCount,
                                        sOldTableInfo,
                                        sTempPartInfoList )
                  != IDE_SUCCESS );
        
        //---------------------------
        // update meta table
        //---------------------------

        IDE_TEST( qdx::updateIndexSpecFromMeta( aStatement,
                                                aIndex->indexId,
                                                sNewIndexTable->tableID )
                  != IDE_SUCCESS );
    }
    else
    {
        // Nothing to do.
    }
    
    //-----------------------------------------
    // cached meta 재생성
    //-----------------------------------------

    // qdbAlter::alterMetaForDisk()에서 touch를 이미 수행했다.

    if ( aIsTablePartition == ID_TRUE )
    {
        IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                      QC_SMI_STMT( aStatement ),
                      sOldTableInfo->partitionID,
                      smiGetTableId( sOldTableInfo->tableHandle ),
                      sOldTableInfo,
                      NULL )
                  != IDE_SUCCESS );

        IDE_TEST( qcmPartition::getPartitionInfoByID(
                      aStatement,
                      sOldTableInfo->partitionID,
                      & sNewTableInfo,
                      & sSCN,
                      & sTableHandle )
                  != IDE_SUCCESS );

        (void) qcmPartition::destroyQcmPartitionInfo( sOldTableInfo );
    }
    else
    {
        IDE_TEST( qcm::makeAndSetQcmTableInfo(
                      QC_SMI_STMT( aStatement ),
                      sOldTableInfo->tableID,
                      smiGetTableId( sOldTableInfo->tableHandle ) )
                  != IDE_SUCCESS );

        IDE_TEST( qcm::getTableInfoByID( aStatement,
                                         sOldTableInfo->tableID,
                                         & sNewTableInfo,
                                         & sSCN,
                                         & sTableHandle )
                  != IDE_SUCCESS);

        (void) qcm::destroyQcmTableInfo( sOldTableInfo );
    }

    *aNewTableInfo = sNewTableInfo;

    return IDE_SUCCESS;

    IDE_EXCEPTION(ERR_META_CRASH)
    {
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QCM_META_CRASH));
    }
    IDE_EXCEPTION_END;

    if ( sNewTableInfo != NULL )
    {
        if ( aIsTablePartition == ID_TRUE )
        {
            (void) qcmPartition::destroyQcmPartitionInfo( sNewTableInfo );
        }
        else
        {
            (void) qcm::destroyQcmTableInfo( sNewTableInfo );
        }
    }

    /* Index Table List의 Meta Cache는 상위 함수에서 제거한다. */
    
    return IDE_FAILURE;
}

IDE_RC qdbAlter::addVerifyColumn( qcStatement         * aStatement,
                                  qcmColumn           * aTableColumn,
                                  qdVerifyCommand       aCommand,
                                  UInt                  aSize,
                                  SInt                  aPrecision,
                                  SInt                  aScale,
                                  qdChangeStoredType    aChangeStoredType,
                                  qdVerifyColumn     ** aVerifyColumn )
{
 /***********************************************************************
 *
 * Description : PROJ-1877
 *
 * Implementation :
 *
 ***********************************************************************/

    qdVerifyColumn  * sColumn;

    // sVerifyColumn 생성
    IDU_LIMITPOINT("qdbAlter::addVerifyColumn::malloc");
    IDE_TEST( aStatement->qmxMem->alloc( ID_SIZEOF(qdVerifyColumn),
                                         (void**) & sColumn )
              != IDE_SUCCESS );

    // sVerifyColumn 초기화
    sColumn->column           = aTableColumn;
    sColumn->command          = aCommand;
    sColumn->size             = aSize;
    sColumn->precision        = aPrecision;
    sColumn->scale            = aScale;
    sColumn->changeStoredType = aChangeStoredType;
    sColumn->next             = *aVerifyColumn;

    // sVerifyColumn 연결
    *aVerifyColumn = sColumn;

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

idBool qdbAlter::isNullOnlyCommand( qdVerifyColumn * aVerifyColumn )
{
 /***********************************************************************
 *
 * Description : PROJ-1877
 *     verify command가 모두 QD_VERIFY_NULL_ONLY인지 검사한다.
 *
 * Implementation :
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::isNullOnlyCommand"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY("qdbAlter::isNullOnlyCommand"));

    qdVerifyColumn  * sVerifyColumn;
    idBool            sIsNullOnly = ID_TRUE;

    sVerifyColumn = aVerifyColumn;

    while ( sVerifyColumn != NULL )
    {
        if ( sVerifyColumn->command != QD_VERIFY_NULL_ONLY )
        {
            sIsNullOnly = ID_FALSE;
            break;
        }
        else
        {
            // Nothing to do.
        }

        sVerifyColumn = sVerifyColumn->next;
    }

    return sIsNullOnly;

#undef IDE_FN
}

IDE_RC qdbAlter::verifyColumnValue( qcStatement          * aStatement,
                                    qcmTableInfo         * aTableInfo,
                                    qdVerifyColumn       * aVerifyColumn,
                                    qdTblColModifyMethod * aMethod )
{
 /***********************************************************************
 *
 * Description : PROJ-1877
 *     alter table modify column의 execution시 table에서 column의 value를
 *     읽어 modify가 가능한지 검사한다.
 *
 * Implementation :
 *    1. Cursor의 초기화
 *    2. Cursor의 Open
 *    3. 한 레코드씩 읽으면서 값 검사
 *
 ***********************************************************************/

    qdVerifyColumn       * sVerifyColumn;
    scGRID                 sRid;
    smiCursorProperties    sCursorProperty;
    smiTableCursor         sCursor;
    smiFetchColumnList   * sFetchColumnList = NULL;
    const void           * sRow;
    SInt                   sStage = 0;
    UInt                   sTableType;
    mtcColumn            * sMtcColumn;
    UChar                * sVarRowBuffer = NULL;
    UInt                   sVarRowSize;
    UInt                   sVarRowOffset;
    UInt                   sRowSize;

    //-----------------------------------------
    // record를 읽기 위한 공간 마련
    //-----------------------------------------

    sTableType = aTableInfo->tableFlag & SMI_TABLE_TYPE_MASK;

    if ( sTableType == SMI_TABLE_DISK )
    {
        // Record Read를 위한 공간을 할당한다.
        IDE_TEST( qdbCommon::getDiskRowSize( aTableInfo,
                                             & sRowSize )
                  != IDE_SUCCESS );

        // To fix BUG-14820
        // Disk-variable 컬럼의 rid비교를 위해 초기화 해야 함.
        IDU_LIMITPOINT("qdbAlter::verifyColumnValue::malloc1");
        IDE_TEST( aStatement->qmxMem->cralloc( sRowSize,
                                               (void**) & sRow )
                  != IDE_SUCCESS );

        // fetch column list를 초기화한다.
        qdbCommon::initFetchColumnList( & sFetchColumnList );

        // fetch column list를 구성한다.
        sVerifyColumn = aVerifyColumn;

        while ( sVerifyColumn != NULL )
        {
            // verify column을 추가하면서 순서와 중복을 고려한다.
            IDE_TEST( qdbCommon::addFetchColumnList(
                          aStatement->qmxMem,
                          sVerifyColumn->column->basicInfo,
                          & sFetchColumnList )
                      != IDE_SUCCESS );

            sVerifyColumn = sVerifyColumn->next;
        }
    }
    else
    {
        // memory table or volatile table
        IDE_DASSERT( ( sTableType == SMI_TABLE_MEMORY ) ||
                     ( sTableType == SMI_TABLE_VOLATILE ) );

        // BUGBUG
        // verify column은 table column이 중복될 수 있다. 따라서
        // 중복되는 variable column에 대하여 각각의 row buffer를 가지게 되고
        // 각각에 대하여 값을 가져오게 된다.

        // Variable Column의 value 공간을 할당한다.
        sVerifyColumn = aVerifyColumn;
        sVarRowSize = 0;

        while ( sVerifyColumn != NULL )
        {
            // To fix BUG-24356
            // geometry에 대해서만 value buffer할당
            if ( ( (sVerifyColumn->column->basicInfo->column.flag & SMI_COLUMN_TYPE_MASK)
                    == SMI_COLUMN_TYPE_VARIABLE_LARGE ) &&
                 (sVerifyColumn->column->basicInfo->module->id == MTD_GEOMETRY_ID) )
            {
                sVarRowSize += smiGetVariableColumnSize( sTableType ) +
                    sVerifyColumn->column->basicInfo->column.size;
                sVarRowSize = idlOS::align( sVarRowSize, 8 );
            }
            else
            {
                // Nothing to do.
            }

            sVerifyColumn = sVerifyColumn->next;
        }

        if ( sVarRowSize > 0 )
        {
            IDU_LIMITPOINT("qdbAlter::verifyColumnValue::malloc2");
            IDE_TEST( aStatement->qmxMem->cralloc( sVarRowSize,
                                                   (void**) & sVarRowBuffer )
                      != IDE_SUCCESS );

            sVerifyColumn = aVerifyColumn;
            sVarRowOffset = 0;

            while ( sVerifyColumn != NULL )
            {
                // To fix BUG-24356
                // geometry에 대해서만 value buffer할당
                if ( ( (sVerifyColumn->column->basicInfo->column.flag & SMI_COLUMN_TYPE_MASK)
                        == SMI_COLUMN_TYPE_VARIABLE_LARGE ) &&
                     (sVerifyColumn->column->basicInfo->module->id == MTD_GEOMETRY_ID) )
                {
                    // sVerifyColumn의 basicInfo는 sTableColumn의 basicInfo이므로
                    // 복사해서 사용한다.
                    IDU_LIMITPOINT("qdbAlter::verifyColumnValue::malloc3");
                    IDE_TEST( aStatement->qmxMem->alloc( ID_SIZEOF(mtcColumn),
                                                         (void**) & sMtcColumn )
                              != IDE_SUCCESS );

                    idlOS::memcpy( sMtcColumn,
                                   sVerifyColumn->column->basicInfo,
                                   ID_SIZEOF(mtcColumn) );

                    sMtcColumn->column.value = (void*) (sVarRowBuffer + sVarRowOffset);
                    sVerifyColumn->column->basicInfo = sMtcColumn;

                    sVarRowOffset += smiGetVariableColumnSize( sTableType ) +
                        sVerifyColumn->column->basicInfo->column.size;
                    sVarRowOffset = idlOS::align( sVarRowOffset, 8 );
                }
                else
                {
                    // Nothing to do.
                }

                sVerifyColumn = sVerifyColumn->next;
            }
        }
        else
        {
            // Nothing to do.
        }
    }

    //-----------------------------------------
    // record를 읽어 컬럼의 값을 검사
    //-----------------------------------------

    // 검색을 위한 자료 구조의 초기화
    SMI_CURSOR_PROP_INIT_FOR_FULL_SCAN( &sCursorProperty, aStatement->mStatistics );

    sCursorProperty.mFetchColumnList = sFetchColumnList;

    sCursor.initialize();

    IDE_TEST(sCursor.open(
                 QC_SMI_STMT( aStatement ),
                 aTableInfo->tableHandle,
                 NULL,
                 smiGetRowSCN(aTableInfo->tableHandle),
                 NULL,
                 smiGetDefaultKeyRange(),
                 smiGetDefaultKeyRange(),
                 smiGetDefaultFilter(),
                 QCM_META_CURSOR_FLAG,
                 SMI_SELECT_CURSOR,
                 & sCursorProperty) != IDE_SUCCESS);
    sStage = 1;

    IDE_TEST(sCursor.beforeFirst() != IDE_SUCCESS);
    IDE_TEST(sCursor.readRow(&sRow, &sRid, SMI_FIND_NEXT) != IDE_SUCCESS);

    if ( isNullOnlyCommand( aVerifyColumn ) == ID_TRUE )
    {
        // verify command가 오직 QD_VERIFY_NULL_ONLY만 있다면
        // 단지 recreate가 필요한지만 판단되면 즉시 scan을 중단할 수 있다.

        while ( sRow != NULL )
        {
            IDE_TEST( verifyColumnValueNullOnlyForRow( aVerifyColumn,
                                                       sRow,
                                                       aMethod )
                      != IDE_SUCCESS );

            if ( *aMethod == QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE )
            {
                break;
            }
            else
            {
                // Nothing to do.
            }

            IDE_TEST( sCursor.readRow( &sRow, &sRid, SMI_FIND_NEXT )
                      != IDE_SUCCESS );
        }
    }
    else
    {
        // 나머지 verify command는 모든 record에 대하여 검사해야 하므로
        // full scan이 꼭 필요하다.

        while ( sRow != NULL )
        {
            IDE_TEST( verifyColumnValueForRow( aStatement,
                                               aVerifyColumn,
                                               sRow,
                                               aMethod )
                      != IDE_SUCCESS );

            IDE_TEST( sCursor.readRow( &sRow, &sRid, SMI_FIND_NEXT )
                      != IDE_SUCCESS );
        }
    }

    sStage = 0;

    IDE_TEST(sCursor.close() != IDE_SUCCESS);

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    if ( sStage == 1 )
    {
        sCursor.close();
    }

    return IDE_FAILURE;
}

IDE_RC qdbAlter::verifyColumnValueForRow( qcStatement          * aStatement,
                                          qdVerifyColumn       * aVerifyColumn,
                                          const void           * aRow,
                                          qdTblColModifyMethod * aMethod )
{
 /***********************************************************************
 *
 * Description : PROJ-1877
 *     column의 value 값을 row에서 읽어 검사한다.
 *
 * Implementation :
 *
 ***********************************************************************/

    qdVerifyColumn   * sVerifyColumn;
    mtcColumn        * sColumn;
    UInt               sSize;
    SInt               sPrecision;
    SInt               sScale;
    qcuSqlSourceInfo   sqlInfo;
    void             * sValueTemp;

    sVerifyColumn = aVerifyColumn;

    while ( sVerifyColumn != NULL )
    {
        sColumn = sVerifyColumn->column->basicInfo;

        switch ( sVerifyColumn->command )
        {
            case QD_VERIFY_NOT_NULL:

                if ( (sColumn->column.flag & SMI_COLUMN_TYPE_MASK)
                     == SMI_COLUMN_TYPE_LOB )
                {
                    // PROJ-1362
                    if ( smiIsNullLobColumn(aRow, & sColumn->column)
                         == ID_TRUE )
                    {
                        sqlInfo.setSourceInfo( aStatement,
                                               & sVerifyColumn->column->namePos );
                        IDE_RAISE( ERR_INVALID_NULL_VALUE );
                    }
                    else
                    {
                        // Nothing to do.
                    }
                }
                else
                {
                    // null이면 에러
                    sValueTemp = (void*)mtc::value( sColumn,
                                                    aRow,
                                                    MTD_OFFSET_USE );

                    if ( sColumn->module->isNull( sColumn,
                                                  sValueTemp ) == ID_TRUE )
                    {
                        sqlInfo.setSourceInfo( aStatement,
                                               & sVerifyColumn->column->namePos );
                        IDE_RAISE( ERR_INVALID_NULL_VALUE );
                    }
                    else
                    {
                        // Nothing to do.
                    }
                }
                break;

            case QD_VERIFY_NULL:

                // 모두 null인 경우만 실시간완성으로 수행한다.
                // null이 아닌 경우 에러
                IDE_DASSERT( (sColumn->column.flag & SMI_COLUMN_TYPE_MASK)
                             != SMI_COLUMN_TYPE_LOB );

                sValueTemp = (void*)mtc::value( sColumn,
                                                aRow,
                                                MTD_OFFSET_USE );

                if ( sColumn->module->isNull( sColumn,
                                              sValueTemp ) == ID_TRUE )
                {
                    // nothing to do
                }
                else
                {
                    sqlInfo.setSourceInfo( aStatement,
                                           & sVerifyColumn->column->namePos );
                    IDE_RAISE( ERR_INVALID_LENGTH );
                }
                break;

            case QD_VERIFY_NULL_ONLY:

                // 모두 null인 경우만 실시간완성으로 수행한다.
                IDE_DASSERT( (sColumn->column.flag & SMI_COLUMN_TYPE_MASK)
                             != SMI_COLUMN_TYPE_LOB );

                sValueTemp = (void*)mtc::value( sColumn,
                                                aRow,
                                                MTD_OFFSET_USE );

                if ( sColumn->module->isNull( sColumn,
                                              sValueTemp ) == ID_TRUE )
                {
                    // nothing to do
                }
                else
                {
                    // recreate
                    *aMethod = *aMethod > QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE ?
                        *aMethod : QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE;
                }
                break;

            case QD_VERIFY_NULL_OR_UNDER_SIZE:

                // 모두 null이거나 size보다 작거나 같은 경우만 실시간완성으로
                // 수행한다. 그렇지 않은 경우 에러
                IDE_DASSERT( (sColumn->column.flag & SMI_COLUMN_TYPE_MASK)
                             != SMI_COLUMN_TYPE_LOB );
                IDE_DASSERT( sVerifyColumn->size > 0 );
                IDE_DASSERT( sVerifyColumn->precision > 0 );

                sValueTemp = (void*)mtc::value( sColumn,
                                                aRow,
                                                MTD_OFFSET_USE );

                if ( sColumn->module->isNull( sColumn,
                                              sValueTemp ) == ID_TRUE )
                {
                    // null인 경우
                    // nothing to do
                }
                else
                {
                    sSize = sColumn->module->actualSize( sColumn,
                                                         sValueTemp );

                    IDE_TEST( sColumn->module->getPrecision( sColumn,
                                                             sValueTemp,
                                                             & sPrecision,
                                                             & sScale )
                              != IDE_SUCCESS );

                    if ( sVerifyColumn->scale == ID_SINT_MAX )
                    {
                        // precision만으로 length 조건을 판단한다.

                        if ( ( sSize <= sVerifyColumn->size ) &&
                             ( sPrecision <= sVerifyColumn->precision ) )
                        {
                            // length 조건을 만족하는 경우

                            // Nothing to do.
                        }
                        else
                        {
                            sqlInfo.setSourceInfo( aStatement,
                                                   & sVerifyColumn->column->namePos );
                            IDE_RAISE( ERR_INVALID_LENGTH );
                        }
                    }
                    else
                    {
                        // precision, scale로 length 조건을 판단한다.

                        if ( ( sSize <= sVerifyColumn->size ) &&
                             ( isEnlargingLengthForNumericType( sPrecision,
                                                                sScale,
                                                                sVerifyColumn->precision,
                                                                sVerifyColumn->scale )
                               == ID_TRUE ) )
                        {
                            // length 조건을 만족하는 경우

                            // Nothing to do.
                        }
                        else
                        {
                            sqlInfo.setSourceInfo( aStatement,
                                                   & sVerifyColumn->column->namePos );
                            IDE_RAISE( ERR_INVALID_LENGTH );
                        }
                    }
                }
                break;

            case QD_VERIFY_NULL_OR_EXACT_OR_UNDER_SIZE:

                // 모두 null이거나 size가 같은 경우 실시간완성으로 수행한다.
                // 모두 null이거나 size보다 작은 경우는 비실시간으로 수행한다.
                // 그렇지 않은 경우 에러
                IDE_DASSERT( (sColumn->column.flag & SMI_COLUMN_TYPE_MASK)
                             != SMI_COLUMN_TYPE_LOB );
                IDE_DASSERT( sVerifyColumn->size > 0 );
                IDE_DASSERT( sVerifyColumn->precision > 0 );

                sValueTemp = (void*)mtc::value( sColumn,
                                                aRow,
                                                MTD_OFFSET_USE );

                if ( sColumn->module->isNull( sColumn,
                                              sValueTemp ) == ID_TRUE )
                {
                    // nothing to do
                }
                else
                {
                    sSize = sColumn->module->actualSize( sColumn,
                                                         sValueTemp );

                    IDE_TEST( sColumn->module->getPrecision( sColumn,
                                                             sValueTemp,
                                                             & sPrecision,
                                                             & sScale )
                              != IDE_SUCCESS );

                    if ( sVerifyColumn->scale == ID_SINT_MAX )
                    {
                        // precision만으로 length 조건을 판단한다.

                        if ( ( sSize <= sVerifyColumn->size ) &&
                             ( sPrecision == sVerifyColumn->precision ) )
                        {
                            // length가 동일한 경우
                            // nothing to do
                        }
                        else
                        {
                            if ( ( sSize <= sVerifyColumn->size ) &&
                                 ( sPrecision <= sVerifyColumn->precision ) )
                            {
                                // length 조건을 만족하는 경우

                                // recreate
                                *aMethod = *aMethod > QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE ?
                                    *aMethod : QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE;
                            }
                            else
                            {
                                sqlInfo.setSourceInfo( aStatement,
                                                       & sVerifyColumn->column->namePos );
                                IDE_RAISE( ERR_INVALID_LENGTH );
                            }
                        }
                    }
                    else
                    {
                        // precision, scale로 length 조건을 판단한다.

                        if ( ( sSize <= sVerifyColumn->size ) &&
                             ( sPrecision == sVerifyColumn->precision ) &&
                             ( sScale == sVerifyColumn->scale ) )
                        {
                            // length가 동일한 경우

                            // Nothing to do.
                        }
                        else
                        {
                            if ( ( sSize <= sVerifyColumn->size ) &&
                                 ( isEnlargingLengthForNumericType( sPrecision,
                                                                    sScale,
                                                                    sVerifyColumn->precision,
                                                                    sVerifyColumn->scale )
                                   == ID_TRUE ) )
                            {
                                // length 조건을 만족하는 경우

                                // recreate
                                *aMethod = *aMethod > QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE ?
                                    *aMethod : QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE;
                            }
                            else
                            {
                                sqlInfo.setSourceInfo( aStatement,
                                                       & sVerifyColumn->column->namePos );
                                IDE_RAISE( ERR_INVALID_LENGTH );
                            }
                        }
                    }
                }
                break;

            default:
                IDE_DASSERT( 0 );
                break;
        }

        sVerifyColumn = sVerifyColumn->next;
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_INVALID_NULL_VALUE );
    {
        (void)sqlInfo.init(aStatement->qmeMem);
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_INVALID_NULL_VALUE,
                                sqlInfo.getErrMessage()));
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION( ERR_INVALID_LENGTH );
    {
        (void)sqlInfo.init(aStatement->qmeMem);
        IDE_SET(ideSetErrorCode(qpERR_ABORT_QDB_INVALID_LENGTH,
                                sqlInfo.getErrMessage()));
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::verifyColumnValueNullOnlyForRow(
    qdVerifyColumn       * aVerifyColumn,
    const void           * aRow,
    qdTblColModifyMethod * aMethod )
{
 /***********************************************************************
 *
 * Description : PROJ-1877
 *     column의 value 값을 row에서 읽어 검사한다.
 *
 * Implementation :
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::verifyColumnValueNullOnlyForRow"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY("qdbAlter::verifyColumnValueNullOnlyForRow"));

    qdVerifyColumn   * sVerifyColumn;
    mtcColumn        * sColumn;
    void             * sValueTemp;

    sVerifyColumn = aVerifyColumn;

    while ( sVerifyColumn != NULL )
    {
        sColumn = sVerifyColumn->column->basicInfo;

        switch ( sVerifyColumn->command )
        {
            case QD_VERIFY_NULL_ONLY:

                // 모두 null인 경우만 실시간완성으로 수행한다.
                IDE_DASSERT( (sColumn->column.flag & SMI_COLUMN_TYPE_MASK)
                             != SMI_COLUMN_TYPE_LOB );

                sValueTemp = (void*)mtc::value( sColumn,
                                                aRow,
                                                MTD_OFFSET_USE );

                if ( sColumn->module->isNull( sColumn,
                                              sValueTemp ) == ID_TRUE )
                {
                    // Nothing to do.
                }
                else
                {
                    // recreate
                    *aMethod = *aMethod > QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE ?
                        *aMethod : QD_TBL_COL_MODIFY_METHOD_RECREATE_TABLE;
                }
                break;


            default:
                IDE_DASSERT( 0 );
                break;
        }

        sVerifyColumn = sVerifyColumn->next;
    }

    return IDE_SUCCESS;

#undef IDE_FN
}

idBool qdbAlter::isEnlargingLengthForNumericType( SInt aSrcPrecision,
                                                  SInt aSrcScale,
                                                  SInt aDestPrecision,
                                                  SInt aDestScale )
{
 /***********************************************************************
 *
 * Description : PROJ-1877
 *    numeric type의 length 확대인지 검사
 *
 *    예제)
 *    numeric(10,2) -> numeric(10,4)는 축소
 *    numeric(10,2) -> numeric(12,4)는 확대
 *    numeric(1,2) -> numeric(2,2)는 확대
 *    numeric(1,2) -> numeric(2,3)은 확대
 *    numeric(1,-10) -> numeric(2,-10)은 확대
 *    numeric(1,-10) -> numeric(2,-9)은 확대
 *
 * Implementation :
 *    1. src와 dest의 numeric type이 표현할 수 있는 upper bound와 lower bound를 계산
 *    2. dest가 src의 bound를 포함하면 length의 확대
 *    3. bound가 동일한 경우도 length 확대로 간주
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::isEnlargingLengthForNumericType"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY("qdbAlter::isEnlargingLengthForNumericType"));

    idBool  sEnlarge;
    SInt    sSrcUpper;
    SInt    sSrcLower;
    SInt    sDestUpper;
    SInt    sDestLower;

    sSrcUpper = aSrcPrecision - aSrcScale;
    sSrcLower = -aSrcScale;

    sDestUpper = aDestPrecision - aDestScale;
    sDestLower = -aDestScale;

    if ( (sSrcUpper <= sDestUpper) && (sSrcLower >= sDestLower) )
    {
        sEnlarge = ID_TRUE;
    }
    else
    {
        sEnlarge = ID_FALSE;
    }

    return sEnlarge;

#undef IDE_FN
}

IDE_RC qdbAlter::isDataLossConversion( UInt     aFromTypeId,
                                       UInt     aToTypeId,
                                       idBool * aIsDataLoss )
{
 /***********************************************************************
 *
 * Description : PROJ-1877
 *    data loss가 발생할 수 있는 type conversion인지 판단한다.
 *
 * Implementation :
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::isDataLossConversion"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY("qdbAlter::isDataLossConversion"));

    static UInt sTypeMap[QDB_CONVERT_MATRIX_SIZE] = {
        MTD_NCHAR_ID,
        MTD_NVARCHAR_ID,
        MTD_CHAR_ID,
        MTD_VARCHAR_ID,
        MTD_CLOB_ID,
        MTD_BIGINT_ID,
        MTD_DOUBLE_ID,
        MTD_FLOAT_ID,
        MTD_INTEGER_ID,
        MTD_NUMERIC_ID,
        MTD_REAL_ID,
        MTD_SMALLINT_ID,
        MTD_DATE_ID,
        MTD_BLOB_ID,
        MTD_BYTE_ID,
        MTD_NIBBLE_ID,
        MTD_BIT_ID,
        MTD_VARBIT_ID,
        MTD_GEOMETRY_ID
    };

    static UChar sLosslessConvertMap[QDB_CONVERT_MATRIX_SIZE][QDB_CONVERT_MATRIX_SIZE] = {
                                                                       // [From]
        {  0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },  // nchar
        {  1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },  // nvarchar
        {  1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },  // char
        {  1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },  // varchar
        {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },  // clob
        {  1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },  // bigint
        {  1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },  // double
        {  1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },  // float
        {  1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },  // integer
        {  1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },  // numeric
        {  1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },  // real
        {  1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },  // smallint
        {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },  // date
        {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },  // blob
        {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },  // byte
        {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },  // nibble
        {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0 },  // bit
        {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },  // varbit
        {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }   // geomerty
        // [To]
        // n  n  c  v  c  b  d  f  i  n  r  s  d  b  b  n  b  v  g
        // c  v  h  a  l  i  o  l  n  u  e  m  a  l  y  i  i  a  e
        // h  a  a  r  o  g  u  o  t  m  a  a  t  o  t  b  t  r  o
        // a  r  r  c  b  i  b  a  e  e  l  l  e  b  e  b     b  m
        // r  c     h     n  l  t  g  r     l           i     i  e
        //    h     a     t  e     r  i     i           t     t  t
        //    a     r                 c     n                    r
        //    r                             t                    y
    };

    SInt    sFromTypeIdx = -1;
    SInt    sToTypeIdx   = -1;
    UInt    i;

    IDE_DASSERT( aFromTypeId != aToTypeId );

    for ( i = 0; i < QDB_CONVERT_MATRIX_SIZE; i++ )
    {
        if ( sTypeMap[i] == aFromTypeId )
        {
            sFromTypeIdx = i;
        }
        else
        {
            // Nothing to do.
        }

        if ( sTypeMap[i] == aToTypeId )
        {
            sToTypeIdx = i;
        }
        else
        {
            // Nothing to do.
        }

        if ( (sFromTypeIdx >= 0) && (sToTypeIdx >= 0) )
        {
            break;
        }
        else
        {
            // Nothing to do.
        }
    }

    // 반드시 찾아야 한다.
    IDE_TEST_RAISE( (sFromTypeIdx < 0) || (sToTypeIdx < 0),
                    ERR_INVALID_TYPE );

    // 1이면 손실이 없다.
    if ( sLosslessConvertMap[sFromTypeIdx][sToTypeIdx] == 1 )
    {
        * aIsDataLoss = ID_FALSE;
    }
    else
    {
        * aIsDataLoss = ID_TRUE;
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_INVALID_TYPE )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QMC_UNEXPECTED_ERROR,
                                  "qdbAlter::isDataLossConversion",
                                  "Invalid type" ));
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::alterMetaForMemory( qcStatement       * aStatement,
                                     qdTableParseTree  * aParseTree,
                                     qcmTableInfo     ** aNewTableInfo,
                                     qcmTableInfo     ** aNewPartInfo )
{
 /***********************************************************************
 *
 * Description : PROJ-1877
 *     meta 변경만으로 alter table modify column 기능을 수행한다.
 *
 * Implementation :
 *     - (not) null constraint 변경
 *     - default value 변경
 *
 *     memory table은 type 변경으로 module이 달리지고 module의 align이
 *     달리지므로 컬럼 순서가 바뀔 수 있다. 또한 length 변경은
 *     size를 변경시키므로 전체 컬럼의 offset을 변경시킬 수 있으므로
 *     결국 type, length 변경은 메타 변경만으로는 불가능하다.
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::alterMetaForMemory"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY("qdbAlter::alterMetaForMemory"));

    qcmTableInfo          * sOldTableInfo;
    qcmColumn             * sTableColumn;
    qcmColumn             * sModifyColumn;
    mtcColumn             * sMtcColumn;
    SChar                   sDefaultValueStrNull[1] = "";
    SChar                 * sDefaultValueStr;
    void                  * sTableHandle;
    smSCN                   sSCN;

    // PROJ-1579 NCHAR
    UInt                    sBufferSize = 0;
    UInt                    sAddSize = 0;
    SChar                 * sDefValBuffer = NULL;
    qcNamePosList         * sTempNamePosList = NULL;
    qcNamePosition          sNamePos;
    
    idBool                  sIsPartitioned;
    qcmPartitionInfoList  * sPartInfoList;
    qcmTableInfo          * sPartInfo;
    UInt                    sPartCount;

    sOldTableInfo = aParseTree->tableInfo;
    sTableColumn = aParseTree->columns;
    sModifyColumn = aParseTree->modifyColumns;

    while ( sTableColumn != NULL )
    {
        IDE_DASSERT( sModifyColumn != NULL );

        //-----------------------------------------
        // default value 변경
        //-----------------------------------------

        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_DEFAULT_MASK)
             == QCM_COLUMN_MODIFY_DEFAULT_TRUE )
        {
            sMtcColumn = QTC_TMPL_COLUMN( QC_PRIVATE_TMPLATE(aStatement),
                                          sModifyColumn->defaultValue );

            if ( sMtcColumn->module->id == MTD_NULL_ID )
            {
                // 'i1 default NULL'은 'i1 drop default'를 의미한다.
                sDefaultValueStr = sDefaultValueStrNull;
            }
            else
            {
                // PROJ-1579 NCHAR
                // 메타테이블에 저장하기 위해 스트링을 변환하기 전에
                // N 타입이 있는 경우 U 타입으로 변환한다.
                for( sTempNamePosList = sModifyColumn->ncharLiteralPos;
                     sTempNamePosList != NULL;
                     sTempNamePosList = sTempNamePosList->next )
                {
                    sNamePos = sTempNamePosList->namePos;

                    // U 타입으로 변환하면서 늘어나는 사이즈 계산
                    // N'안' => U'\C548' 으로 변환된다면
                    // '안'의 캐릭터 셋이 KSC5601이라고 가정했을 때,
                    // single-quote안의 문자는 2 byte -> 5byte로 변경된다.
                    // 즉, 1.5배가 늘어나는 것이다.
                    //(전체 사이즈가 아니라 증가하는 사이즈만 계산하는 것임)
                    // 하지만, 어떤 예외적인 캐릭터 셋이 들어올지 모르므로
                    // * 2로 충분히 잡는다.
                    sAddSize += (sNamePos.size - 3) * 2;
                }

                if ( sModifyColumn->ncharLiteralPos != NULL )
                {
                    sBufferSize = sModifyColumn->defaultValue->position.size +
                        sAddSize;

                    IDU_LIMITPOINT("qdbAlter::alterMetaForMemory::malloc");
                    IDE_TEST(STRUCT_ALLOC_WITH_SIZE(aStatement->qmxMem,
                                                    SChar,
                                                    sBufferSize,
                                                    & sDefValBuffer)
                             != IDE_SUCCESS);

                    IDE_TEST( qdbCommon::convertToUTypeString(
                                  aStatement,
                                  sModifyColumn->defaultValue->position.offset,
                                  sModifyColumn->defaultValue->position.size,
                                  sModifyColumn->ncharLiteralPos,
                                  sDefValBuffer,
                                  sBufferSize )
                              != IDE_SUCCESS );

                    IDE_TEST( qdbCommon::getStrForMeta(
                                  aStatement,
                                  sDefValBuffer,
                                  idlOS::strlen( sDefValBuffer ),
                                  & sDefaultValueStr)
                              != IDE_SUCCESS );
                }
                else
                {
                    IDE_TEST( qdbCommon::getStrForMeta(
                                  aStatement,
                                  sModifyColumn->defaultValue->position.stmtText+
                                  sModifyColumn->defaultValue->position.offset,
                                  sModifyColumn->defaultValue->position.size,
                                  & sDefaultValueStr )
                              != IDE_SUCCESS );
                }
            }

            sModifyColumn->defaultValueStr = (UChar*)sDefaultValueStr;

            // update column default value
            IDE_TEST( updateColumnSpecDefault( aStatement,
                                               sModifyColumn )
                      != IDE_SUCCESS);
        }
        else
        {
            // Nothing to do.
        }

        //-----------------------------------------
        // (not) null 변경
        //-----------------------------------------

        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_NULLABLE_MASK)
             == QCM_COLUMN_MODIFY_NULLABLE_NULL )
        {
            // set nullable flag to true.
            IDE_TEST( qdbCommon::updateColumnSpecNull( aStatement,
                                                       sModifyColumn,
                                                       ID_TRUE )
                      != IDE_SUCCESS );

            // not null constraint 삭제
            IDE_TEST( deleteNotNullConstraint(
                          aStatement,
                          sOldTableInfo,
                          sModifyColumn->basicInfo->column.id )
                      != IDE_SUCCESS );

            // smiTable::modifyTableInfo로 table 정보 변경
            // partitioned table에 대해서는 함수 안에서 고려하고 있다.
            IDE_TEST( qdbCommon::makeColumnNullable(
                          aStatement,
                          sOldTableInfo,
                          sModifyColumn->basicInfo->column.id )
                      != IDE_SUCCESS );
        }
        else if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_NULLABLE_MASK)
                  == QCM_COLUMN_MODIFY_NULLABLE_NOTNULL )
        {
            // set nullable flag to false.
            IDE_TEST( qdbCommon::updateColumnSpecNull( aStatement,
                                                       sModifyColumn,
                                                       ID_FALSE )
                      != IDE_SUCCESS );

            // not null constraint 추가
            // 여러 개의 not null constraint에서 modify column에 해당하는
            // constraint를 찾아서 추가한다.
            IDE_TEST( insertNotNullConstraint( aStatement,
                                               aParseTree,
                                               sModifyColumn )
                      != IDE_SUCCESS );

            // PROJ-1502 PARTITIONED DISK TABLE
            // PROJ-2334 PMT
            if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
            {
                sPartInfoList = aParseTree->partTable->partInfoList;
                sIsPartitioned = ID_TRUE;
            }
            else
            {
                sPartInfoList = NULL;
                sIsPartitioned = ID_FALSE;
            }

            // smiTable::modifyTableInfo로 table 정보 변경
            // partitioned table에 대해서는 함수 안에서 고려하고 있다.
            IDE_TEST( qdbCommon::makeColumnNotNull(
                          aStatement,
                          sOldTableInfo->tableHandle,
                          sOldTableInfo->maxrows,
                          sPartInfoList,
                          sIsPartitioned,
                          sModifyColumn->basicInfo->column.id )
                      != IDE_SUCCESS );
        }
        else
        {
            // Nothing to do.
        }

        //-----------------------------------------
        // type, length 변경
        //-----------------------------------------

        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_COLUMN_OPTION_MASK)
             == QCM_COLUMN_MODIFY_COLUMN_OPTION_TRUE )
        {
            // column option을 변경한 경우

            // alter meta만으로 ddl을 수행할 수 없다.
            IDE_DASSERT( 0 );
        }
        else
        {
            // 순수 type, length 변경

            // Nothing to do.
        }

        sTableColumn = sTableColumn->next;
        sModifyColumn = sModifyColumn->next;
    }

    //-----------------------------------------
    // table spec 변경
    //-----------------------------------------

    // fix BUG-14394
    IDE_TEST( qdbCommon::updateTableSpecFromMeta(
                  aStatement,
                  aParseTree->userName,
                  aParseTree->tableName,
                  sOldTableInfo->tableID,
                  smiGetTableId( sOldTableInfo->tableHandle ),
                  sOldTableInfo->columnCount,
                  sOldTableInfo->parallelDegree )
              != IDE_SUCCESS );

    IDE_TEST( qcm::touchTable( QC_SMI_STMT( aStatement ),
                               sOldTableInfo->tableID,
                               SMI_TBSLV_DDL_DML )
              != IDE_SUCCESS);

    //-----------------------------------------
    // cached meta 재생성
    //-----------------------------------------

    IDE_TEST( qcm::makeAndSetQcmTableInfo( QC_SMI_STMT( aStatement ),
                                           sOldTableInfo->tableID,
                                           smiGetTableId( sOldTableInfo->tableHandle ) )
              != IDE_SUCCESS );

    IDE_TEST( qcm::getTableInfoByID( aStatement,
                                     sOldTableInfo->tableID,
                                     aNewTableInfo,
                                     & sSCN,
                                     & sTableHandle )
              != IDE_SUCCESS);

    // PROJ-1502 PARTITIONED DISK TABLE
    // PROJ-2334 PMT
    if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST( qcmPartition::touchPartitionInfoList( QC_SMI_STMT( aStatement ),
                                                        aParseTree->partTable->partInfoList )
                  != IDE_SUCCESS );

        IDE_DASSERT( aNewPartInfo != NULL );

        sPartCount = 0;

        for ( sPartInfoList = aParseTree->partTable->partInfoList;
              sPartInfoList != NULL;
              sPartInfoList = sPartInfoList->next )
        {
            sPartInfo = sPartInfoList->partitionInfo;

            IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                          QC_SMI_STMT( aStatement ),
                          sPartInfo->partitionID,
                          smiGetTableId( sPartInfo->tableHandle ),
                          *aNewTableInfo,
                          NULL )
                      != IDE_SUCCESS );

            IDE_TEST( qcmPartition::getPartitionInfoByID(
                          aStatement,
                          sPartInfo->partitionID,
                          & aNewPartInfo[sPartCount],
                          & sSCN,
                          & sTableHandle )
                      != IDE_SUCCESS );

            sPartCount++;
        }
    }
    else
    {
        // Nothing to do.
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    // qdbAlter::executeModifyCol()에서 Meta Cache 메모리를 해제한다.

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::alterMetaForDisk( qcStatement       * aStatement,
                                   qdTableParseTree  * aParseTree,
                                   qcmTableInfo     ** aNewTableInfo,
                                   qcmTableInfo     ** aNewPartInfo )
{
 /***********************************************************************
 *
 * Description : PROJ-1877
 *     meta 변경만으로 alter table modify column 기능을 수행한다.
 *
 * Implementation :
 *     - (not) null constraint 변경
 *     - default value 변경
 *     - type, length 변경
 *
 *       type과 length 변경은 table 전체 column의 offset, size를
 *       변경시키지만 column의 id, 순서는 변경하지 않는다.
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::alterMetaForDisk"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY("qdbAlter::alterMetaForDisk"));

    qcmTableInfo          * sOldTableInfo;
    idBool                  sIsPartitioned;
    qcmPartitionInfoList  * sPartInfoList;
    qcmTableInfo          * sPartInfo;
    UInt                    sPartCount;
    smSCN                   sSCN;
    void                  * sTableHandle;
    qcmColumn             * sTableColumn;
    qcmColumn             * sModifyColumn;
    qcmColumn             * sNewColumn;
    mtcColumn             * sNewMtcColumn;
    qcmColumn             * sNewTableColumn;
    mtcColumn             * sNewTableMtcColumn;
    mtcColumn             * sMtcColumn;
    UInt                    sColumnCount;
    UInt                    sCurrentOffset;
    UInt                    i;

    sOldTableInfo = aParseTree->tableInfo;

    //-----------------------------------------
    // new table column 구성
    //-----------------------------------------

    // new table column 생성
    sColumnCount = sOldTableInfo->columnCount;

    IDU_LIMITPOINT("qdbAlter::alterMetaForDisk::malloc1");
    IDE_TEST( aStatement->qmxMem->alloc( ID_SIZEOF(qcmColumn) * sColumnCount,
                                         (void**) &sNewTableColumn )
              != IDE_SUCCESS );

    IDU_LIMITPOINT("qdbAlter::alterMetaForDisk::malloc2");
    IDE_TEST( aStatement->qmxMem->alloc( ID_SIZEOF(mtcColumn) * sColumnCount,
                                         (void**) &sNewTableMtcColumn)
              != IDE_SUCCESS );

    // new table column 초기화
    idlOS::memcpy( (void*) sNewTableColumn,
                   (void*) sOldTableInfo->columns,
                   ID_SIZEOF(qcmColumn) * sColumnCount );

    for ( i = 0; i < sColumnCount; i++ )
    {
        idlOS::memcpy( (void*) &sNewTableMtcColumn[i],
                       (void*) sNewTableColumn[i].basicInfo,
                       ID_SIZEOF(mtcColumn) );

        sNewTableColumn[i].basicInfo = &sNewTableMtcColumn[i];
    }

    // new table column 구성
    sTableColumn = aParseTree->columns;
    sModifyColumn = aParseTree->modifyColumns;

    while ( sTableColumn != NULL )
    {
        IDE_DASSERT( sModifyColumn != NULL );

        // sModifyColumn에 해당하는 sNewTableColumn을 찾는다.
        sNewColumn = NULL;
        sNewMtcColumn = NULL;

        for ( i = 0; i < sColumnCount; i++ )
        {
            // sModifyColumn->basicInfo->column.id는 설정되었으므로
            // column.id로 비교한다.
            if ( sModifyColumn->basicInfo->column.id ==
                 sNewTableColumn[i].basicInfo->column.id )
            {
                sNewColumn = & sNewTableColumn[i];
                sNewMtcColumn = & sNewTableMtcColumn[i];
                break;
            }
            else
            {
                // Nothing to do.
            }
        }

        // 반드시 존재한다.
        IDE_ASSERT( sNewColumn != NULL );
        IDE_ASSERT( sNewMtcColumn != NULL );

        // sNewTableColumn에 sModifyColumn을 복사한다.
        // (sNewColumn->next의 정보는 후에 보정한다.)
        idlOS::memcpy( (void*) sNewColumn,
                       (void*) sModifyColumn,
                       ID_SIZEOF(qcmColumn) );

        idlOS::memcpy( (void*) sNewMtcColumn,
                       (void*) sModifyColumn->basicInfo,
                       ID_SIZEOF(mtcColumn) );

        // tableColumn의 정보를 보존한다.
        // not null flag
        sNewColumn->basicInfo->flag &= ~MTC_COLUMN_NOTNULL_MASK;
        sNewColumn->basicInfo->flag |=
            (sTableColumn->basicInfo->flag & MTC_COLUMN_NOTNULL_MASK);
        // default value
        sNewColumn->defaultValueStr = sTableColumn->defaultValueStr;
        /* PROJ-1090 Function-based Index */
        sNewColumn->flag &= ~QCM_COLUMN_HIDDEN_COLUMN_MASK;
        sNewColumn->flag |= (sTableColumn->flag & QCM_COLUMN_HIDDEN_COLUMN_MASK);

        //-----------------------------------------
        // default value 변경
        //-----------------------------------------

        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_DEFAULT_MASK)
             == QCM_COLUMN_MODIFY_DEFAULT_TRUE )
        {
            sMtcColumn = QTC_TMPL_COLUMN( QC_PRIVATE_TMPLATE(aStatement),
                                          sNewColumn->defaultValue );

            if ( sMtcColumn->module->id == MTD_NULL_ID )
            {
                // 'i1 default NULL'은 'i1 drop default'를 의미한다.
                sNewColumn->defaultValue = NULL;
            }
            else
            {
                // Nothing to do.
            }

            // 기존의 default value를 초기화한다.
            sNewColumn->defaultValueStr = NULL;
        }
        else
        {
            // Nothing to do.
        }

        //-----------------------------------------
        // (not) null 변경
        //-----------------------------------------

        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_NULLABLE_MASK)
             == QCM_COLUMN_MODIFY_NULLABLE_NULL )
        {
            // not null constraint 삭제
            IDE_TEST( deleteNotNullConstraint(
                          aStatement,
                          sOldTableInfo,
                          sNewColumn->basicInfo->column.id )
                      != IDE_SUCCESS );

            // smiTable::modifyTableInfo로 table 정보 변경
            // partitioned table에 대해서는 함수 안에서 고려하고 있다.
            IDE_TEST( qdbCommon::makeColumnNullable(
                          aStatement,
                          sOldTableInfo,
                          sNewColumn->basicInfo->column.id )
                      != IDE_SUCCESS );

            // nullable flag를 설정한다.
            sNewColumn->basicInfo->flag &= ~MTC_COLUMN_NOTNULL_MASK;
            sNewColumn->basicInfo->flag |= MTC_COLUMN_NOTNULL_FALSE;
        }
        else if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_NULLABLE_MASK)
                  == QCM_COLUMN_MODIFY_NULLABLE_NOTNULL )
        {
            // not null constraint 추가
            // 여러 개의 not null constraint에서 modify column에 해당하는
            // constraint를 찾아서 추가한다.
            IDE_TEST( insertNotNullConstraint( aStatement,
                                               aParseTree,
                                               sNewColumn )
                      != IDE_SUCCESS );

            // PROJ-1502 PARTITIONED DISK TABLE
            if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
            {
                sPartInfoList = aParseTree->partTable->partInfoList;
                sIsPartitioned = ID_TRUE;
            }
            else
            {
                sPartInfoList = NULL;
                sIsPartitioned = ID_FALSE;
            }

            // smiTable::modifyTableInfo로 table 정보 변경
            // partitioned table에 대해서는 함수 안에서 고려하고 있다.
            IDE_TEST( qdbCommon::makeColumnNotNull(
                          aStatement,
                          sOldTableInfo->tableHandle,
                          sOldTableInfo->maxrows,
                          sPartInfoList,
                          sIsPartitioned,
                          sNewColumn->basicInfo->column.id )
                      != IDE_SUCCESS );

            // not null flag를 설정한다.
            sNewColumn->basicInfo->flag &= ~MTC_COLUMN_NOTNULL_MASK;
            sNewColumn->basicInfo->flag |= MTC_COLUMN_NOTNULL_TRUE;
        }
        else
        {
            // Nothing to do.
        }

        //-----------------------------------------
        // type, length 변경
        //-----------------------------------------

        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_COLUMN_OPTION_MASK)
             == QCM_COLUMN_MODIFY_COLUMN_OPTION_TRUE )
        {
            // column option을 변경한 경우

            // Nothing to do.
        }
        else
        {
            // 순수 type, length 변경

            // Nothing to do.
        }

        sTableColumn = sTableColumn->next;
        sModifyColumn = sModifyColumn->next;
    }

    //-----------------------------------------
    // modify 대상이 아닌 기존 컬럼에 대한 default value 정보 설정
    //-----------------------------------------

    for ( i = 0; i < sColumnCount; i++ )
    {
        // fix BUG-14204
        if ( sNewTableColumn[i].defaultValueStr != NULL )
        {
            // old column의 default value를 이용하기 위해
            // dummy qtcNode를 붙인다.
            IDU_LIMITPOINT("qdbAlter::alterMetaForDisk::malloc3");
            IDE_TEST( aStatement->qmxMem->alloc(
                          ID_SIZEOF(qtcNode),
                          (void**) & sNewTableColumn[i].defaultValue )
                      != IDE_SUCCESS );

            // PROJ-1579 NCHAR
            // old column의 default value는 이미 메타 테이블에 저장되어 있음
            sNewTableColumn[i].ncharLiteralPos = NULL;
        }
        else
        {
            // Nothing to do.
        }
    }

    //-----------------------------------------
    // sNewTableColumn의 next를 연결한다.
    //-----------------------------------------

    for ( i = 0; i < sColumnCount - 1; i++ )
    {
        sNewTableColumn[i].next = & sNewTableColumn[i + 1];
    }
    sNewTableColumn[i].next = NULL;

    //-----------------------------------------
    // new table column offset 조정
    //-----------------------------------------

    IDE_DASSERT( smiTableSpace::isDiskTableSpaceType( sOldTableInfo->TBSType )
                 == ID_TRUE );

    // disk table이므로 record header size를 고려하지 않아 offset은 0부터 시작한다.
    sCurrentOffset = 0;

    // disk table의 schema로 memory table로 생성가능한지만을 검사하는 것으로
    // column id가 변경되지는 않는다.
    IDE_TEST( qdbCommon::setColListOffset( aStatement->qmxMem,
                                           sNewTableColumn,
                                           sCurrentOffset )
              != IDE_SUCCESS );

    //-----------------------------------------
    // column spec 변경
    //-----------------------------------------

    // delete invalidated column spec from meta.
    IDE_TEST( deleteColumnSpecFromMeta( aStatement,
                                        sOldTableInfo->tableID )
              != IDE_SUCCESS );

    // insert new column spec into meta.
    IDE_TEST( qdbCommon::insertColumnSpecIntoMeta( aStatement,
                                                   aParseTree->userID,
                                                   sOldTableInfo->tableID,
                                                   sNewTableColumn,
                                                   ID_FALSE /* is queue */)
              != IDE_SUCCESS );

    // smiTable::modifyTableInfo로 table 정보 변경
    // partitioned table에 대해서는 함수 안에서 고려하고 있다.
    IDE_TEST( qdbCommon::makeColumnNewType( aStatement,
                                            sOldTableInfo,
                                            sNewTableColumn )
              != IDE_SUCCESS );

    //-----------------------------------------
    // table spec 변경
    //-----------------------------------------

    // fix BUG-14394
    IDE_TEST( qdbCommon::updateTableSpecFromMeta(
                  aStatement,
                  aParseTree->userName,
                  aParseTree->tableName,
                  sOldTableInfo->tableID,
                  smiGetTableId( sOldTableInfo->tableHandle ),
                  sOldTableInfo->columnCount,
                  sOldTableInfo->parallelDegree )
              != IDE_SUCCESS );

    IDE_TEST( qcm::touchTable( QC_SMI_STMT( aStatement ),
                               sOldTableInfo->tableID,
                               SMI_TBSLV_DDL_DML )
              != IDE_SUCCESS);

    //-----------------------------------------
    // cached meta 재생성
    //-----------------------------------------

    IDE_TEST( qcm::makeAndSetQcmTableInfo( QC_SMI_STMT( aStatement ),
                                           sOldTableInfo->tableID,
                                           smiGetTableId( sOldTableInfo->tableHandle ) )
              != IDE_SUCCESS );

    IDE_TEST( qcm::getTableInfoByID( aStatement,
                                     sOldTableInfo->tableID,
                                     aNewTableInfo,
                                     & sSCN,
                                     & sTableHandle )
              != IDE_SUCCESS);

    // PROJ-1502 PARTITIONED DISK TABLE
    if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST( qcmPartition::touchPartitionInfoList( QC_SMI_STMT( aStatement ),
                                                        aParseTree->partTable->partInfoList )
                  != IDE_SUCCESS );

        IDE_DASSERT( aNewPartInfo != NULL );

        sPartCount = 0;

        for( sPartInfoList = aParseTree->partTable->partInfoList;
             sPartInfoList != NULL;
             sPartInfoList = sPartInfoList->next )
        {
            sPartInfo = sPartInfoList->partitionInfo;

            IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                          QC_SMI_STMT( aStatement ),
                          sPartInfo->partitionID,
                          smiGetTableId( sPartInfo->tableHandle ),
                          *aNewTableInfo,
                          NULL )
                      != IDE_SUCCESS );

            IDE_TEST( qcmPartition::getPartitionInfoByID(
                          aStatement,
                          sPartInfo->partitionID,
                          & aNewPartInfo[sPartCount],
                          & sSCN,
                          & sTableHandle )
                      != IDE_SUCCESS );

            sPartCount++;
        }
    }
    else
    {
        // Nothing to do.
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    // qdbAlter::executeModifyCol()에서 Meta Cache 메모리를 해제한다.

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::recreateTableForMemory( qcStatement       * aStatement,
                                         qdTableParseTree  * aParseTree,
                                         qcmTableInfo     ** aNewTableInfo,
                                         qcmTableInfo     ** aNewPartInfo )
{
 /***********************************************************************
 *
 * Description : PROJ-1877
 *     table 재생성과 table의 하위 객체(index등) 재생성으로
 *     alter table modify column 기능을 수행한다.
 *
 * Implementation :
 *     1. memory table에 대한 re-create table.
 *     2. memory partitioned table에 대한 re-create table.
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::recreateTableForMemory"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY("qdbAlter::recreateTableForMemory"));

    qcmTableInfo          * sNewTableInfo = NULL;
    qcmTableInfo          * sOldTableInfo;
    smSCN                   sSCN;
    void                  * sTableHandle;
    qcmColumn             * sTableColumn;
    qcmColumn             * sModifyColumn;
    qcmColumn             * sNewColumn;
    qcmColumn             * sNewTableColumn;
    mtcColumn             * sNewMtcColumn;
    qcmIndex              * sNewTableIndex;
    mtcColumn             * sMtcColumn;
    UInt                    sColumnCount;
    UInt                    sCurrentOffset;
    smOID                   sNewTableOID;
    const void            * sNewTableHandle;
    qcmColumn             * sModifyColumns;
    qdConstraintSpec      * sConstraint;
    UInt                    i;
    
    const void            * sNewPartTableHandle;
    qcmTableInfo          * sOldPartInfo;
    qcmPartitionInfoList  * sPartInfoList;
    smOID                 * sNewPartitionOID   = NULL;
    UInt                    sPartitionCount    = 0;
    qcmIndex             ** sNewPartIndex      = NULL;
    UInt                    sNewPartIndexCount = 0;

    
    sOldTableInfo = aParseTree->tableInfo;
    
    //-----------------------------------------
    // new table column 구성
    //-----------------------------------------

    // new table column 생성
    sColumnCount = sOldTableInfo->columnCount;

    IDU_LIMITPOINT( "qdbAlter::recreateTableForMemory::malloc1");
    IDE_TEST( aStatement->qmxMem->alloc( ID_SIZEOF(qcmColumn) * sColumnCount,
                                         (void**) &sNewTableColumn )
              != IDE_SUCCESS);

    IDU_LIMITPOINT( "qdbAlter::recreateTableForMemory::malloc2");
    IDE_TEST( aStatement->qmxMem->alloc( ID_SIZEOF(mtcColumn) * sColumnCount,
                                         (void**) &sNewMtcColumn)
              != IDE_SUCCESS);

    // new table column 초기화
    idlOS::memcpy( (void*) sNewTableColumn,
                   (void*) sOldTableInfo->columns,
                   ID_SIZEOF(qcmColumn) * sColumnCount );

    for ( i = 0; i < sColumnCount; i++ )
    {
        idlOS::memcpy( (void*) &sNewMtcColumn[i],
                       (void*) sNewTableColumn[i].basicInfo,
                       ID_SIZEOF(mtcColumn) );

        sNewTableColumn[i].basicInfo = &sNewMtcColumn[i];
    }

    // new table column 구성
    sTableColumn = aParseTree->columns;
    sModifyColumn = aParseTree->modifyColumns;

    while ( sTableColumn != NULL )
    {
        IDE_DASSERT( sModifyColumn != NULL );

        // sModifyColumn에 해당하는 sNewTableColumn을 찾는다.
        sNewColumn = NULL;

        for ( i = 0; i < sColumnCount; i++ )
        {
            // sModifyColumn->basicInfo->column.id는 설정되었으므로
            // column.id로 비교한다.
            if ( sModifyColumn->basicInfo->column.id ==
                 sNewTableColumn[i].basicInfo->column.id )
            {
                sNewColumn = & sNewTableColumn[i];
                break;
            }
            else
            {
                // Nothing to do.
            }
        }

        // 반드시 존재한다.
        IDE_ASSERT( sNewColumn != NULL );

        // sNewTableColumn에 sModifyColumn을 복사한다.
        // (sNewColumn->next의 정보는 후에 보정한다.)
        idlOS::memcpy( (void*) sNewColumn,
                       (void*) sModifyColumn,
                       ID_SIZEOF(qcmColumn) );

        // tableColumn의 정보를 보존한다.
        // not null flag
        sNewColumn->basicInfo->flag &= ~MTC_COLUMN_NOTNULL_MASK;
        sNewColumn->basicInfo->flag |=
            (sTableColumn->basicInfo->flag & MTC_COLUMN_NOTNULL_MASK);
        // default value
        sNewColumn->defaultValueStr = sTableColumn->defaultValueStr;
        /* PROJ-1090 Function-based Index */
        sNewColumn->flag &= ~QCM_COLUMN_HIDDEN_COLUMN_MASK;
        sNewColumn->flag |= (sTableColumn->flag & QCM_COLUMN_HIDDEN_COLUMN_MASK);

        //-----------------------------------------
        // default value 변경
        //-----------------------------------------

        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_DEFAULT_MASK)
             == QCM_COLUMN_MODIFY_DEFAULT_TRUE )
        {
            sMtcColumn = QTC_TMPL_COLUMN( QC_PRIVATE_TMPLATE(aStatement),
                                          sNewColumn->defaultValue );

            if ( sMtcColumn->module->id == MTD_NULL_ID )
            {
                // 'i1 default NULL'은 'i1 drop default'를 의미한다.
                sNewColumn->defaultValue = NULL;
            }
            else
            {
                // Nothing to do.
            }

            // 기존의 default value를 초기화한다.
            sNewColumn->defaultValueStr = NULL;
        }
        else
        {
            // Nothing to do.
        }

        //-----------------------------------------
        // (not) null 변경
        //-----------------------------------------

        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_NULLABLE_MASK)
             == QCM_COLUMN_MODIFY_NULLABLE_NULL )
        {
            // nullable flag를 설정한다.
            sNewColumn->basicInfo->flag &= ~MTC_COLUMN_NOTNULL_MASK;
            sNewColumn->basicInfo->flag |= MTC_COLUMN_NOTNULL_FALSE;
        }
        else if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_NULLABLE_MASK)
                  == QCM_COLUMN_MODIFY_NULLABLE_NOTNULL )
        {
            // not null flag를 설정한다.
            sNewColumn->basicInfo->flag &= ~MTC_COLUMN_NOTNULL_MASK;
            sNewColumn->basicInfo->flag |= MTC_COLUMN_NOTNULL_TRUE;
        }
        else
        {
            // Nothing to do.
        }

        //-----------------------------------------
        // type, length 변경
        //-----------------------------------------

        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_COLUMN_OPTION_MASK)
             == QCM_COLUMN_MODIFY_COLUMN_OPTION_TRUE )
        {
            // column option을 변경한 경우

            // Nothing to do.
        }
        else
        {
            // 순수 type, length 변경

            // Nothing to do.
        }

        sTableColumn = sTableColumn->next;
        sModifyColumn = sModifyColumn->next;
    }

    //-----------------------------------------
    // modify 대상이 아닌 기존 컬럼에 대한 default value 정보 설정
    //-----------------------------------------

    for ( i = 0; i < sColumnCount; i++ )
    {
        // fix BUG-14204
        if ( sNewTableColumn[i].defaultValueStr != NULL )
        {
            // old column의 default value를 이용하기 위해
            // dummy qtcNode를 붙인다.
            IDU_LIMITPOINT("qdbAlter::recreateTableForMemory::malloc3");
            IDE_TEST( aStatement->qmxMem->alloc(
                          ID_SIZEOF(qtcNode),
                          (void**) & sNewTableColumn[i].defaultValue )
                      != IDE_SUCCESS );

            // PROJ-1579 NCHAR
            // old column의 default value는 이미 메타 테이블에 저장되어 있음
            sNewTableColumn[i].ncharLiteralPos = NULL;
        }
        else
        {
            // Nothing to do.
        }
    }

    //-----------------------------------------
    // sNewTableColumn의 next를 연결한다.
    //-----------------------------------------

    for ( i = 0; i < sColumnCount - 1; i++ )
    {
        sNewTableColumn[i].next = & sNewTableColumn[i + 1];
    }
    sNewTableColumn[i].next = NULL;

    //-----------------------------------------
    // new table column offset 조정
    //-----------------------------------------

    if ( smiTableSpace::isMemTableSpaceType( sOldTableInfo->TBSType )
         == ID_TRUE )
    {
        sCurrentOffset = smiGetRowHeaderSize( SMI_TABLE_MEMORY );
    }
    else
    {
        IDE_DASSERT( smiTableSpace::isVolatileTableSpaceType( sOldTableInfo->TBSType )
                     == ID_TRUE );

        sCurrentOffset = smiGetRowHeaderSize( SMI_TABLE_VOLATILE );
    }

    // column offset을 조정한다.
    // column id가 변경되지는 않는다.
    IDE_TEST( qdbCommon::setColListOffset( aStatement->qmxMem,
                                           sNewTableColumn,
                                           sCurrentOffset )
              != IDE_SUCCESS );

    //-----------------------------------------
    // new table index 구성
    //-----------------------------------------

    // new table index 생성
    if ( sOldTableInfo->indexCount > 0 )
    {
        IDU_LIMITPOINT("qdbAlter::recreateTableForMemory::malloc4");
        IDE_TEST( aStatement->qmxMem->alloc(
                      ID_SIZEOF(qcmIndex) * sOldTableInfo->indexCount,
                      (void**) & sNewTableIndex )
                  != IDE_SUCCESS );

        idlOS::memcpy( sNewTableIndex,
                       sOldTableInfo->indices,
                       ID_SIZEOF(qcmIndex) * sOldTableInfo->indexCount );
    }
    else
    {
        sNewTableIndex = NULL;
    }

    //-----------------------------------------------------
    // PROJ-2334 PMT
    // memory partitioned table recreate Index 정보 구축을 위한 공간 할당
    //-----------------------------------------------------
    if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        //-----------------------------------------
        // partitined count 
        //-----------------------------------------
        for ( sPartitionCount = 0, sPartInfoList = aParseTree->partTable->partInfoList;
              sPartInfoList != NULL;
              sPartInfoList = sPartInfoList->next, sPartitionCount++ )
        {
            /* Mothing To Do */
        }

        IDU_LIMITPOINT("qdbAlter::recreateTableForMemory::malloc5");
        IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(qcmIndex*) *
                                           sPartitionCount,
                                           (void**)& sNewPartIndex)
                 != IDE_SUCCESS);

        for ( i = 0, sPartInfoList = aParseTree->partTable->partInfoList;
              sPartInfoList != NULL;
              sPartInfoList = sPartInfoList->next, i++ )
        {
            sOldPartInfo = sPartInfoList->partitionInfo;

            if ( sOldPartInfo->indexCount > 0 )
            {
                IDU_LIMITPOINT("qdbAlter::recreateTableForMemory::malloc6");
                IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(qcmIndex) *
                                                   sOldPartInfo->indexCount,
                                                   (void**)&sNewPartIndex[i])
                         != IDE_SUCCESS);
                    
                if ( sNewPartIndexCount == 0 )
                {
                    sNewPartIndexCount = sOldPartInfo->indexCount;
                }
                else
                {
                    IDE_DASSERT( sNewPartIndexCount == sOldPartInfo->indexCount );
                }
                    
                idlOS::memcpy( sNewPartIndex[i],
                               sOldPartInfo->indices,
                               ID_SIZEOF(qcmIndex) * sOldPartInfo->indexCount );
            }
            else
            {
                sNewPartIndex[i] = NULL;
            }
        }
    }
    else
    {
        /* Nothing Td Do */
    }

    //-----------------------------------------
    // table 생성
    //-----------------------------------------

    IDE_TEST( qdbCommon::createTableOnSM( aStatement,
                                          sNewTableColumn,
                                          sOldTableInfo->tableOwnerID,
                                          sOldTableInfo->tableID,
                                          sOldTableInfo->maxrows,
                                          sOldTableInfo->TBSID,
                                          sOldTableInfo->segAttr,
                                          sOldTableInfo->segStoAttr,
                                          /* 원본 Table Flag를 통째로 복사 =>
                                             MASK 비트를 를 모두 1로 설정 */
                                          QDB_TABLE_ATTR_MASK_ALL,
                                          sOldTableInfo->tableFlag, /* Flag Value */
                                          sOldTableInfo->parallelDegree,
                                          & sNewTableOID )
              != IDE_SUCCESS );
    
    sNewTableHandle = smiGetTable( sNewTableOID );

    // BUG-44814 ddl 구문 수행시 통계정보 복사를 해야함
    smiStatistics::copyTableStats( sNewTableHandle, sOldTableInfo->tableHandle, NULL, 0 );

    // BUG-44964 modify column 시에 min, max 통계정보를 복사하면 안됩니다.
    // 데이타 타입이 달리질 경우 잘못된 값으로 읽게 됩니다.
    for ( sModifyColumns = aParseTree->modifyColumns;
          sModifyColumns != NULL;
          sModifyColumns = sModifyColumns->next )
    {
        if ( ((sModifyColumns->flag & QCM_COLUMN_MODIFY_TYPE_MASK) == QCM_COLUMN_MODIFY_TYPE_TRUE) ||
             ((sModifyColumns->flag & QCM_COLUMN_MODIFY_LENGTH_MASK) == QCM_COLUMN_MODIFY_LENGTH_TRUE) )
        {

            IDE_TEST( smiStatistics::removeColumnMinMax(
                                        sNewTableHandle,
                                        (sModifyColumns->basicInfo->column.id & SMI_COLUMN_ID_MASK) )
                    != IDE_SUCCESS );
        }
        else
        {
            // nothing todo.
        }
    }

    // update table spec (tableOID).
    IDE_TEST( qdbCommon::updateTableSpecFromMeta(
                  aStatement,
                  aParseTree->userName,
                  aParseTree->tableName,
                  sOldTableInfo->tableID,
                  sNewTableOID,
                  sOldTableInfo->columnCount,
                  sOldTableInfo->parallelDegree )
              != IDE_SUCCESS );

    //-----------------------------------------
    // PROJ-2334 PMT
    // PARTITIONED TABLE 생성
    //-----------------------------------------

    if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        //-----------------------------------------
        // partitioned oid 공간 할당
        //-----------------------------------------
        IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(smOID) * sPartitionCount,
                                           (void**)&sNewPartitionOID)
                 != IDE_SUCCESS);

        // 테이블 파티션 개수만큼 반복
        for ( i = 0, sPartInfoList = aParseTree->partTable->partInfoList;
              sPartInfoList != NULL;
              sPartInfoList = sPartInfoList->next, i++ )
        {
            // alter modify column 이전의 tableInfo
            sOldPartInfo = sPartInfoList->partitionInfo;

            //-----------------------------------------
            // new partition 생성
            //-----------------------------------------

            IDE_TEST( qdbCommon::createTableOnSM( aStatement,
                                                  sNewTableColumn,
                                                  sOldTableInfo->tableOwnerID,
                                                  sOldTableInfo->tableID,
                                                  sOldTableInfo->maxrows,
                                                  sOldPartInfo->TBSID,
                                                  sOldTableInfo->segAttr,
                                                  sOldTableInfo->segStoAttr,
                                                  QDB_TABLE_ATTR_MASK_ALL,
                                                  sOldPartInfo->tableFlag, /* Flag Value */
                                                  sOldPartInfo->parallelDegree,
                                                  & sNewPartitionOID[i] )
                      != IDE_SUCCESS );
            
            sNewPartTableHandle = smiGetTable(sNewPartitionOID[i]);

            // BUG-44814 ddl 구문 수행시 통계정보 복사를 해야함
            smiStatistics::copyTableStats( sNewPartTableHandle, sOldPartInfo->tableHandle, NULL, 0 );

            // BUG-44964 modify column 시에 min, max 통계정보를 복사하면 안됩니다.
            // 데이타 타입이 달리질 경우 잘못된 값으로 읽게 됩니다.
            for ( sModifyColumns = aParseTree->modifyColumns;
                  sModifyColumns != NULL;
                  sModifyColumns = sModifyColumns->next )
            {
                if ( ((sModifyColumns->flag & QCM_COLUMN_MODIFY_TYPE_MASK) == QCM_COLUMN_MODIFY_TYPE_TRUE) ||
                     ((sModifyColumns->flag & QCM_COLUMN_MODIFY_LENGTH_MASK) == QCM_COLUMN_MODIFY_LENGTH_TRUE) )
                {
                    IDE_TEST( smiStatistics::removeColumnMinMax(
                                                sNewPartTableHandle,
                                                (sModifyColumns->basicInfo->column.id & SMI_COLUMN_ID_MASK) )
                            != IDE_SUCCESS );
                }
                else
                {
                    // nothing todo.
                }
            }

            IDE_TEST( qdbCommon::updatePartTableSpecFromMeta(
                          aStatement,
                          sOldTableInfo->tableID,
                          sOldPartInfo->partitionID,
                          sNewPartitionOID[i] )
                      != IDE_SUCCESS );
        }
    }
    else
    {
        /* Nothing To Do */
    }

    //-----------------------------------------
    // column, constraint, index spec 삭제
    //-----------------------------------------

    // delete invalidated column spec from meta.
    IDE_TEST( deleteColumnSpecFromMeta( aStatement,
                                        sOldTableInfo->tableID )
              != IDE_SUCCESS );

    IDE_TEST( qdd::deleteConstraintsFromMeta( aStatement,
                                              sOldTableInfo->tableID )
              != IDE_SUCCESS );

    IDE_TEST( deleteIndexSpecFromMeta( aStatement,
                                       sOldTableInfo->tableID )
              != IDE_SUCCESS );

    // PROJ-2334 PMT
    if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST(deletePartKeyColumnSpecFromMeta(aStatement,
                                                 sOldTableInfo->tableID,
                                                 QCM_TABLE_OBJECT_TYPE)
                 != IDE_SUCCESS);

        IDE_TEST(deletePartLobSpecFromMeta(aStatement, sOldTableInfo->tableID)
                 != IDE_SUCCESS);
    }
    else
    {
        /* Nothing To Do */
    }
    
    //-----------------------------------------
    // column, constraint, index spec 생성
    //-----------------------------------------

    // insert new column spec into meta.
    IDE_TEST( qdbCommon::insertColumnSpecIntoMeta( aStatement,
                                                   aParseTree->userID,
                                                   sOldTableInfo->tableID,
                                                   sNewTableColumn,
                                                   ID_FALSE /* is queue */)
              != IDE_SUCCESS );

    /* PROJ-2334 PMT */
    if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST(qdbCommon::insertPartKeyColumnSpecIntoMeta(
                     aStatement,
                     aParseTree->userID,
                     sOldTableInfo->tableID,
                     sNewTableColumn,
                     sOldTableInfo->partKeyColumns,
                     QCM_TABLE_OBJECT_TYPE)
                 != IDE_SUCCESS);

        for ( sPartInfoList = aParseTree->partTable->partInfoList;
              sPartInfoList != NULL;
              sPartInfoList = sPartInfoList->next )
        {
            sOldPartInfo = sPartInfoList->partitionInfo;
                        
            IDE_TEST(qdbCommon::insertPartLobSpecIntoMeta(
                         aStatement,
                         aParseTree->userID,
                         sOldTableInfo->tableID,
                         sOldPartInfo->partitionID,
                         sNewTableColumn )
                     != IDE_SUCCESS);
        }
    }
    else
    {
        /* Nothing To Do */
    }

    IDE_TEST( qdbCommon::createConstraintFromInfo( aStatement,
                                                   sOldTableInfo,
                                                   sNewTableOID,
                                                   sPartitionCount,
                                                   sNewPartitionOID,
                                                   SMI_INDEX_BUILD_UNCOMMITTED_ROW_ENABLE,
                                                   sNewTableIndex,
                                                   sNewPartIndex,
                                                   sNewPartIndexCount,
                                                   NULL,
                                                   NULL,
                                                   NULL )
              != IDE_SUCCESS );

    // modify column에서 삭제한 not null constraint 제거
    sModifyColumn = aParseTree->modifyColumns;

    while ( sModifyColumn != NULL )
    {
        if ( (sModifyColumn->flag & QCM_COLUMN_MODIFY_NULLABLE_MASK)
             == QCM_COLUMN_MODIFY_NULLABLE_NULL )
        {
            // not null constraint 삭제
            IDE_TEST( deleteNotNullConstraint(
                          aStatement,
                          sOldTableInfo,
                          sModifyColumn->basicInfo->column.id )
                      != IDE_SUCCESS );
        }
        else
        {
            // Nothing to do.
        }

        sModifyColumn = sModifyColumn->next;
    }

    // modify column에서 추가한 not null constraint 추가
    for ( sConstraint = aParseTree->constraints;
          sConstraint != NULL;
          sConstraint = sConstraint->next )
    {
        IDE_TEST( qdbCommon::createConstrNotNull( aStatement,
                                                  sConstraint,
                                                  aParseTree->userID,
                                                  sOldTableInfo->tableID )
                  != IDE_SUCCESS );
    }

    // re-create index!!
    IDE_TEST( qdbCommon::createIndexFromInfo( aStatement,
                                              sOldTableInfo,
                                              sNewTableOID,
                                              sPartitionCount,
                                              sNewPartitionOID,
                                              SMI_INDEX_BUILD_UNCOMMITTED_ROW_ENABLE,
                                              sNewTableIndex,
                                              sNewPartIndex,
                                              sNewPartIndexCount,
                                              NULL,
                                              NULL,
                                              NULL,
                                              ID_TRUE )
              != IDE_SUCCESS );

    //-----------------------------------------
    // move row
    //-----------------------------------------

    if ( sOldTableInfo->tablePartitionType != QCM_PARTITIONED_TABLE )
    {            
        // move row from old to new.
        IDE_TEST( moveRow( aStatement,
                           NULL,
                           sOldTableInfo,
                           sOldTableInfo->tableHandle,
                           sNewTableHandle,
                           sOldTableInfo->columns,
                           sNewTableColumn,
                           NULL,
                           NULL,
                           ID_FALSE /* No Undo Logging */)
                  != IDE_SUCCESS );
    }
    else
    {
        /* PROJ-2334 PMT */
        for ( i = 0, sPartInfoList = aParseTree->partTable->partInfoList;
              sPartInfoList != NULL;
              sPartInfoList = sPartInfoList->next, i++ )
        {
            sOldPartInfo = sPartInfoList->partitionInfo;
            
            sNewPartTableHandle = smiGetTable( sNewPartitionOID[i] );

            // move row from old to new.
            IDE_TEST( moveRow( aStatement,
                               NULL,
                               sOldTableInfo,
                               sOldPartInfo->tableHandle,
                               sNewPartTableHandle,
                               sOldPartInfo->columns,
                               sNewTableColumn,
                               NULL,
                               NULL,
                               ID_FALSE /* No Undo Logging */)
                      != IDE_SUCCESS );
        }
        
        IDE_TEST( smiTable::dropTable( QC_SMI_STMT( aStatement ),
                                       sOldTableInfo->tableHandle,
                                       SMI_TBSLV_DDL_DML )
                  != IDE_SUCCESS );
    }


    //-----------------------------------------
    // cached meta 재생성
    //-----------------------------------------

    IDE_TEST( qcm::makeAndSetQcmTableInfo( QC_SMI_STMT( aStatement ),
                                           sOldTableInfo->tableID,
                                           sNewTableOID )
              != IDE_SUCCESS );

    IDE_TEST( qcm::getTableInfoByID( aStatement,
                                     sOldTableInfo->tableID,
                                     & sNewTableInfo,
                                     & sSCN,
                                     & sTableHandle )
              != IDE_SUCCESS);

    if ( sNewTableInfo->primaryKey != NULL )
    {
        for ( i = 0; i < sNewTableInfo->primaryKey->keyColCount; i++ )
        {
            IDE_TEST( qdbCommon::makeColumnNotNull(
                          aStatement,
                          sNewTableInfo->tableHandle,
                          sNewTableInfo->maxrows,
                          NULL,
                          ID_FALSE,
                          sNewTableInfo->primaryKey->keyColumns[i].column.id )
                      != IDE_SUCCESS );
        }
    }
    else
    {
        // Nothing to do.
    }

    (void) qcm::destroyQcmTableInfo( sNewTableInfo );
    sNewTableInfo = NULL;

    IDE_TEST( qcm::makeAndSetQcmTableInfo( QC_SMI_STMT( aStatement ),
                                           sOldTableInfo->tableID,
                                           sNewTableOID )
              != IDE_SUCCESS );

    IDE_TEST( qcm::getTableInfoByID( aStatement,
                                     sOldTableInfo->tableID,
                                     & sNewTableInfo,
                                     & sSCN,
                                     & sTableHandle )
              != IDE_SUCCESS );

    /* PROJ-2334 PMT */
    if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        for ( i = 0, sPartInfoList = aParseTree->partTable->partInfoList;
              sPartInfoList != NULL;
              sPartInfoList = sPartInfoList->next, i++ )
        {
            sOldPartInfo = sPartInfoList->partitionInfo;
            
            IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                          QC_SMI_STMT( aStatement ),
                          sOldPartInfo->partitionID,
                          sNewPartitionOID[i],
                          sNewTableInfo,
                          NULL )
                      != IDE_SUCCESS );
            
            IDE_TEST( qcmPartition::getPartitionInfoByID(
                          aStatement,
                          sOldPartInfo->partitionID,
                          & aNewPartInfo[i],
                          & sSCN,
                          & sTableHandle )
                      != IDE_SUCCESS );
        }           
    }
    else
    {
        /* Nothing To Do */
    }
      
    *aNewTableInfo = sNewTableInfo;

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    if ( sNewTableInfo != NULL )
    {
        (void) qcm::destroyQcmTableInfo( sNewTableInfo );
    }

    /* PROJ-2334 PMT */
    if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        for ( i = 0, sPartInfoList = aParseTree->partTable->partInfoList;
              sPartInfoList != NULL;
              sPartInfoList = sPartInfoList->next, i++ )
        {
            (void)qcmPartition::destroyQcmPartitionInfo( aNewPartInfo[i] );
            aNewPartInfo[i] = NULL;
        }
    }
    else
    {
        /* Nothing To Do */
    }

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::recreateTableForDisk( qcStatement       * aStatement,
                                       qdTableParseTree  * aParseTree,
                                       qcmTableInfo     ** aNewTableInfo,
                                       qcmTableInfo      * aPartInfo,
                                       qcmTableInfo     ** aNewPartInfo,
                                       UInt                aNewPartIdx )
{
 /***********************************************************************
 *
 * Description : PROJ-1877
 *     table 재생성과 table의 하위 객체(index등) 재생성으로
 *     alter table modify column 기능을 수행한다.
 *
 * Implementation :
 *     1. non-partitioned table에 대한 re-create table
 *     2. partitioned table의 partition 하나에 대한 re-create partition
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::recreateTableForDisk"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY("qdbAlter::recreateTableForDisk"));

    qcmTableInfo          * sOldTableInfo = NULL;
    qcmTableInfo          * sNewTableInfo;
    qcmTableInfo          * sOldPartInfo = NULL;
    qcmTableInfo          * sNewPartInfo;
    qcmTableInfo          * sTempPartInfo;
    smOID                   sNewTableOID;
    const void            * sNewTableHandle;
    const void            * sNewIndexHandle;
    void                  * sTableHandle;
    qcmColumn             * sModifyColumns;
    smSCN                   sSCN;
    qcmIndex              * sIndex;
    UInt                    sFlag;
    smiSegAttr              sSegAttr;
    smiSegStorageAttr       sSegStoAttr;
    smiColumnList         * sColumnListAtKey;
    UInt                    i;
    
    // alter modify column 이전의 tableInfo
    sOldTableInfo = aParseTree->tableInfo;
    
    // alter modify column 이후의 tableInfo
    sNewTableInfo = *aNewTableInfo;

    // PROJ-1502 PARTITIONED DISK TABLE
    if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_DASSERT( aPartInfo != NULL );

        // alter modify column 이전의 tableInfo
        sOldPartInfo = aPartInfo;

        // alter modify column 이후의 tableInfo
        sNewPartInfo = aNewPartInfo[aNewPartIdx];

        //-----------------------------------------
        // new partition 생성
        //-----------------------------------------

        IDE_TEST( qdbCommon::createTableOnSM( aStatement,
                                              sNewPartInfo->columns,
                                              sOldTableInfo->tableOwnerID,
                                              sOldTableInfo->tableID,
                                              sOldTableInfo->maxrows,
                                              sOldPartInfo->TBSID,
                                              sOldTableInfo->segAttr,
                                              sOldTableInfo->segStoAttr,
                                              QDB_TABLE_ATTR_MASK_ALL,
                                              sOldPartInfo->tableFlag, /* Flag Value */
                                              sOldPartInfo->parallelDegree,
                                              & sNewTableOID )
                  != IDE_SUCCESS );

        sNewTableHandle = smiGetTable( sNewTableOID );

        // BUG-44814 ddl 구문 수행시 통계정보 복사를 해야함
        smiStatistics::copyTableStats( sNewTableHandle, sOldPartInfo->tableHandle, NULL, 0 );

        // BUG-44964 modify column 시에 min, max 통계정보를 복사하면 안됩니다.
        // 데이타 타입이 달리질 경우 잘못된 값으로 읽게 됩니다.
        for ( sModifyColumns = aParseTree->modifyColumns;
              sModifyColumns != NULL;
              sModifyColumns = sModifyColumns->next )
        {
            if ( ((sModifyColumns->flag & QCM_COLUMN_MODIFY_TYPE_MASK) == QCM_COLUMN_MODIFY_TYPE_TRUE) ||
                 ((sModifyColumns->flag & QCM_COLUMN_MODIFY_LENGTH_MASK) == QCM_COLUMN_MODIFY_LENGTH_TRUE) )
            {
                IDE_TEST( smiStatistics::removeColumnMinMax(
                                            sNewTableHandle,
                                            (sModifyColumns->basicInfo->column.id & SMI_COLUMN_ID_MASK) )
                          != IDE_SUCCESS );
            }
            else
            {
                // nothing todo.
            }
        }
        
        IDE_TEST( qdbCommon::updatePartTableSpecFromMeta(
                      aStatement,
                      sOldTableInfo->tableID,
                      sOldPartInfo->partitionID,
                      sNewTableOID )
                  != IDE_SUCCESS );

        //-----------------------------------------
        // move row
        //-----------------------------------------

        // move row from old to new.
        IDE_TEST( moveRow( aStatement,
                           NULL,
                           sOldTableInfo,
                           sOldPartInfo->tableHandle,
                           sNewTableHandle,
                           sOldPartInfo->columns,
                           sNewTableInfo->columns,
                           sNewTableInfo,
                           aParseTree->newIndexTables,
                           ID_FALSE /* No Undo Logging */)
                  != IDE_SUCCESS );

        /* BUG-44230 ADD, DROP, MODIFY, REORGANIZE DDL의 INDEX, CONSTRAINT 생성 순서 변경 */
        //-----------------------------------------
        // local index 생성
        //-----------------------------------------

        for ( i = 0; i < sNewPartInfo->indexCount; i++ )
        {
            sIndex = & sNewPartInfo->indices[i];

            // 인덱스 생성을 위한 flag
            sFlag = smiTable::getIndexInfo( sIndex->indexHandle );
            sSegAttr = smiTable::getIndexSegAttr( sIndex->indexHandle );
            sSegStoAttr = smiTable::getIndexSegStoAttr( sIndex->indexHandle );

            // 인덱스 생성을 위한 키 컬럼 정보를 구한다.
            // index keyColumn type flag는 sIndex에 이미 설정되어 있다.
            IDE_TEST( qdx::getKeyColumnList( aStatement,
                                             sIndex,
                                             & sColumnListAtKey )
                      != IDE_SUCCESS );

            // 인덱스 생성
            IDE_TEST( smiTable::createIndex( aStatement->mStatistics,
                                             QC_SMI_STMT( aStatement ),
                                             sIndex->TBSID,
                                             sNewTableHandle,
                                             (SChar*)sIndex->name,
                                             sIndex->indexId,
                                             sIndex->indexTypeId,
                                             sColumnListAtKey,
                                             sFlag,
                                             QD_INDEX_DEFAULT_PARALLEL_DEGREE,
                                             SMI_INDEX_BUILD_UNCOMMITTED_ROW_ENABLE,
                                             sSegAttr,
                                             sSegStoAttr,
                                             0, /* PROJ-2433 : disk에서는 direct key index 사용안함 */
                                             & sNewIndexHandle )
                      != IDE_SUCCESS );
            
            // BUG-44814 ddl 구문 수행시 통계정보 복사를 해야함
            smiStatistics::copyIndexStats( sNewIndexHandle, sIndex->indexHandle );
        }
    }
    else
    {
        //-----------------------------------------
        // table 생성
        //-----------------------------------------

        IDE_TEST( qdbCommon::createTableOnSM( aStatement,
                                              sNewTableInfo->columns,
                                              sOldTableInfo->tableOwnerID,
                                              sOldTableInfo->tableID,
                                              sOldTableInfo->maxrows,
                                              sOldTableInfo->TBSID,
                                              sOldTableInfo->segAttr,
                                              sOldTableInfo->segStoAttr,
                                              QDB_TABLE_ATTR_MASK_ALL,
                                              sOldTableInfo->tableFlag, /* Flag Value */
                                              sOldTableInfo->parallelDegree,
                                              & sNewTableOID )
                  != IDE_SUCCESS );

        sNewTableHandle = smiGetTable( sNewTableOID );
        
        // BUG-44814 ddl 구문 수행시 통계정보 복사를 해야함
        smiStatistics::copyTableStats( sNewTableHandle, sOldTableInfo->tableHandle, NULL, 0 );

        // BUG-44964 modify column 시에 min, max 통계정보를 복사하면 안됩니다.
        // 데이타 타입이 달리질 경우 잘못된 값으로 읽게 됩니다.
        for ( sModifyColumns = aParseTree->modifyColumns;
              sModifyColumns != NULL;
              sModifyColumns = sModifyColumns->next )
        {
            if ( ((sModifyColumns->flag & QCM_COLUMN_MODIFY_TYPE_MASK) == QCM_COLUMN_MODIFY_TYPE_TRUE) ||
                 ((sModifyColumns->flag & QCM_COLUMN_MODIFY_LENGTH_MASK) == QCM_COLUMN_MODIFY_LENGTH_TRUE) )
            {
                IDE_TEST( smiStatistics::removeColumnMinMax(
                                            sNewTableHandle,
                                            (sModifyColumns->basicInfo->column.id & SMI_COLUMN_ID_MASK) )
                          != IDE_SUCCESS );
            }
            else
            {
                // nothing todo.
            }
        }

        // update table spec (tableOID).
        IDE_TEST(qdbCommon::updateTableSpecFromMeta(
                     aStatement,
                     aParseTree->userName,
                     aParseTree->tableName,
                     sOldTableInfo->tableID,
                     sNewTableOID,
                     sNewTableInfo->columnCount,
                     sOldTableInfo->parallelDegree )
                 != IDE_SUCCESS);

        //-----------------------------------------
        // move row
        //-----------------------------------------
        // move row from old to new.
        IDE_TEST( moveRow( aStatement,
                           NULL,
                           sOldTableInfo,
                           sOldTableInfo->tableHandle,
                           sNewTableHandle,
                           sOldTableInfo->columns,
                           sNewTableInfo->columns,
                           NULL,
                           NULL,
                           ID_FALSE /* No Undo Logging */)
                  != IDE_SUCCESS );

        /* BUG-44230 ADD, DROP, MODIFY, REORGANIZE DDL의 INDEX, CONSTRAINT 생성 순서 변경 */
        //-----------------------------------------
        // index 생성
        //-----------------------------------------

        for ( i = 0; i < sNewTableInfo->indexCount; i++ )
        {
            sIndex = & sNewTableInfo->indices[i];

            // 인덱스 생성을 위한 flag
            sFlag = smiTable::getIndexInfo( sIndex->indexHandle );
            sSegAttr = smiTable::getIndexSegAttr( sIndex->indexHandle );
            sSegStoAttr = smiTable::getIndexSegStoAttr( sIndex->indexHandle );

            // 인덱스 생성을 위한 키 컬럼 정보를 구한다.
            // index keyColumn type flag는 sIndex에 이미 설정되어 있다.
            IDE_TEST( qdx::getKeyColumnList( aStatement,
                                             sIndex,
                                             & sColumnListAtKey )
                      != IDE_SUCCESS );

            // 인덱스 생성
            IDE_TEST( smiTable::createIndex( aStatement->mStatistics,
                                             QC_SMI_STMT( aStatement ),
                                             sIndex->TBSID,
                                             sNewTableHandle,
                                             (SChar*)sIndex->name,
                                             sIndex->indexId,
                                             sIndex->indexTypeId,
                                             sColumnListAtKey,
                                             sFlag,
                                             QD_INDEX_DEFAULT_PARALLEL_DEGREE,
                                             SMI_INDEX_BUILD_UNCOMMITTED_ROW_ENABLE,
                                             sSegAttr,
                                             sSegStoAttr,
                                             0, /* PROJ-2433 : disk에서는 direct key index 사용안함 */
                                             & sNewIndexHandle )
                      != IDE_SUCCESS );

            // BUG-44814 ddl 구문 수행시 통계정보 복사를 해야함
            smiStatistics::copyIndexStats( sNewIndexHandle, sIndex->indexHandle );
        }
    }

    /* BUG-44230 ADD, DROP, MODIFY, REORGANIZE DDL의 INDEX, CONSTRAINT 생성 순서 변경 */
    IDU_FIT_POINT( "qdbAlter::recreateTableForDisk::BUG-44230" );

    //-----------------------------------------
    // cached meta 재생성
    //-----------------------------------------

    // PROJ-1502 PARTITIONED DISK TABLE
    if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_DASSERT( aNewPartInfo != NULL );

        sTempPartInfo = aNewPartInfo[aNewPartIdx];

        IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo(
                      QC_SMI_STMT( aStatement ),
                      sOldPartInfo->partitionID,
                      sNewTableOID,
                      sNewTableInfo,
                      NULL )
                  != IDE_SUCCESS );

        IDE_TEST( qcmPartition::getPartitionInfoByID(
                      aStatement,
                      sOldPartInfo->partitionID,
                      & aNewPartInfo[aNewPartIdx],
                      & sSCN,
                      & sTableHandle )
                  != IDE_SUCCESS );

        (void) qcmPartition::destroyQcmPartitionInfo( sTempPartInfo );
    }
    else
    {
        IDE_TEST( qcm::makeAndSetQcmTableInfo( QC_SMI_STMT( aStatement ),
                                               sOldTableInfo->tableID,
                                               sNewTableOID )
                  != IDE_SUCCESS );

        IDE_TEST( qcm::getTableInfoByID( aStatement,
                                         sOldTableInfo->tableID,
                                         aNewTableInfo,
                                         & sSCN,
                                         & sTableHandle )
                  != IDE_SUCCESS);

        (void) qcm::destroyQcmTableInfo( sNewTableInfo );
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::deleteNotNullConstraint( qcStatement   * aStatement,
                                          qcmTableInfo  * aTableInfo,
                                          UInt            aColID )
{
 /***********************************************************************
 *
 * Description : PROJ-1877
 *     column id에 걸린 not null constraint 제거
 *
 * Implementation :
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::deleteNotNullConstraint"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY("qdbAlter::deleteNotNullConstraint"));

    UInt      sConstraintID;
    idBool    sFound = ID_FALSE;
    UInt      i;

    // 제거할 not null constraint 검색
    for ( i = 0; i < aTableInfo->notNullCount; i++ )
    {
        if ( (aTableInfo->notNulls[i].constraintColumn[0] == aColID ) &&
             (aTableInfo->notNulls[i].constraintColumnCount == 1) )
        {
            sConstraintID = aTableInfo->notNulls[i].constraintID;
            sFound = ID_TRUE;
            break;
        }
        else
        {
            // Nothing to do.
        }
    }

    // not null constraint 제거
    if ( sFound == ID_TRUE )
    {
        IDE_TEST( qdd::deleteConstraintsFromMetaByConstraintID(
                      aStatement,
                      sConstraintID )
                  != IDE_SUCCESS );
    }
    else
    {
        // 반드시 찾아야 한다.
        IDE_DASSERT( 0 );
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::insertNotNullConstraint( qcStatement      * aStatement,
                                          qdTableParseTree * aParseTree,
                                          qcmColumn        * aColumn )
{
 /***********************************************************************
 *
 * Description : PROJ-1877
 *     not null constraint 추가
 *
 * Implementation :
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::insertNotNullConstraint"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY("qdbAlter::insertNotNullConstraint"));

    qdConstraintSpec     * sConstraint;

    // not null constraint 추가
    for ( sConstraint = aParseTree->constraints;
          sConstraint != NULL;
          sConstraint = sConstraint->next )
    {
        if ( sConstraint->constraintColumns->basicInfo->column.id ==
             aColumn->basicInfo->column.id )
        {
            IDE_TEST( qdbCommon::createConstrNotNull(
                          aStatement,
                          sConstraint,
                          aParseTree->userID,
                          aParseTree->tableInfo->tableID )
                      != IDE_SUCCESS );

            break;
        }
        else
        {
            // Nothing to do.
        }
    }

    // 반드시 추가해야 한다.
    IDE_DASSERT( sConstraint != NULL );

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::makeConvertContext( qcStatement       * aStatement,
                                     mtcColumn         * aSrcColumn,
                                     mtcColumn         * aDestColumn,
                                     qdbConvertContext * aContext )
{
 /***********************************************************************
 *
 * Description : PROJ-1877
 *
 * Implementation :
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::makeConvertContext"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY("qdbAlter::makeConvertContext"));

    UInt          sArguCount;
    mtvConvert  * sConvert = NULL;

    // 초기화
    aContext->needConvert  = ID_FALSE;
    aContext->needCanonize = ID_FALSE;
    aContext->needEncrypt  = ID_FALSE;
    aContext->needDecrypt  = ID_FALSE;

    if ( (aSrcColumn->column.flag & SMI_COLUMN_TYPE_MASK) == SMI_COLUMN_TYPE_LOB )
    {
        // lob 컬럼의 modify는 지원하지 않으므로 변경하지 않는다.
        IDE_DASSERT( aSrcColumn->type.dataTypeId == aDestColumn->type.dataTypeId );
    }
    else
    {
        if ( aSrcColumn->type.dataTypeId != aDestColumn->type.dataTypeId )
        {
            //---------------------------------------------------
            // PROJ-2002 Column Security
            //
            // a. data type의 변환은 다음과 같다.
            //   1. convert
            //   2. canonize
            // b. modify encrypt의 경우는 다음과 같다.
            //   1. encrypt column
            // c. modify decrypt의 경우는 다음과 같다.
            //   1. decrypt column
            //---------------------------------------------------

            while ( 1 )
            {
                //-----------------------------------------
                // c. modify decrypt (echar->char, evarchar->varchar)
                //-----------------------------------------

                if ( ( ( aSrcColumn->type.dataTypeId == MTD_ECHAR_ID ) &&
                       ( aDestColumn->type.dataTypeId == MTD_CHAR_ID ) )
                     ||
                     ( ( aSrcColumn->type.dataTypeId == MTD_EVARCHAR_ID ) &&
                       ( aDestColumn->type.dataTypeId == MTD_VARCHAR_ID ) ) )
                {
                    // src column id와 dest column id는 같다.
                    IDE_DASSERT( aSrcColumn->column.id == aDestColumn->column.id );
                    IDE_DASSERT( aSrcColumn->policy[0] != '\0' );

                    // decrypt시 char precision보다 더 큰 공간이 필요하다.
                    IDU_LIMITPOINT("qdbAlter::makeConvertContext::malloc1");
                    IDE_TEST( aStatement->qmxMem->alloc(
                                  aDestColumn->column.size
                                  + MTD_ECHAR_DECRYPT_BLOCK_SIZE,
                                  (void**) & aContext->encBuf )
                              != IDE_SUCCESS );

                    aContext->needDecrypt = ID_TRUE;
                    break;
                }
                else
                {
                    // Nothing to do.
                }

                //-----------------------------------------
                // b. modify encrypt (char->echar, varchar->evarchar)
                //-----------------------------------------

                if ( ( ( aSrcColumn->type.dataTypeId == MTD_CHAR_ID ) &&
                       ( aDestColumn->type.dataTypeId == MTD_ECHAR_ID ) )
                     ||
                     ( ( aSrcColumn->type.dataTypeId == MTD_VARCHAR_ID ) &&
                       ( aDestColumn->type.dataTypeId == MTD_EVARCHAR_ID ) ) )
                {
                    // src column id와 dest column id는 같다.
                    IDE_DASSERT( aSrcColumn->column.id == aDestColumn->column.id );
                    IDE_DASSERT( aDestColumn->policy[0] != '\0' );

                    // encrypt시에는 echar precision만큼의 공간이 필요하다.
                    IDU_LIMITPOINT("qdbAlter::makeConvertContext::malloc2");
                    IDE_TEST( aStatement->qmxMem->alloc(
                                  aDestColumn->column.size,
                                  (void**) & aContext->encBuf )
                              != IDE_SUCCESS );

                    aContext->needEncrypt = ID_TRUE;
                    break;
                }
                else
                {
                    // Nothing to do.
                }

                //-----------------------------------------
                // a. 일반적인 data type 변환
                //-----------------------------------------

                //-------------------------------
                // 1. conversion
                //-------------------------------

                sArguCount = aSrcColumn->flag & MTC_COLUMN_ARGUMENT_COUNT_MASK;

                IDE_TEST( mtv::estimateConvert4Server(
                              aStatement->qmxMem,
                              & sConvert,
                              aDestColumn->type,     // aDestinationType
                              aSrcColumn->type,      // aSourceType
                              sArguCount,            // aSourceArgument
                              aSrcColumn->precision, // aSourcePrecision
                              aSrcColumn->scale,     // aSourceScale
                              & QC_PRIVATE_TMPLATE(aStatement)->tmplate )  // mtcTemplate
                          // for passing session
                          // dateFormat
                          != IDE_SUCCESS );

                aContext->needConvert = ID_TRUE;
                aContext->convert = sConvert;

                //-------------------------------
                // 2. canonize
                //-------------------------------

                if ( (aDestColumn->module->flag & MTD_CANON_MASK)
                     == MTD_CANON_NEED_WITH_ALLOCATION )
                {
                    IDU_LIMITPOINT("qdbAlter::makeConvertContext::malloc3");
                    IDE_TEST( aStatement->qmxMem->alloc(
                                  aDestColumn->column.size,
                                  (void**) & aContext->canonBuf )
                              != IDE_SUCCESS );
                }
                else
                {
                    // Nothing to do.
                }

                aContext->needCanonize = ID_TRUE;

                break;
            }
        }
        else
        {
            // 동일 type인 경우

            //---------------------------------------------------
            // d. length 변환은 다음과 같다.
            //   1. canonize
            //---------------------------------------------------

            if ( ( aSrcColumn->precision != aDestColumn->precision ) ||
                 ( aSrcColumn->scale != aDestColumn->scale ) )
            {
                // length가 다른 경우 canonize가 필요하다.

                if ( (aDestColumn->module->flag & MTD_CANON_MASK)
                     == MTD_CANON_NEED_WITH_ALLOCATION )
                {
                    IDU_LIMITPOINT("qdbAlter::makeConvertContext::malloc4");
                    IDE_TEST( aStatement->qmxMem->alloc(
                                  aDestColumn->column.size,
                                  (void**) & aContext->canonBuf )
                              != IDE_SUCCESS );
                }
                else
                {
                    // Nothing to do.
                }

                aContext->needCanonize = ID_TRUE;
            }
            else
            {
                // Nothing to do.
            }
        }
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::initializeConvert( void * aInfo )
{
 /***********************************************************************
 *
 * Description : PROJ-1877
 *     하나의 record를 convert하기 위해 초기화한다.
 *
 * Implementation :
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::initializeConvert"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY("qdbAlter::initializeConvert"));

    qdbCallBackInfo  * sInfo = (qdbCallBackInfo*) aInfo;

    IDE_TEST( sInfo->qmxMem->getStatus( sInfo->qmxMemStatus )
              != IDE_SUCCESS);

    // convert context pointer를 초기화한다.
    sInfo->convertContextPtr = sInfo->convertContextList;

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::finalizeConvert( void * aInfo )
{
 /***********************************************************************
 *
 * Description : PROJ-1877
 *     하나의 record를 convert하고 finalize를 수행한다.
 *
 * Implementation :
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::finalizeConvert"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY("qdbAlter::finalizeConvert"));

    qdbCallBackInfo  * sInfo = (qdbCallBackInfo*) aInfo;

    IDE_TEST( sInfo->qmxMem->setStatus( sInfo->qmxMemStatus )
              != IDE_SUCCESS);

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::convertSmiValue( idvSQL          * /* aStatistics */,
                                  const smiColumn * aSrcColumn,
                                  const smiColumn * aDestColumn,
                                  smiValue        * aValue,
                                  void            * aInfo )
{
 /***********************************************************************
 *
 * Description : PROJ-1877
 *     convertValue는 column 마다 원하는 type으로 변환하는 함수이다.
 *
 * Implementation :
 *
 ***********************************************************************/

#define IDE_FN "qdbAlter::convertSmiValue"
    IDE_MSGLOG_FUNC(IDE_MSGLOG_BODY("qdbAlter::convertSmiValue"));

    qdbCallBackInfo   * sInfo = (qdbCallBackInfo*) aInfo;
    mtcColumn         * sSrcCol;
    mtcColumn         * sDestCol;
    UInt                sColumnOrder;
    qdbConvertContext * sConvertContext;
    mtvConvert        * sConvert;
    mtcColumn         * sValueColumn;
    void              * sValue;
    void              * sCanonizedValue;

    sSrcCol = (mtcColumn*) aSrcColumn;
    sDestCol = (mtcColumn*) aDestColumn;

    //---------------------------------------------------
    // convert context를 찾는다.
    //---------------------------------------------------

    // convertContext는 list형태로 생성되어 있는데,
    // 본 함수는 column 하나마다 호출되므로 convertContext list에서
    // 해당 column에 해당하는 convertContext를 보다 빨리 검색하기 위해
    // convertContextPtr을 사용하여 다음에 사용할 convertContext를
    // 미리 찾아둔다.
    sConvertContext = sInfo->convertContextPtr;

    sInfo->convertContextPtr = sInfo->convertContextPtr->next;

    //---------------------------------------------------
    // convert를 수행한다.
    //---------------------------------------------------

    if ( (sSrcCol->column.flag & SMI_COLUMN_TYPE_MASK) == SMI_COLUMN_TYPE_LOB )
    {
        // lob 컬럼의 modify는 지원하지 않으므로 변경하지 않는다.
        IDE_DASSERT( sSrcCol->type.dataTypeId == sDestCol->type.dataTypeId );
    }
    else
    {
        //---------------------------------------------------
        // src와 dest column의 type이 다르면 convert한다.
        //---------------------------------------------------

        if ( ( aValue->value == NULL ) && ( aValue->length == 0 ) )
        {
            // src가 variable null인 경우 dest의 null value를 사용한다.

            sColumnOrder = sDestCol->column.id & SMI_COLUMN_ID_MASK;

            aValue->value = sInfo->nullValues[sColumnOrder].value;
            aValue->length = sInfo->nullValues[sColumnOrder].length;
        }
        else
        {
            // src가 variable null이 아닌 경우

            sValueColumn = sSrcCol;
            sValue       = (void*) aValue->value;

            //-------------------------------------------------
            // type 변환이 필요한 경우 (conversion이 필요한 경우)
            //
            // a. modify decrypt의 경우
            // b. modify encrypt의 경우
            // c. data type의 변환 (canonize 포함)
            // d. length 변환 (canonize 만)
            //-------------------------------------------------

            while ( 1 )
            {
                //-----------------------------------------
                // a. modify decrypt (echar->char, evarchar->varchar)
                //-----------------------------------------

                if ( sConvertContext->needDecrypt == ID_TRUE )
                {
                    //-------------------------------
                    // 1. decrypt
                    //-------------------------------

                    IDE_DASSERT( sConvertContext->encBuf != NULL );

                    sColumnOrder = sValueColumn->column.id & SMI_COLUMN_ID_MASK;

                    IDE_TEST( qcsModule::decryptColumn(
                                  sInfo->tmplate->stmt,
                                  sInfo->tableInfo,
                                  sColumnOrder,
                                  sValueColumn,
                                  sValue,
                                  sDestCol,
                                  sConvertContext->encBuf )
                              != IDE_SUCCESS );

                    sValueColumn = sDestCol;
                    sValue       = sConvertContext->encBuf;

                    //-------------------------------
                    // 2. assign
                    //-------------------------------

                    aValue->value = sValue;
                    aValue->length =
                        sValueColumn->module->actualSize(
                            sValueColumn,
                            sValue );

                    break;
                }
                else
                {
                    // Nothing to do.
                }

                //-----------------------------------------
                // b. modify encrypt (char->echar, varchar->evarchar)
                //-----------------------------------------

                if ( sConvertContext->needEncrypt == ID_TRUE )
                {
                    //-------------------------------
                    // 1. encrypt
                    //-------------------------------

                    IDE_DASSERT( sConvertContext->encBuf != NULL );

                    sColumnOrder = sValueColumn->column.id & SMI_COLUMN_ID_MASK;

                    IDE_TEST( qcsModule::encryptColumn(
                                  sInfo->tmplate->stmt,
                                  sInfo->tableInfo,
                                  sColumnOrder,
                                  sValueColumn,
                                  sValue,
                                  sDestCol,
                                  sConvertContext->encBuf )
                              != IDE_SUCCESS );

                    sValueColumn = sDestCol;
                    sValue       = sConvertContext->encBuf;

                    //-------------------------------
                    // 2. assign
                    //-------------------------------

                    aValue->value = sValue;
                    aValue->length =
                        sValueColumn->module->actualSize(
                            sValueColumn,
                            sValue );

                    break;
                }
                else
                {
                    // Nothing to do.
                }

                //-----------------------------------------
                // c. data type 변환
                //-----------------------------------------

                if ( (sConvertContext->needConvert == ID_TRUE) &&
                     (sConvertContext->needCanonize == ID_TRUE) )
                {
                    //-------------------------------
                    // 1. conversion
                    //-------------------------------

                    IDE_DASSERT( sConvertContext->convert != NULL );

                    sConvert = sConvertContext->convert;

                    // source value pointer
                    sConvert->stack[sConvert->count].value = sValue;

                    // destination value pointer
                    sValueColumn = sConvert->stack[0].column;
                    sValue       = sConvert->stack[0].value;

                    IDE_TEST( mtv::executeConvert(
                                  sConvert,
                                  & sInfo->tmplate->tmplate )
                              != IDE_SUCCESS );

                    //-------------------------------
                    // 2. canonize
                    //-------------------------------

                    if ( ( sDestCol->module->flag & MTD_CANON_MASK )
                         == MTD_CANON_NEED )
                    {
                        sCanonizedValue = sValue;

                        IDE_TEST( sDestCol->module->canonize(
                                      sDestCol,
                                      &sCanonizedValue,  // canonized value
                                      NULL,
                                      sValueColumn,
                                      sValue,            // original value
                                      NULL,
                                      & sInfo->tmplate->tmplate )
                                  != IDE_SUCCESS );

                        sValue = sCanonizedValue;
                    }
                    else if ( (sDestCol->module->flag & MTD_CANON_MASK)
                              == MTD_CANON_NEED_WITH_ALLOCATION )
                    {
                        IDE_DASSERT( sConvertContext->canonBuf != NULL );

                        sCanonizedValue = sConvertContext->canonBuf;

                        IDE_TEST( sDestCol->module->canonize(
                                      sDestCol,
                                      &sCanonizedValue,  // canonized value
                                      NULL,
                                      sValueColumn,
                                      sValue,            // original value
                                      NULL,
                                      & sInfo->tmplate->tmplate )
                                  != IDE_SUCCESS );

                        sValue = sCanonizedValue;
                    }
                    else
                    {
                        // Nothing to do.
                    }

                    //-------------------------------
                    // 3. assign
                    //-------------------------------

                    aValue->value = sValue;
                    aValue->length =
                        sValueColumn->module->actualSize(
                            sValueColumn,
                            sValue );

                    break;
                }
                else
                {
                    // Nothing to do.
                }

                //-------------------------------------------------
                // d. length 변환이 필요한 경우 (canonize가 필요한 경우)
                //-------------------------------------------------

                if ( (sConvertContext->needConvert == ID_FALSE) &&
                     (sConvertContext->needCanonize == ID_TRUE) )
                {
                    //-------------------------------
                    // 1. canonize
                    //-------------------------------

                    if ( ( sDestCol->module->flag & MTD_CANON_MASK )
                         == MTD_CANON_NEED )
                    {
                        sCanonizedValue = sValue;

                        IDE_TEST( sDestCol->module->canonize(
                                      sDestCol,
                                      &sCanonizedValue,  // canonized value
                                      NULL,
                                      sValueColumn,
                                      sValue,            // original value
                                      NULL,
                                      & sInfo->tmplate->tmplate )
                                  != IDE_SUCCESS );

                        sValue = sCanonizedValue;
                    }
                    else if ( (sDestCol->module->flag & MTD_CANON_MASK)
                              == MTD_CANON_NEED_WITH_ALLOCATION )
                    {
                        IDE_DASSERT( sConvertContext->canonBuf != NULL );

                        sCanonizedValue = sConvertContext->canonBuf;

                        IDE_TEST( sDestCol->module->canonize(
                                      sDestCol,
                                      &sCanonizedValue,  // canonized value
                                      NULL,
                                      sValueColumn,
                                      sValue,            // original value
                                      NULL,
                                      & sInfo->tmplate->tmplate )
                                  != IDE_SUCCESS );

                        sValue = sCanonizedValue;
                    }
                    else
                    {
                        // Nothing to do.
                    }

                    //-------------------------------
                    // 2. assign
                    //-------------------------------

                    aValue->value = sValue;
                    aValue->length =
                        sValueColumn->module->actualSize(
                            sValueColumn,
                            sValue );

                    break;
                }
                else
                {
                    // Noting to do.
                }

                /* BUG-43117 : variable 컬럼의 패딩으로 인하여 패딩 추가로 인하여
                 * converted value size가 dest value size 보다 커지기 때문에
                 * mtcColumn의 실제 사이즈로 value 길이를 맞춤
                 */ 
                if ( ( (sDestCol->column.flag & SMI_COLUMN_TYPE_MASK)
                       == SMI_COLUMN_TYPE_VARIABLE) &&
                     ( (sDestCol->column.flag & SMI_COLUMN_COMPRESSION_MASK)
                       != SMI_COLUMN_COMPRESSION_TRUE) )
                {
                    aValue->value = sValue;
                    aValue->length =
                        sValueColumn->module->actualSize(
                            sValueColumn,
                            sValue );

                    break;
                }
                else 
                {
                    // Nothing to do.
                }

                //-------------------------------------------------
                // 그대로 복사하는 경우
                //-------------------------------------------------

                break;
            }
        }

        // converted value가 dest column size 보다 작아야 한다.
        IDE_DASSERT( aValue->length <= sDestCol->column.size );
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;

#undef IDE_FN
}

IDE_RC qdbAlter::decideAddColExeMethod( qcStatement      * aStatement,
                                        qdTableParseTree * aParseTree,
                                        idBool           * aRecreateTable )
{
 /***********************************************************************
 *
 * Description : add column 수행 방법 결정
 *
 * Implementation :
 *    아래 조건들을 만족하면 column 정보 변경만 수행하고,
 *    그렇지 않을 경우에는 (drop table & create table)로 수행
 *
 *    [Memory/Volatile Table]
 *    Variable Column이어야 한다.
 *        - 실제로 저장할 곳이 Variable Slot이어야 한다.
 *
 *    LOB을 지원하지 않는다.
 *        - LOB은 Fixed Slot에 저장한다.
 *
 *    Large Variable Column을 지원하지 않는다.
 *        - Large Variable Column은 Fixed Slot에 저장한다.
 *        - CHAR/VARCHAR 최대 크기를 초과해야 하므로, GEOMETRY에만 적용된다.
 *
 *    Compressed Column을 지원하지 않는다.
 *        - Compressed Column의 smOID를 Fixed Slot에 저장한다.
 *
 *    [Disk Table]
 *
 *    [공통]
 *    Trailing Null이어야 한다.
 *        - Default Value를 지정하지 않았거나 NULL어이야 한다.
 *        - NOT NULL 속성이 없어야 한다.
 *        - CHECK 속성이 없어야 한다.
 *            - CHECK로 NOT NULL을 지정할 수 있다.
 *        - Hidden Column이 아니어야 한다.
 *            - Function-Based Index를 Hidden Column으로 구현하는데, Default Value를 사용한다.
 *        - PRIMARY KEY, UNIQUE, LOCAL UNIQUE 속성이 없어야 한다.
 *            - Index는 Trailing Null을 지원하지 않는다.
 *        - Timestamp Type이 아니어야 한다.
 *            - Timestamp는 Default Value를 지정하지 않아도, Default Value가 있는 것처럼 동작한다.
 *
 ***********************************************************************/

    idBool                 sModifyColumnInfo = ID_FALSE;
    qcmColumn            * sCurColumn        = NULL;
    qdConstraintSpec     * sCurConstr        = NULL;
    void                 * sValue            = NULL;
    mtcColumn            * sValueColumn      = NULL;

    qcmPartitionInfoList * sPartInfoList     = NULL;
    SInt                   sCountDskType     = 0;
    SInt                   sCountMemType     = 0;
    SInt                   sCountVolType     = 0;
    UInt                   sTableType        = 0;

    qcmPartitionInfoList * sCurPartInfoList  = NULL;
    qdPartitionAttribute * sCurPartAttr      = NULL;
    qcmColumn            * sAddColumns       = NULL;
    UInt                   sPartType         = 0;

    sTableType = aParseTree->tableInfo->tableFlag & SMI_TABLE_TYPE_MASK;
    
    while ( 1 )
    {
        /* PROJ-2464 hybrid partitioned table 지원
         *  - HPT 인 경우에, Memory, Disk 매체를 모두 지닐 수 있다.
         */
        if ( aParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
        {
            sPartInfoList = aParseTree->partTable->partInfoList;
        }
        else
        {
            /* Nothing to do */
        }

        qdbCommon::getTableTypeCountInPartInfoList( & sTableType,
                                                    sPartInfoList,
                                                    & sCountDskType,
                                                    & sCountMemType,
                                                    & sCountVolType );

        //--------------------------------
        // Memory Table에 대한 추가적인 검사
        //--------------------------------

        /* BUG-43124 Memory Table에 실시간 Add (Variable) Column 지원 */
        if ( ( sCountMemType + sCountVolType ) > 0 )
        {
            if ( sTableType != SMI_TABLE_DISK )
            {
                sAddColumns = aParseTree->columns;
            }
            else
            {
                for ( sCurPartInfoList = aParseTree->partTable->partInfoList,
                          sCurPartAttr = aParseTree->partTable->partAttr;
                      sCurPartInfoList != NULL;
                      sCurPartInfoList = sCurPartInfoList->next,
                          sCurPartAttr = sCurPartAttr->next )
                {
                    sPartType = sCurPartInfoList->partitionInfo->tableFlag & SMI_TABLE_TYPE_MASK;

                    if ( sPartType != SMI_TABLE_DISK )
                    {
                        sAddColumns = sCurPartAttr->columns;
                        break;
                    }
                    else
                    {
                        /* Nothing to do */
                    }
                }
            }

            for ( sCurColumn = sAddColumns;
                  sCurColumn != NULL;
                  sCurColumn = sCurColumn->next )
            {
                if ( ( sCurColumn->basicInfo->column.flag & SMI_COLUMN_TYPE_MASK )
                     == SMI_COLUMN_TYPE_VARIABLE )
                {
                    /* Variable Column이어야 한다.
                     *   - 실제로 저장할 곳이 Variable Slot이어야 한다.
                     */
                }
                else
                {
                    /* Large Variable Column을 지원하지 않는다.
                     *   - Large Variable Column은 Fixed Slot에 저장한다.
                     *   - CHAR/VARCHAR 최대 크기를 초과해야 하므로, GEOMETRY에만 적용된다.
                     */
                    /* LOB을 지원하지 않는다.
                     *   - LOB은 Fixed Slot에 저장한다.
                     */
                    break;
                }
            }

            if ( sCurColumn != NULL )
            {
                break;
            }
            else
            {
                /* Nothing to do */
            }

            /* Compressed Column을 지원하지 않는다.
             *   - Compressed Column의 smOID를 Fixed Slot에 저장한다.
             */
            if ( aParseTree->compressionColumn != NULL )
            {
                break;
            }
            else
            {
                /* Nothing to do */
            }
        }
        else
        {
            /* Nothing to do */
        }

        //--------------------------------
        // hidden column이 있는지 검사
        //--------------------------------

        if ( aParseTree->addHiddenColumn == ID_TRUE )
        {
            // hidden column의 add는 default expr을 채워야하므로
            // alter meta로는 불가능하다.
            break;
        }
        else
        {
            // Nothing to do.
        }

        //--------------------------------
        // default value가 NULL 인지 검사
        //--------------------------------

        for ( sCurColumn = aParseTree->columns;
              sCurColumn != NULL;
              sCurColumn = sCurColumn->next )
        {
            if ( sCurColumn->defaultValue != NULL )
            {
                // 앞서 검사했으므로 add columns에 hidden column이 나올 수 없다.
                IDE_DASSERT( ( sCurColumn->flag & QCM_COLUMN_HIDDEN_COLUMN_MASK)
                             == QCM_COLUMN_HIDDEN_COLUMN_FALSE );
                
                // default value를 명시한 경우
                IDE_TEST(qtc::calculate( sCurColumn->defaultValue,
                                         QC_PRIVATE_TMPLATE(aStatement))
                         != IDE_SUCCESS);

                sValue =
                    QC_PRIVATE_TMPLATE(aStatement)->tmplate.stack[0].value;

                sValueColumn =
                    QC_PRIVATE_TMPLATE(aStatement)->tmplate.stack[0].column;

                if ( sValueColumn->module->isNull( sValueColumn,
                                                   sValue )
                     != ID_TRUE )
                {
                    // default value가 NULL이 아닌 경우
                    // 중단
                    break;
                }
                else
                {
                    // default value가 NULL인 경우
                    // 다음 조건 검사
                }
            }
            else
            {
                // default value를 명시하지 않은 경우
                // default value는 NULL 이므로,
                // 다음 column 검사
            }
        }

        if ( sCurColumn != NULL )
        {
            // default value가 NULL 이 아닌 column이 존재하는 경우,
            // 실시간 add column 할 수 없음
            break;
        }
        else
        {
            // 다음 제약 사항 검사
        }

        //--------------------------------
        // PRIMARY KEY, UNIQUE, LOCAL UNIQUE, NOT NULL, CHECK 속성을 가질수 없음
        //--------------------------------

        for ( sCurConstr = aParseTree->constraints;
              sCurConstr != NULL;
              sCurConstr = sCurConstr->next )
        {
            if ( ( sCurConstr->constrType == QD_PRIMARYKEY )   ||
                 ( sCurConstr->constrType == QD_UNIQUE )       ||
                 ( sCurConstr->constrType == QD_LOCAL_UNIQUE ) ||
                 ( sCurConstr->constrType == QD_NOT_NULL )     ||
                 ( sCurConstr->constrType == QD_CHECK ) ) /* PROJ-1107 Check Constraint 지원 */
            {
                // Primary key, unique, local unique는 index가
                // 실시간으로 할 수 없기 때문에 실시간 add column이 안됨
                // default value는 NULL 이어야만 실시간으로
                // 가능하기 때문에 NOT NULL 이면 실시간 add column이 안됨
                // CHECK는 NOT NULL을 포함할 수 있기 때문에, CHECK이면 실시간 add column이 안됨
                break;
            }
            else
            {
                // 다음 constraint 검사
            }
        }

        if ( sCurConstr != NULL )
        {
            // 위 constraint type이 하나라도 존재하는 경우에는
            // 실시간 add column 할 수 없음
            break;
        }
        else
        {
            // nothing to do
        }

        //------------------------------------------------------------
        // timestamp 컬럼인지 검사
        //------------------------------------------------------------

        for ( sCurColumn = aParseTree->columns;
              sCurColumn != NULL;
              sCurColumn = sCurColumn->next )
        {
            if ( ( sCurColumn->basicInfo->flag & MTC_COLUMN_TIMESTAMP_MASK )
                   == MTC_COLUMN_TIMESTAMP_TRUE )
            {
                break;
            }
            else
            {
                // nothing to do
            }
        }

        if ( sCurColumn != NULL )
        {
            // timestamp 컬럼은 항상 default value가 있으므로
            // 실시간 add column 할 수 없음
            break;
        }
        else
        {
            // nothing to do
        }

        sModifyColumnInfo = ID_TRUE;
        break;
    }

    if ( sModifyColumnInfo == ID_TRUE )
    {
        *aRecreateTable = ID_FALSE;
    }
    else
    {
        *aRecreateTable = ID_TRUE;
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::alterColumnInfo4AddCol(
    qcStatement       * aStatement,
    qdTableParseTree  * aParseTree,
    UInt                aAddColCnt,
    idBool              aIsPartitioned,
    UInt                aPartitionCnt,
    UInt              * aPartitionID,
    qcmColumn         * aNewTableColumn,
    mtcColumn         * aNewTableMtcColumn,
    qcmColumn        ** aNewPartitionColumn,
    mtcColumn        ** aNewPartitionMtcColumn )
{
/***********************************************************************
 *
 * Description : Column 정보 변경
 *
 * Implementation :
 *    Table 과 각 partition에 대하여 아래 과정을 수행
 *    (1) Table Header의 column list와 column count 변경
 *    (2) SYS_TABLES_ Meta Table에서 해당 table의 column count 정보 변경
 *    (3) SYS_COLUMNS_ Meta Table에 column spec을 추가
 *
 ***********************************************************************/

    qcmTableInfo          * sTableInfo = NULL;
    qdPartitionedTable    * sPartTable = NULL;
    UInt                    sOldColCnt;
    UInt                    sTotalColCnt;
    qcmColumn             * sNewColumnAdded = NULL;
    smOID                   sTableOID;
    UInt                    sTableID;
    qcmPartitionInfoList  * sCurPartInfo  = NULL;
    qdConstraintSpec      * sConstraint = NULL;
    UInt                    sParallelDegree;
    UInt                    i;

    //-----------------
    // 지역 변수 초기화
    //-----------------

    sTableInfo   = aParseTree->tableInfo;
    sPartTable   = aParseTree->partTable;
    sOldColCnt   = aParseTree->tableInfo->columnCount;
    sTotalColCnt = aAddColCnt + sOldColCnt;
    sTableOID    = smiGetTableId(aParseTree->tableHandle);
    sTableID     = sTableInfo->tableID;

    // PROJ-1071 Parallel query
    sParallelDegree = sTableInfo->parallelDegree;

    //---------------------------
    // Table의 Column 정보 변경
    //---------------------------

    //  (1) Table Header의 column list와 column count 변경
    IDE_TEST( alterTableHeaderColumnList( aStatement,
                                          sTableInfo->tableHandle,
                                          sTotalColCnt,
                                          aNewTableMtcColumn )
              != IDE_SUCCESS );

    // (2) SYS_TABLES_ Meta Table에서 해당 table의 column count 정보 변경
    IDE_TEST(qdbCommon::updateTableSpecFromMeta( aStatement,
                                                 aParseTree->userName,
                                                 aParseTree->tableName,
                                                 sTableID,
                                                 sTableOID,
                                                 sTotalColCnt,
                                                 sParallelDegree )
             != IDE_SUCCESS);

    // (3) SYS_COLUMNS_ Meta Table에 column spec을 추가
    IDE_TEST(deleteColumnSpecFromMeta(aStatement, sTableID)
             != IDE_SUCCESS);

    IDE_TEST( qdbCommon::insertColumnSpecIntoMeta( aStatement,
                                                   aParseTree->userID,
                                                   sTableID,
                                                   aNewTableColumn,
                                                   ID_FALSE /* is queue */)
              != IDE_SUCCESS);

    // (4) 새로운 column에 대한 costraint 생성
    for (sConstraint = aParseTree->constraints;
         sConstraint != NULL;
         sConstraint = sConstraint->next)
    {
        sNewColumnAdded = &aNewTableColumn[sOldColCnt];
        while (sNewColumnAdded != NULL)
        {
            if ( QC_IS_NAME_MATCHED( sNewColumnAdded->namePos, sConstraint->constraintColumns->namePos ) )
            {
                break;
            }
            else
            {
                sNewColumnAdded = sNewColumnAdded->next;
            }
        }

        if ( sNewColumnAdded != NULL )
        {
            sConstraint->constraintColumns->basicInfo =
                sNewColumnAdded->basicInfo;

            IDE_TEST(qdbCommon::createConstrTimeStamp(aStatement,
                                                      sConstraint,
                                                      aParseTree->userID,
                                                      sTableID)
                     != IDE_SUCCESS);

            IDE_TEST(qdbCommon::createConstrForeign(aStatement,
                                                    sConstraint,
                                                    aParseTree->userID,
                                                    sTableID)
                     != IDE_SUCCESS);
        }
        else
        {
            IDE_DASSERT(0);
        }
    }

    //---------------------------
    // Partition
    //---------------------------

    if( aIsPartitioned == ID_TRUE )
    {
        // BUG-28356
        // Table관련 Lob spec을 한꺼번에 meta로 부터 삭제
        IDE_TEST(deletePartLobSpecFromMeta(aStatement, sTableID)
                     != IDE_SUCCESS);

        // 테이블 파티션 개수만큼 반복
        // sPartAttr의 리스트 개수는 파티션 개수와 동일하다.
        for( sCurPartInfo = sPartTable->partInfoList, i = 0;
             sCurPartInfo != NULL;
             sCurPartInfo = sCurPartInfo->next, i++ )
        {

            // (1) Parition Header의 column list와 column count 변경
            IDE_TEST( alterTableHeaderColumnList( aStatement,
                                                  sCurPartInfo->partHandle,
                                                  sTotalColCnt,
                                                  aNewPartitionMtcColumn[i] )
                      != IDE_SUCCESS );
        }

        // (2) SYS_COLUMNS_ Meta Table에 column spec을 추가
        for( i = 0; i < aPartitionCnt; i++ )
        {

            IDE_TEST(
                qdbCommon::insertPartLobSpecIntoMeta(
                    aStatement,
                    aParseTree->userID,
                    sTableID,
                    aPartitionID[i],
                    aNewPartitionColumn[i])
                != IDE_SUCCESS);
        }
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::alterTableHeaderColumnList( qcStatement * aStatement,
                                             void        * aTableHandle,
                                             UInt          aTotalColCnt,
                                             mtcColumn   * aNewMtcColumn )
{
/***********************************************************************
 *
 * Description : Table Header의 column list와 column count를 변경
 *
 * Implementation :
 *    (1) 새로운 column list를 smiColumn list 형태로 변환
 *    (2) Table Header의 column list와 column count 변경
 *
 ***********************************************************************/

    smiColumnList * sSmiColumnList = NULL;
    mtcColumn     * sColumn;
    UInt            i;
    UShort          sMaxAlign = 0;

    // 새로운 column list를 smiColumn 형의 list 형태로 변환
    IDU_LIMITPOINT("qdbAlter::alterTableHeaderColumnList::malloc1");
    IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(smiColumnList) * aTotalColCnt,
                                       (void**)&sSmiColumnList)
             != IDE_SUCCESS);

    IDU_LIMITPOINT("qdbAlter::alterTableHeaderColumnList::malloc2");
    IDE_TEST(aStatement->qmxMem->alloc(ID_SIZEOF(mtcColumn) * aTotalColCnt,
                                       (void**)&sColumn)
             != IDE_SUCCESS);

    for ( i = 0; i < aTotalColCnt; i++ )
    {
        idlOS::memcpy(&sColumn[i], &aNewMtcColumn[i], ID_SIZEOF(mtcColumn));

        sSmiColumnList[i].column = (const smiColumn*)&sColumn[i];

        if ( (sColumn[i].column.flag & SMI_COLUMN_TYPE_MASK )
             == SMI_COLUMN_TYPE_VARIABLE )
        {
            sMaxAlign = IDL_MAX( sMaxAlign, (UShort)sColumn[i].module->align );
        }
        else
        {
            // Nothing to do.
        }

        // BUG-43117 : smiColumn에 align값 입력
        ((smiColumn*)&sColumn[i])->align = sColumn[i].module->align;

        if (i == aTotalColCnt -1)
        {
            sSmiColumnList[i].next = NULL;
        }
        else
        {
            sSmiColumnList[i].next = &sSmiColumnList[i+1];
        }
    }

    /* BUG-43287 Variable column 들의 Align 중 가장 큰 값을 기록해 둔다. */
    for ( i = 0; i < aTotalColCnt; i++ )
    {
        sColumn[i].column.maxAlign = sMaxAlign;
    }

    if ( sSmiColumnList == NULL )
    {
        IDE_DASSERT(0);
    }

    // (2) Table Header의 column list와 column count 변경
    IDE_TEST(smiTable::modifyTableInfo(QC_SMI_STMT( aStatement ),
                                       aTableHandle,
                                       sSmiColumnList,
                                       ID_SIZEOF(mtcColumn),
                                       NULL,
                                       0,
                                       SMI_TABLE_FLAG_UNCHANGE,
                                       SMI_TBSLV_DDL_DML)
             != IDE_SUCCESS);

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::calculateSmiValueArray( smiValue * aValueArr,
                                         void     * aInfo )
{
/***********************************************************************
 *
 * Description :
 *    Function-based Index를 생성할 때 Column을 추가하는데,
 *    추가 Column에 들어갈 값을 계산한다.
 *
 * Implementation :
 *
 ***********************************************************************/

    qdbCallBackInfo   * sInfo = (qdbCallBackInfo *)aInfo;
    idBool              sIsDisk;

    if ( sInfo->hasDefaultExpr == ID_TRUE )
    {
        if ( ( sInfo->srcColumns->basicInfo->column.flag & SMI_COLUMN_STORAGE_MASK )
                                                        == SMI_COLUMN_STORAGE_DISK )
        {
            sIsDisk = ID_TRUE;
        }
        else
        {
            sIsDisk = ID_FALSE;
        }

        /* smiValue 배열을 calculate할 수 있는 형태로 만든다. */
        IDE_TEST( qmsDefaultExpr::setRowBufferFromSmiValueArray(
                      &(sInfo->tmplate->tmplate),
                      sInfo->srcTableRef,
                      sInfo->tableInfo->columns,
                      sInfo->rowBuffer,
                      aValueArr,
                      sIsDisk )
                  != IDE_SUCCESS );

        /* calculate하여 smiValue배열에 설정한다. */
        IDE_TEST( qmsDefaultExpr::calculateDefaultExpression(
                      sInfo->tmplate,
                      sInfo->srcTableRef,
                      NULL,
                      sInfo->dstTblColumn,
                      sInfo->rowBuffer,
                      aValueArr,
                      sInfo->dstColumns )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    // default value with sequence 계산
    IDE_TEST( qdbCommon::calculateDefaultValueWithSequence(
                  sInfo->statement,
                  sInfo->tableInfo,
                  sInfo->srcColumns,
                  sInfo->dstColumns,
                  aValueArr )
              != IDE_SUCCESS );
            
    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::printProgressLog( void  * aInfo,
                                   idBool  aIsProgressComplete )
{
/***********************************************************************
 *
 * Description : BUG-42920 DDL print data move progress
 *       add column
 *       modify column
 *       drop column
 *       reorganize column
 *   데이터의 진행률을 나타낸다.
 *
 * Implementation :
 *
 ***********************************************************************/

    qdbCallBackInfo   * sInfo = (qdbCallBackInfo *)aInfo;
    
    IDE_TEST( qdbAlter::printProgressLog4Partition( sInfo->tableInfo,
                                                    sInfo->partitionInfo,
                                                    &sInfo->progressRows,
                                                    aIsProgressComplete )
              != IDE_SUCCESS );
        
    return IDE_SUCCESS;
    
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
    
}

IDE_RC qdbAlter::printProgressLog4Partition( qcmTableInfo * aTableInfo,
                                             qcmTableInfo * aPartitionInfo,
                                             ULong        * aProgressCnt,
                                             idBool         aIsProgressComplete )
{
/***********************************************************************
 *
 * Description : BUG-42920 DDL print data move progress
 *      partition split
 *      partition merge
 *      partition add
 *      partition coalesce
 *      alter tablespace
 *      alter partition tablespace
 *   데이터의 진행률을 나타낸다.
 *      
 * Implementation :
 *
 ***********************************************************************/

    if ( aIsProgressComplete == ID_TRUE )
    {
        if ( aTableInfo->tablePartitionType == QCM_NONE_PARTITIONED_TABLE )
        {
            ideLog::log( IDE_QP_2,
                         "[ TABLE : \"%s\".\"%s\" | ROWS MOVED : %"ID_UINT64_FMT" ]",
                         aTableInfo->tableOwnerName,
                         aTableInfo->name,
                         *aProgressCnt );
        }
        else
        {
            ideLog::log( IDE_QP_2,
                         "[ TABLE : \"%s\".\"%s\" | PARTITION : \"%s\" | ROWS MOVED : %"ID_UINT64_FMT" ]",
                         aTableInfo->tableOwnerName,
                         aTableInfo->name,
                         aPartitionInfo->name,
                         *aProgressCnt );
        }

        // outplace merge, add partition, coalesce partition
        // partition table 마다 진행율을 나타내야 하므로 초기화 한다.
        *aProgressCnt = 0;
    }
    else
    {
        if ( ( *aProgressCnt != 0 ) && ( ( *aProgressCnt %  QDB_PROGRESS_ROWS_COUNT ) == 0 ) )
        {
            if ( aTableInfo->tablePartitionType == QCM_NONE_PARTITIONED_TABLE )
            {
                ideLog::log( IDE_QP_2,
                             "[ TABLE : \"%s\".\"%s\" | ROWS MOVED : %"ID_UINT64_FMT" ]",
                             aTableInfo->tableOwnerName,
                             aTableInfo->name,
                             *aProgressCnt );
            }
            else
            {
                ideLog::log( IDE_QP_2,
                             "[ TABLE : \"%s\".\"%s\" | PARTITION : \"%s\" | ROWS MOVED : %"ID_UINT64_FMT" ]",
                             aTableInfo->tableOwnerName,
                             aTableInfo->name,
                             aPartitionInfo->name,
                             *aProgressCnt );
            }
        }
        else
        {
            // nothing to do 
        }

        (*aProgressCnt)++;
    }
    
    return IDE_SUCCESS;
}

IDE_RC qdbAlter::renameColumnInDefaultExpression(
    qcStatement  * aStatement,
    qcmColumn    * aDefaultExpressionColumns,
    qcmColumn    * aOldColumn,
    qcmColumn    * aNewColumn )
{
/***********************************************************************
 *
 * Description :
 *    모든 Default Expression의 Column Name을 변경한다.
 *
 * Implementation :
 *    1. 새로운 Column Name으로 변경한 Default Expression을 구한다.
 *    2. SYS_COLUMNS_ 메타 테이블의 DEFAULT_VAL 컬럼을 변경한다.
 *
 ***********************************************************************/

    qcmColumn     * sColumn;
    SChar         * sNewExpressionStr = NULL;

    for ( sColumn = aDefaultExpressionColumns;
          sColumn != NULL;
          sColumn = sColumn->next )
    {
        if ( sColumn->defaultValue == NULL )
        {
            continue;
        }
        else
        {
            /* Nothing to do */
        }

        IDE_TEST( qdnCheck::renameColumnInExpression(
                      aStatement,
                      &sNewExpressionStr,
                      sColumn->defaultValue,
                      aOldColumn->namePos,
                      aNewColumn->namePos )
                  != IDE_SUCCESS );

        sColumn->defaultValueStr = (UChar *)sNewExpressionStr;
    }

    if ( aDefaultExpressionColumns != NULL )
    {
        IDE_TEST( updateColumnSpecDefault(
                      aStatement,
                      aDefaultExpressionColumns )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::recreateTableForReorganize( qcStatement       * aStatement,     /* in  */
                                             qdTableParseTree  * aParseTree,     /* in  */
                                             smOID             * aNewTableOID,   /* out */
                                             qcmTableInfo     ** aNewTableInfo ) /* out */
{
/***********************************************************************
 *
 * Description :
 *    BUG-44230 ADD, DROP, MODIFY, REORGANIZE DDL의 INDEX, CONSTRAINT 생성 순서 변경
 *     - PROJ-2264 Dictionary table 의 함수의 처리를 3개로 나누었다.
 *        1) recreateTableForReorganize 함수 수정
 *        2) moveRow 상위 함수로 옮김
 *        3) recreateIndexForReorganize 함수 생성
 *
 * Implementation :
 *
 *    1. 새로운 Column 정보 구축
 *      1.1. qcmColumn deep copy
 *      1.2. dictionary table OID 를 복사한다.
 *    2. 새로운 Table 생성
 *    3. update table spec (tableOID)
 *    4. Meta Cache( Table Header에 저장된 qcmTableInfo ) 재구성
 *    5. 새로 생성한 Table의 OID와 Info를 반환
 *
 ************************************************************************/

    qcmTableInfo * sOldTableInfo   = NULL;
    qcmTableInfo * sNewTableInfo   = NULL;
    qcmColumn    * sColumn         = NULL;
    qcmColumn    * sPrev           = NULL;
    qcmColumn    * sReorgColumn    = NULL;
    qcmColumn    * sNewColumns     = NULL;
    mtcColumn    * sMtcColumns     = NULL;
    void         * sNewTableHandle = NULL;
    smOID          sNewTableOID;
    smSCN          sSCN;
    UInt           sTableID;
    UInt           i;

    sTableID        = aParseTree->tableInfo->tableID;
    sOldTableInfo   = aParseTree->tableInfo;

    /* 1. 새로운 Column 정보 구축 */
    IDU_FIT_POINT( "qdbAlter::recreateTableForReorganize::alloc::sNewColumns",
                   idERR_ABORT_InsufficientMemory );
    IDE_TEST( aStatement->qmxMem->alloc( ID_SIZEOF( qcmColumn ) * sOldTableInfo->columnCount,
                                         (void**)& sNewColumns )
              != IDE_SUCCESS );

    IDU_FIT_POINT( "qdbAlter::recreateTableForReorganize::alloc::sMtcColumns",
                   idERR_ABORT_InsufficientMemory );
    IDE_TEST( aStatement->qmxMem->alloc( ID_SIZEOF( mtcColumn ) * sOldTableInfo->columnCount,
                                         (void**)& sMtcColumns )
              != IDE_SUCCESS );

    for ( sColumn  = sOldTableInfo->columns, i = 0;
          sColumn != NULL;
          sColumn  = sColumn->next, i++ )
    {
        /* 1.1. qcmColumn deep copy */
        idlOS::memcpy( &(sNewColumns[i]), sColumn, ID_SIZEOF(qcmColumn) );
        idlOS::memcpy( &(sMtcColumns[i]), sColumn->basicInfo, ID_SIZEOF(mtcColumn) );
        sNewColumns[i].basicInfo = &(sMtcColumns[i]);
        sNewColumns[i].next      = NULL;
        
        /*      Parse tree 에 달린 columns 는 reorganize 대상 컬럼이다.
         *      recreateDictionaryTable 함수에서 columns 에 new dictionary
         *      table OID 를 달아 놓았으므로 reorganize 대상 컬럼이라면
         * 1.2. dictionary table OID 를 복사한다.
         */
        sReorgColumn = aParseTree->columns;

        while ( sReorgColumn != NULL )
        {
            if ( idlOS::strMatch( sColumn->name,
                                  idlOS::strlen( sColumn->name ),
                                  sReorgColumn->name,
                                  idlOS::strlen( sReorgColumn->name ) ) == 0 )
            {
                sNewColumns[i].basicInfo->column.mDictionaryTableOID
                    = sReorgColumn->basicInfo->column.mDictionaryTableOID;
                break;
            }
            else
            {
                sReorgColumn = sReorgColumn->next;
            }
        }

        if ( sPrev == NULL )
        {
            sPrev       = &(sNewColumns[i]);
        }
        else
        {
            sPrev->next = &(sNewColumns[i]);
            sPrev       = sPrev->next;
        }
    }

    /* 2. 새로운 table 생성 */
    IDE_TEST( qdbCommon::createTableOnSM( aStatement,
                                          sNewColumns, /* sOldTableInfo->columns, aNewTableColumn, */
                                          sOldTableInfo->tableOwnerID,
                                          sTableID,
                                          sOldTableInfo->maxrows,
                                          sOldTableInfo->TBSID,
                                          sOldTableInfo->segAttr,
                                          sOldTableInfo->segStoAttr,
                                          /* 원본 Table Flag를 통째로 복사 =>
                                             MASK 비트를 를 모두 1로 설정 */
                                          QDB_TABLE_ATTR_MASK_ALL,
                                          sOldTableInfo->tableFlag, /* Flag Value */
                                          sOldTableInfo->parallelDegree,
                                          & sNewTableOID )
             != IDE_SUCCESS );

    // BUG-44814 ddl 구문 수행시 통계정보 복사를 해야함
    smiStatistics::copyTableStats( smiGetTable(sNewTableOID), sOldTableInfo->tableHandle, NULL, 0 );
    
    /* 3. update table spec (tableOID) */
    IDE_TEST( qdbCommon::updateTableSpecFromMeta( aStatement,
                                                  aParseTree->userName,
                                                  aParseTree->tableName,
                                                  sTableID,
                                                  sNewTableOID,
                                                  sOldTableInfo->columnCount,
                                                  sOldTableInfo->parallelDegree )
              != IDE_SUCCESS );

    /* 4. Meta Cache( Table Header에 저장된 qcmTableInfo ) 재구성 */
    IDE_TEST( qcm::makeAndSetQcmTableInfo( QC_SMI_STMT( aStatement ),
                                          sTableID,
                                          sNewTableOID )
              != IDE_SUCCESS );

    IDE_TEST( qcm::getTableInfoByID( aStatement,
                                     sTableID,
                                     & sNewTableInfo,
                                     & sSCN,
                                     & sNewTableHandle )
             != IDE_SUCCESS );

    /* 5. 새로 생성한 Table의 OID와 Info를 반환 */
    *aNewTableOID  = sNewTableOID;
    *aNewTableInfo = sNewTableInfo;

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    /* cleanup new table info */
    (void)qcm::destroyQcmTableInfo( sNewTableInfo );

    return IDE_FAILURE;
}

IDE_RC qdbAlter::updateTableAccessOption( qcStatement          * aStatement,
                                          UInt                   aTableID,
                                          qcmAccessOption        aAccessOption )
{
/***********************************************************************
 *
 * Description :
 *      PROJ-2359 Table/Partition Access Option
 *
 *      SYS_TABLES_ 메타 테이블의 ACCESS를 업데이트한다.
 *
 * Implementation :
 *
 ***********************************************************************/

    SChar                 * sSqlStr;
    SChar                   sAccessOptionStr[2];
    idBool                  sNeedToUpdate = ID_TRUE;
    vSLong                  sRowCnt;

    switch ( aAccessOption )
    {
        case QCM_ACCESS_OPTION_READ_ONLY :
            sAccessOptionStr[0] = 'R';
            sAccessOptionStr[1] = '\0';
            break;

        case QCM_ACCESS_OPTION_READ_WRITE :
            sAccessOptionStr[0] = 'W';
            sAccessOptionStr[1] = '\0';
            break;

        case QCM_ACCESS_OPTION_READ_APPEND :
            sAccessOptionStr[0] = 'A';
            sAccessOptionStr[1] = '\0';
            break;

        default : /* QCM_ACCESS_OPTION_NONE */
            sNeedToUpdate = ID_FALSE;
            break;
    }

    if ( sNeedToUpdate == ID_TRUE )
    {
        IDU_FIT_POINT( "qdbAlter::updateTableAccessOption::malloc::sSqlStr",
                        idERR_ABORT_InsufficientMemory );

        IDE_TEST( STRUCT_ALLOC_WITH_SIZE( aStatement->qmxMem,
                                          SChar,
                                          QD_MAX_SQL_LENGTH,
                                          &sSqlStr )
                  != IDE_SUCCESS);

        idlOS::snprintf( sSqlStr, QD_MAX_SQL_LENGTH,
                         "UPDATE SYS_TABLES_ "
                         "SET ACCESS = CHAR'%s' "
                         "WHERE TABLE_ID = INTEGER'%"ID_INT32_FMT"' ",
                         sAccessOptionStr,
                         aTableID );

        IDE_TEST( qcg::runDMLforDDL( QC_SMI_STMT( aStatement ),
                                     sSqlStr,
                                     & sRowCnt )
                  != IDE_SUCCESS );

        IDE_TEST_RAISE( sRowCnt != 1, ERR_META_CRASH );
    }
    else
    {
        /* Nothing to do */
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_META_CRASH )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QCM_META_CRASH ) );
    }

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::updatePartAccessOfTablePartMeta( qcStatement          * aStatement,
                                                  UInt                   aPartitionID,
                                                  qcmAccessOption        aAccessOption )
{
/***********************************************************************
 *
 * Description :
 *      PROJ-2359 Table/Partition Access Option
 *
 *      SYS_TABLE_PARTITIONS_ 메타 테이블의
 *      PARTITION_ACCESS를 업데이트한다.
 *
 *      qdbAlter::executeSplitPartition, qdbAlter::executeMergePartition,
 *      qdbAlter::executeAccessPartition에 의해 호출된다.
 *
 * Implementation :
 *
 ***********************************************************************/

    SChar                 * sSqlStr;
    SChar                   sAccessOptionStr[2];
    idBool                  sNeedToUpdate = ID_TRUE;
    vSLong                  sRowCnt;

    switch ( aAccessOption )
    {
        case QCM_ACCESS_OPTION_READ_ONLY :
            sAccessOptionStr[0] = 'R';
            sAccessOptionStr[1] = '\0';
            break;

        case QCM_ACCESS_OPTION_READ_WRITE :
            sAccessOptionStr[0] = 'W';
            sAccessOptionStr[1] = '\0';
            break;

        case QCM_ACCESS_OPTION_READ_APPEND :
            sAccessOptionStr[0] = 'A';
            sAccessOptionStr[1] = '\0';
            break;

        default : /* QCM_ACCESS_OPTION_NONE */
            sNeedToUpdate = ID_FALSE;
            break;
    }

    if ( sNeedToUpdate == ID_TRUE )
    {
        IDU_FIT_POINT( "qdbAlter::updatePartAccessOfTablePartMeta::alloc::sSqlStr",
                        idERR_ABORT_InsufficientMemory );

        IDE_TEST( STRUCT_ALLOC_WITH_SIZE( aStatement->qmxMem,
                                          SChar,
                                          QD_MAX_SQL_LENGTH,
                                          &sSqlStr )
                  != IDE_SUCCESS);

        idlOS::snprintf( sSqlStr, QD_MAX_SQL_LENGTH,
                         "UPDATE SYS_TABLE_PARTITIONS_ "
                         "SET PARTITION_ACCESS = CHAR'%s', "
                         "    LAST_DDL_TIME = SYSDATE "
                         "WHERE PARTITION_ID = INTEGER'%"ID_INT32_FMT"' ",
                         sAccessOptionStr,
                         aPartitionID );

        IDE_TEST( qcg::runDMLforDDL( QC_SMI_STMT( aStatement ),
                                     sSqlStr,
                                     & sRowCnt )
                  != IDE_SUCCESS );

        IDE_TEST_RAISE( sRowCnt != 1, ERR_META_CRASH );
    }
    else
    {
        /* Nothing to do */
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_META_CRASH )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QCM_META_CRASH ) );
    }

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::validateAccessTable( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *    PROJ-2359 Table/Partition Access Option
 *
 *    ALTER TABLE table ACCESS READ { ONLY | WRITE | APPEND };
 *
 * Implementation :
 *
 ***********************************************************************/

    qdTableParseTree    * sParseTree;
    qcmTableInfo        * sTableInfo;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // ------------------------------------------------------
    // 1. ALTER TABLE 구문의 공통적인 validation
    // ------------------------------------------------------
    // 테이블에 LOCK(IS)
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_FALSE )
              != IDE_SUCCESS );

    sTableInfo = sParseTree->tableInfo;

    // ------------------------------------------------------
    // 2. ACCESS 가능 테이블 타입 검사
    // ------------------------------------------------------
    IDE_TEST_RAISE( sTableInfo->tableType == QCM_MVIEW_TABLE,
                    ERR_ACCESS_NOT_SUPPORT_MVIEW );

    // ------------------------------------------------------
    // 3. 이미 지정한 ACCESS로 지정하는지 검사
    // ------------------------------------------------------
    if ( sTableInfo->accessOption == sParseTree->accessOption )
    {
        sParseTree->common.execute = qcc::execute;
    }
    else
    {
        /* Nothing to do */
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_ACCESS_NOT_SUPPORT_MVIEW );
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDM_ACCESS_NOT_SUPPORT_MVIEW ) );
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::executeAccessTable( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *    PROJ-2359 Table/Partition Access Option
 *
 *    ALTER TABLE table ACCESS READ { ONLY | WRITE | APPEND };
 *
 * Implementation :
 *
 ***********************************************************************/

    qdTableParseTree    * sParseTree;
    qcmTableInfo        * sTableInfo        = NULL;
    UInt                  sTableID;
    smOID                 sTableOID;

    qcmTableInfo        * sNewTableInfo    = NULL;
    void                * sNewTableHandle  = NULL;
    smSCN                 sNewSCN          = SM_SCN_INIT;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // TASK-2176
    // Table에 대한 Lock을 획득한다.
    IDE_TEST( qcm::validateAndLockTable( aStatement,
                                         sParseTree->tableHandle,
                                         sParseTree->tableSCN,
                                         SMI_TABLE_LOCK_X )
              != IDE_SUCCESS );

    sTableInfo = sParseTree->tableInfo;
    sTableID   = sTableInfo->tableID;
    sTableOID  = smiGetTableId( sTableInfo->tableHandle );

    // ACCESS 업데이트
    IDE_TEST( updateTableAccessOption(
                    aStatement,
                    sTableInfo->tableID,
                    sParseTree->accessOption )
              != IDE_SUCCESS );

    // fix BUG-14394
    IDE_TEST( qdbCommon::updateTableSpecFromMeta(
                    aStatement,
                    sParseTree->userName,
                    sParseTree->tableName,
                    sTableID,
                    sTableOID,
                    sTableInfo->columnCount,
                    sTableInfo->parallelDegree )
              != IDE_SUCCESS );

    IDE_TEST( qcm::touchTable( QC_SMI_STMT( aStatement ),
                               sTableID,
                               SMI_TBSLV_DDL_DML )
              != IDE_SUCCESS );

    IDE_TEST( qcm::makeAndSetQcmTableInfo( QC_SMI_STMT( aStatement ),
                                           sTableID,
                                           sTableOID )
              != IDE_SUCCESS );

    IDE_TEST( qcm::getTableInfoByID( aStatement,
                                     sTableID,
                                     & sNewTableInfo,
                                     & sNewSCN,
                                     & sNewTableHandle )
              != IDE_SUCCESS );

    (void)qcm::destroyQcmTableInfo( sTableInfo );

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    (void)qcm::destroyQcmTableInfo( sNewTableInfo );

    qcmPartition::restoreTempInfo( sTableInfo,
                                   NULL,
                                   NULL );

    return IDE_FAILURE;
}

IDE_RC qdbAlter::validateIndexAlterationForPartition( qcStatement          * aStatement,
                                                      qcmTableInfo         * aTableInfo,
                                                      qcmTableInfo         * aPartInfo,
                                                      qdPartitionAttribute * aPartAttr )
{
/***********************************************************************
 *
 * Description :
 *      PROJ-2464 hybrid partitioned table 지원
 *
 *      Partitioned Table 수정 시, Index 속성을 검사하는 함수이다.
 *      ALTER TABLE ~ ADD PARTITION
 *                  ~ SPLIT PARTITION
 *                  ~ MERGE PARTITION 에서 호출한다.
 *
 *      aPartInfo 는 Partition Info가 없는 경우, Partitined Info가 전달된다.
 *
 * Implementation :
 *      1. Global Index를 검사한다.
 *
 *      2. Key Size Limit를 검사한다.
 *
 *      3. Partioned Index Header의 Flag를 확인한다.
 *         3.1. Persistent   옵션은 Memory Partition만 지원한다.
 *         * TODO : 3.2. DirectKeyMax 옵션은 Memory Partition만 지원한다.
 *         * TODO : 3.3. Logging      옵션은 Disk   Partition만 지원한다.
 *
 ***********************************************************************/

    qcmColumn   sKeyColumn[QC_MAX_KEY_COLUMN_COUNT];
    mtcColumn   sMtcColumn[QC_MAX_KEY_COLUMN_COUNT];
    qcmIndex  * sIndex     = NULL;
    UInt        sTableType = 0;
    UInt        sPartType  = 0;
    UInt        sFlag      = 0;
    UInt        i          = 0;

    sTableType = aTableInfo->tableFlag & SMI_TABLE_TYPE_MASK;
    sPartType  = qdbCommon::getTableTypeFromTBSID( aPartAttr->TBSAttr.mID );

    for ( i = 0; i < aTableInfo->indexCount; i++ )
    {
        sIndex = &( aTableInfo->indices[i] );

        /* 1. Global Index를 검사한다. */
        IDE_TEST_RAISE( ( sIndex->indexPartitionType == QCM_NONE_PARTITIONED_INDEX ) &&
                        ( smiTableSpace::isDiskTableSpaceType( aPartAttr->TBSAttr.mType ) != ID_TRUE ),
                        ERR_CANNOT_CREATE_NONE_PART_INDEX_ON_PART_TABLE );

        /* 2. Key Size Limit를 검사한다. */
        if ( QCM_TABLE_TYPE_IS_DISK( sTableType ) != QCM_TABLE_TYPE_IS_DISK( sPartType ) )
        {
            qdbCommon::makeTempQcmColumnListFromIndex( sIndex, sMtcColumn, sKeyColumn );

            IDE_TEST( qdbCommon::adjustKeyColumn( aPartAttr->columns,
                                                  sKeyColumn )
                      != IDE_SUCCESS );

            IDE_TEST( qdx::validateKeySizeLimit( aStatement,
                                                 QC_QMP_MEM( aStatement ),
                                                 sPartType,
                                                 (void *)sKeyColumn,
                                                 sIndex->keyColCount,
                                                 sIndex->indexTypeId )
                      != IDE_SUCCESS );
        }
        else
        {
            /* Nothing to do */
        }
    }

    for ( i = 0; i < aPartInfo->indexCount; i++ )
    {
        sIndex = &( aPartInfo->indices[i] );

        /* 3. Partition Index Header의 Flag를 확인한다. */
        sFlag = smiTable::getIndexInfo( sIndex->indexHandle );

        /* 3.1. Persistent   옵션은 Memory Partition만 지원한다. */
        IDE_TEST_RAISE( ( ( sFlag & SMI_INDEX_PERSISTENT_MASK ) == SMI_INDEX_PERSISTENT_ENABLE ) &&
                        ( smiTableSpace::isMemTableSpaceType( aPartAttr->TBSAttr.mType ) != ID_TRUE ),
                        ERR_IRREGULAR_PERSISTENT_OPTION );

        /* TODO : 3.2. DirectKeyMax 옵션은 Memory Partition만 지원한다.
         *        Partitioned Table에 지원하게 되면 아래의 코드를 이용한다.
         *
         * IDE_TEST_RAISE( ( ( sFlag & SMI_INDEX_DIRECTKEY_MASK ) == SMI_INDEX_DIRECTKEY_TRUE ) &&
         *                 ( smiTableSpace::isMemTableSpaceType( aPartAttr->TBSAttr.mType ) != ID_TRUE ),
         *                 ERR_IRREGULAR_DIRECTKEY_OPTION );
         *
         * IDE_EXCEPTION( ERR_IRREGULAR_DIRECTKEY_OPTION )
         * {
         *     IDE_SET( ideSetErrorCode( smERR_ABORT_NonDirectKeyOption ) );
         * }
         */

        /* TODO : 3.3. Logging      옵션은 Disk   Partition만 지원한다.
         *        Index의 Logging 옵션은 현재(2015-06-02) 생성 시에만 검사를 하고, Alter로 변경할 수 없는 옵션이다.
         *        그래서 Split, Merge, Add, Coalesce, Truncate 시, 생성 때에 사용한 옵션을 유지하지 않는 정책을 지닌다.
         *        PROJ-2464 에서는 그러한 정책를 그대로 이용한다.
         *        이후 해당 옵션의 Alter 변경이 지원될 때에 옵션 제약을 처리하도록 한다.
         */
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_IRREGULAR_PERSISTENT_OPTION )
    {
        IDE_SET( ideSetErrorCode ( qpERR_ABORT_QDX_NON_MEMORY_INDEX_PERSISTENT_OPTION ) );
    }
    IDE_EXCEPTION( ERR_CANNOT_CREATE_NONE_PART_INDEX_ON_PART_TABLE )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDX_CANNOT_CREATE_NONE_PART_INDEX_ON_MEM_PART_TABLE ) );
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::validateIndexAlterationForPartitioned( qcStatement  * aStatement,
                                                        qcmTableInfo * aTableInfo,
                                                        qcmColumn    * aNewTableColumn,
                                                        UInt           aNewTableType )
{
/***********************************************************************
 *
 * Description :
 *      PROJ-2465 Tablespace Alteration for Table
 *
 *      Partitioned Table 수정 시, Index 속성을 검사하는 함수이다.
 *      ALTER TABLE ~ ALTER TABLESPACE 에서 호출한다.
 *
 * Implementation :
 *      1. Global Index와 Direct Key를 검사한다.
 *
 *      2. Key Size Limit를 검사한다.
 *
 *      3. Persistent 옵션은 Memory Table만 지원한다.
 *
 ***********************************************************************/

    qcmColumn   sKeyColumn[QC_MAX_KEY_COLUMN_COUNT];
    mtcColumn   sMtcColumn[QC_MAX_KEY_COLUMN_COUNT];
    qcmIndex  * sIndex     = NULL;
    UInt        sTableType = SMI_TABLE_DISK;
    UInt        sFlag      = 0;
    UInt        i          = 0;

    sTableType = aTableInfo->tableFlag & SMI_TABLE_TYPE_MASK;

    for ( i = 0; i < aTableInfo->indexCount; i++ )
    {
        sIndex = &( aTableInfo->indices[i] );
        sFlag  = smiTable::getIndexInfo( sIndex->indexHandle );

        /* 1. Global Index와 Direct Key를 검사한다. */
        if ( aTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
        {
            /* ALTER TABLE ~ ALTER TABLESPACE 에서 Global Index를 지원하지 않는다. */
            IDE_TEST_RAISE( sIndex->indexPartitionType == QCM_NONE_PARTITIONED_INDEX,
                            ERR_CANNOT_ALTER_TABLESPACE_ON_NONE_PART_INDEX );
        }
        else
        {
            IDE_TEST_RAISE( ( ( sFlag & SMI_INDEX_DIRECTKEY_MASK ) == SMI_INDEX_DIRECTKEY_TRUE ) &&
                            ( QCM_TABLE_TYPE_IS_MEMORY( aNewTableType ) != ID_TRUE ),
                            ERR_IRREGULAR_DIRECTKEY_OPTION );
        }

        /* 2. Key Size Limit를 검사한다. */
        if ( QCM_TABLE_TYPE_IS_DISK( sTableType ) != QCM_TABLE_TYPE_IS_DISK( aNewTableType ) )
        {
            qdbCommon::makeTempQcmColumnListFromIndex( sIndex, sMtcColumn, sKeyColumn );

            IDE_TEST( qdbCommon::adjustKeyColumn( aNewTableColumn,
                                                  sKeyColumn )
                      != IDE_SUCCESS );

            IDE_TEST( qdx::validateKeySizeLimit( aStatement,
                                                 QC_QMP_MEM( aStatement ),
                                                 aNewTableType,
                                                 (void *)sKeyColumn,
                                                 sIndex->keyColCount,
                                                 sIndex->indexTypeId )
                      != IDE_SUCCESS );
        }
        else
        {
            /* Nothing to do */
        }

        /* 3. Persistent 옵션은 Memory Table만 지원한다. */
        IDE_TEST_RAISE( ( ( sFlag & SMI_INDEX_PERSISTENT_MASK ) == SMI_INDEX_PERSISTENT_ENABLE ) &&
                        ( QCM_TABLE_TYPE_IS_MEMORY( aNewTableType ) != ID_TRUE ),
                        ERR_IRREGULAR_PERSISTENT_OPTION );
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_CANNOT_ALTER_TABLESPACE_ON_NONE_PART_INDEX )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_CANNOT_ALTER_TABLESPACE_ON_NONE_PART_INDEX ) );
    }
    IDE_EXCEPTION( ERR_IRREGULAR_DIRECTKEY_OPTION )
    {
        IDE_SET( ideSetErrorCode( smERR_ABORT_NonDirectKeyOption ) );
    }
    IDE_EXCEPTION( ERR_IRREGULAR_PERSISTENT_OPTION )
    {
        IDE_SET( ideSetErrorCode ( qpERR_ABORT_QDX_NON_MEMORY_INDEX_PERSISTENT_OPTION ) );
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::validateTablespaceRestriction( qcmTableInfo      * aTableInfo,
                                                smiTableSpaceType   aTBSType )
{
/***********************************************************************
 *
 * Description :
 *      PROJ-2464 hybrid partitioned table 지원
 *
 *      Table/Partition에 적합한 Tablespace인지 검사한다.
 *
 *      ALTER TABLE ~ ADD PARTITION
 *                  ~ SPLIT PARTITION
 *                  ~ MERGE PARTITION
 *                  ~ ALTER PARTITION
 *                  ~ ALTER TABLESPACE
 *      에서 호출한다.
 *
 * Implementation :
 *      1. Volatile Tablespace이라면, 제약조건을 검사한다.
 *         1.1. Table/Partition Header의 Flag를 확인한다.
 *         1.2. Compressed Log 옵션을 사용하면, Volatile Tablespace을 지원하지 않는다.
 *
 ***********************************************************************/

    UInt sFlag = 0;

    /* 1. Volatile Tablespace이라면, 제약조건을 검사한다.
     *    ALTER 시에만 처리한다. CREATE의 경우 다른 함수에서 이미 처리하고 있다.
     */
    if ( smiTableSpace::isVolatileTableSpaceType( aTBSType ) == ID_TRUE )
    {
        /* 1.1. Table/Partition Header의 Flag를 확인한다. */
        sFlag = smiGetTableFlag( aTableInfo->tableHandle );

        /* 1.2. Compressed Log 옵션을 사용하면, Volatile Tablespace을 지원하지 않는다. */
        IDE_TEST_RAISE( ( sFlag & SMI_TABLE_LOG_COMPRESS_MASK ) == SMI_TABLE_LOG_COMPRESS_TRUE,
                        ERR_VOLATILE_LOG_COMPRESS );
    }
    else
    {
        /* Nothing to do */
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_VOLATILE_LOG_COMPRESS );
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDT_UNABLE_TO_COMPRESS_VOLATILE_TBS_LOG ) );
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::validateTableReferenceForPartitions( qcStatement          * aStatement,
                                                      qcmTableInfo         * aTableInfo,
                                                      qdPartitionAttribute * aSrcAttrList,
                                                      qdPartitionAttribute * aDstAttrList )
{
/***********************************************************************
 *
 * Description :
 *      PROJ-2464 hybrid partitioned table 지원
 *
 *      Partitioned Table 수정 시,
 *                  Foreign Key를 Check
 *
 *      ALTER TABLE ~ ADD PARTITION
 *                  ~ SPLIT PARTITION
 *                  ~ MERGE PARTITION 에서 호출한다.
 *
 *      Table Reference 허용 관계도
 *      -----------------------------------
 *      | No | Current | Table  | Allowed |
 *      |    | Self    | Parent |         |
 *      -----------------------------------
 *      | 1  | Non     | Vol    | X       |
 *      | 2  | Non     | Non    | O       |
 *      | 3  | Vol     | Vol    | O       |
 *      | 4  | Vol     | Non    | O       |
 *      -----------------------------------
 *      | No | Current | Table  | Allowed |
 *      |    | Parent  | Child  |         |
 *      -----------------------------------
 *      | 5  | Non     | Vol    | O       |
 *      | 6  | Non     | Non    | O       |
 *      | 7  | Vol     | Vol    | O       |
 *      | 8  | Vol     | Non    | X       |
 *      -----------------------------------
 *       - Non : NonVolatile
 *       - Vol : Volatile
 *
 * Implementation :
 *      1. Partitioned의 Type를 검사한다.
 *
 *      2. Parent Table를 검사한다.
 *
 *      3. Child Table를 검사한다.
 *
 ***********************************************************************/

    qcmTableInfo    * sReferenceInfo      = NULL;
    qcmParentInfo   * sParentInfoList     = NULL;
    qcmRefChildInfo * sChildInfoList      = NULL;
    idBool            sIsVolatileAsParent = ID_FALSE;
    idBool            sIsVolatileAsSelf   = ID_FALSE;
    idBool            sIsVolatileParent   = ID_FALSE; /* Non Type 경우, 모든 변경이 허용 */
    idBool            sIsVolatileChild    = ID_TRUE; /* Vol Type 경우, 모든 변경이 허용 */

    /* 1. Partitioned의 Type를 검사한다. */
    IDE_TEST( checkVolatileTableForPartitions( aStatement,
                                               aTableInfo,
                                               aSrcAttrList,
                                               aDstAttrList,
                                               & sIsVolatileAsSelf,
                                               & sIsVolatileAsParent )
              != IDE_SUCCESS );

    /* 2. Parent Table를 검사한다. */
    if ( sIsVolatileAsSelf != ID_TRUE )
    {
        IDE_TEST( qmv::getParentInfoList( aStatement,
                                          aTableInfo,
                                          &( sParentInfoList ) )
                  != IDE_SUCCESS );

        while ( sParentInfoList != NULL )
        {
            sReferenceInfo = sParentInfoList->parentTableRef->tableInfo;

            if ( sReferenceInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
            {
                IDE_TEST( checkVolatileTableForParent( aStatement,
                                                       sReferenceInfo,
                                                       & sIsVolatileParent )
                          != IDE_SUCCESS );
            }
            else
            {
                sIsVolatileParent = smiTableSpace::isVolatileTableSpace( sReferenceInfo->TBSID );
            }

            IDE_TEST_RAISE( sIsVolatileParent == ID_TRUE, ERR_ABORT_REFERENTIAL_CONSTRAINT_EXIST );

            sParentInfoList = sParentInfoList->next;
        }
    }
    else
    {
        /* Nothing to do */
    }

    /* 3. Child Table를 검사한다. */
    if ( sIsVolatileAsParent == ID_TRUE )
    {
        IDE_TEST( qmv::getChildInfoList( aStatement,
                                         aTableInfo,
                                         &( sChildInfoList ) )
                  != IDE_SUCCESS );

        while ( sChildInfoList != NULL )
        {
            sReferenceInfo = sChildInfoList->childTableRef->tableInfo;

            if ( sReferenceInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
            {
                IDE_TEST( checkVolatileTableForChild( aStatement,
                                                      sReferenceInfo,
                                                      & sIsVolatileChild )
                          != IDE_SUCCESS );
            }
            else
            {
                sIsVolatileChild = smiTableSpace::isVolatileTableSpace( sReferenceInfo->TBSID );
            }

            IDE_TEST_RAISE( sIsVolatileChild != ID_TRUE, ERR_ABORT_REFERENTIAL_CONSTRAINT_EXIST );

            sChildInfoList = sChildInfoList->next;
        }
    }
    else
    {
        /* Nothing to do */
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_ABORT_REFERENTIAL_CONSTRAINT_EXIST );
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_REFERENTIAL_CONSTRAINT_EXIST ) );
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::validateTableReferenceForPartitioned( qcStatement  * aStatement,
                                                       qcmTableInfo * aTableInfo,
                                                       UInt           aNewTableType )
{
/***********************************************************************
 *
 * Description :
 *      PROJ-2465 Tablespace Alteration for Table
 *
 *      Partitioned Table 수정 시,
 *                  Foreign Key를 Check
 *
 *      ALTER TABLE ~ ALTER TABLESPACE 에서 호출한다.
 *
 *      Table Reference 허용 관계도
 *      -----------------------------------
 *      | No | Current | Table  | Allowed |
 *      |    | Self    | Parent |         |
 *      -----------------------------------
 *      | 1  | Non     | Vol    | X       |
 *      | 2  | Non     | Non    | O       |
 *      | 3  | Vol     | Vol    | O       |
 *      | 4  | Vol     | Non    | O       |
 *      -----------------------------------
 *      | No | Current | Table  | Allowed |
 *      |    | Parent  | Child  |         |
 *      -----------------------------------
 *      | 5  | Non     | Vol    | O       |
 *      | 6  | Non     | Non    | O       |
 *      | 7  | Vol     | Vol    | O       |
 *      | 8  | Vol     | Non    | X       |
 *      -----------------------------------
 *       - Non : NonVolatile
 *       - Vol : Volatile
 *
 * Implementation :
 *      1. Partitioned의 Type을 검사한다.
 *
 *      2. Parent Table을 검사한다.
 *
 *      3. Child Table을 검사한다.
 *
 ***********************************************************************/

    qcmTableInfo    * sReferenceInfo      = NULL;
    qcmParentInfo   * sParentInfoList     = NULL;
    qcmRefChildInfo * sChildInfoList      = NULL;
    idBool            sIsVolatileAsParent = ID_FALSE;
    idBool            sIsVolatileAsSelf   = ID_FALSE;
    idBool            sIsVolatileParent   = ID_FALSE; /* Non Type 경우, 모든 변경이 허용 */
    idBool            sIsVolatileChild    = ID_TRUE;  /* Vol Type 경우, 모든 변경이 허용 */

    /* 1. Partitioned의 Type를 검사한다. */
    IDE_TEST( checkVolatileTableForPartitioned( aStatement,
                                                aTableInfo,
                                                aNewTableType,
                                                & sIsVolatileAsSelf,
                                                & sIsVolatileAsParent )
              != IDE_SUCCESS );

    /* 2. Parent Table를 검사한다. */
    if ( sIsVolatileAsSelf != ID_TRUE )
    {
        IDE_TEST( qmv::getParentInfoList( aStatement,
                                          aTableInfo,
                                          &( sParentInfoList ) )
                  != IDE_SUCCESS );

        while ( sParentInfoList != NULL )
        {
            sReferenceInfo = sParentInfoList->parentTableRef->tableInfo;

            if ( sReferenceInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
            {
                IDE_TEST( checkVolatileTableForParent( aStatement,
                                                       sReferenceInfo,
                                                       & sIsVolatileParent )
                          != IDE_SUCCESS );
            }
            else
            {
                sIsVolatileParent = smiTableSpace::isVolatileTableSpace( sReferenceInfo->TBSID );
            }

            IDE_TEST_RAISE( sIsVolatileParent == ID_TRUE, ERR_ABORT_REFERENTIAL_CONSTRAINT_EXIST );

            sParentInfoList = sParentInfoList->next;
        }
    }
    else
    {
        /* Nothing to do */
    }

    /* 3. Child Table를 검사한다. */
    if ( sIsVolatileAsParent == ID_TRUE )
    {
        IDE_TEST( qmv::getChildInfoList( aStatement,
                                         aTableInfo,
                                         &( sChildInfoList ) )
                  != IDE_SUCCESS );

        while ( sChildInfoList != NULL )
        {
            sReferenceInfo = sChildInfoList->childTableRef->tableInfo;

            if ( sReferenceInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
            {
                IDE_TEST( checkVolatileTableForChild( aStatement,
                                                      sReferenceInfo,
                                                      & sIsVolatileChild )
                          != IDE_SUCCESS );
            }
            else
            {
                sIsVolatileChild = smiTableSpace::isVolatileTableSpace( sReferenceInfo->TBSID );
            }

            IDE_TEST_RAISE( sIsVolatileChild != ID_TRUE, ERR_ABORT_REFERENTIAL_CONSTRAINT_EXIST );

            sChildInfoList = sChildInfoList->next;
        }
    }
    else
    {
        /* Nothing to do */
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_ABORT_REFERENTIAL_CONSTRAINT_EXIST );
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_REFERENTIAL_CONSTRAINT_EXIST ) );
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::checkVolatileTableForChild( qcStatement  * aStatement,
                                             qcmTableInfo * aTableInfo,
                                             idBool       * aIsVolatile )
{
/***********************************************************************
 *
 * Description :
 *      PROJ-2464 hybrid partitioned table 지원
 *
 *      Child Table이 Volatile인지 검사한다.
 *
 *      Partitioned Table의 Volatile Type 결정
 *      -----------------------------
 *      | No | Part1 | Part2 | Type |
 *      -----------------------------
 *      | 1  | Non   | Vol   | Non  |
 *      | 2  | Non   | Non   | Non  |
 *      | 3  | Vol   | Vol   | Vol  |
 *      | 4  | Vol   | Non   | Non  |
 *      -----------------------------
 *       - Non : NonVolatile
 *       - Vol : Volatile
 *
 * Implementation :
 *      1. Volatile를 포함하고 있는 지 검사한다.
 *         1.1. Partition 정보를 가져온다.
 *         1.2. 매체를 검사한다.
 *         1.3. 모두 Volatile Type이 Valatile Table이다.
 *
 ***********************************************************************/

    qcmPartitionInfoList * sPartInfoList  = NULL;
    idBool                 sIsVolatile    = ID_FALSE;
    SInt                   sCountDiskType = 0;
    SInt                   sCountMemType  = 0;
    UInt                   sTableType     = 0;

    sTableType = aTableInfo->tableFlag & SMI_TABLE_TYPE_MASK;

    /* 1. Volatile를 포함하고 있는 지 검사한다. */
    /* 1.1. Partition 정보를 가져온다. */
    IDE_TEST( qdbCommon::checkAndSetAllPartitionInfo( aStatement,
                                                      aTableInfo->tableID,
                                                      &( sPartInfoList ) )
              != IDE_SUCCESS );

    /* 1.2. 매체를 검사한다. */
    qdbCommon::getTableTypeCountInPartInfoList( & sTableType,
                                                sPartInfoList,
                                                & sCountDiskType,
                                                & sCountMemType,
                                                NULL );

    /* 1.3. 모두 Volatile Type이 Valatile Table이다. */
    if ( ( sCountDiskType + sCountMemType ) == 0 )
    {
        sIsVolatile = ID_TRUE;
    }
    else
    {
        sIsVolatile = ID_FALSE;
    }

    *aIsVolatile = sIsVolatile;

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::checkVolatileTableForParent( qcStatement  * aStatement,
                                              qcmTableInfo * aTableInfo,
                                              idBool       * aIsVolatile )
{
/***********************************************************************
 *
 * Description :
 *      PROJ-2464 hybrid partitioned table 지원
 *
 *      Parent Table이 Volatile인지 검사한다.
 *      qdbAlter::checkVolatileTableForParent와 결정조건이 다르다.
 *
 *      Partitioned Table의 Volatile Type 결정
 *      -----------------------------
 *      | No | Part1 | Part2 | Type |
 *      -----------------------------
 *      | 1  | Non   | Vol   | Vol  |
 *      | 2  | Non   | Non   | Non  |
 *      | 3  | Vol   | Vol   | Vol  |
 *      | 4  | Vol   | Non   | Vol  |
 *      -----------------------------
 *       - Non : NonVolatile
 *       - Vol : Volatile
 *
 * Implementation :
 *      1. Volatile를 포함하고 있는 지 검사한다.
 *         1.1. Partition 정보를 가져온다.
 *         1.2. 매체를 검사한다.
 *         1.3. Volatile Type이 존재하면 Valatile Table이다.
 *
 ***********************************************************************/

    qcmPartitionInfoList * sPartInfoList = NULL;
    idBool                 sIsVolatile   = ID_FALSE;
    SInt                   sCountVolType = 0;
    UInt                   sTableType    = 0;

    sTableType = aTableInfo->tableFlag & SMI_TABLE_TYPE_MASK;

    /* 1. Volatile를 포함하고 있는 지 검사한다. */
    /* 1.1. Partition 정보를 가져온다. */
    IDE_TEST( qdbCommon::checkAndSetAllPartitionInfo( aStatement,
                                                      aTableInfo->tableID,
                                                      &( sPartInfoList ) )
              != IDE_SUCCESS );

    /* 1.2. 매체를 검사한다. */
    qdbCommon::getTableTypeCountInPartInfoList( & sTableType,
                                                sPartInfoList,
                                                NULL,
                                                NULL,
                                                & sCountVolType );

    /* 1.3. Volatile Type이 존재하면 Valatile Table이다. */
    if ( sCountVolType > 0 )
    {
        sIsVolatile = ID_TRUE;
    }
    else
    {
        sIsVolatile = ID_FALSE;
    }

    *aIsVolatile = sIsVolatile;

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::checkVolatileTableForPartitions( qcStatement          * aStatement,
                                                  qcmTableInfo         * aTableInfo,
                                                  qdPartitionAttribute * aSrcAttrList,
                                                  qdPartitionAttribute * aDstAttrList,
                                                  idBool               * aIsVolatileAsSelf,
                                                  idBool               * aIsVolatileAsParent )
{
/***********************************************************************
 *
 * Description :
 *      PROJ-2464 hybrid partitioned table 지원
 *
 *      Partitioned Table이 Volatile인지 검사한다.
 *
 *      Partitioned Table의 Volatile Type 결정
 *      ----------------------------------------
 *      | No | Position | Part1 | Part2 | Type |
 *      ----------------------------------------
 *      | 1  | Self     | Non   | Non   | Non  |
 *      | 2  | Self     | Non   | Vol   | Non  |
 *      | 3  | Self     | Vol   | Non   | Non  |
 *      | 4  | Self     | Vol   | Vol   | Vol  |
 *      ----------------------------------------
 *      | 5  | Parent   | Non   | Non   | Non  |
 *      | 6  | Parent   | Non   | Vol   | Vol  |
 *      | 7  | Parent   | Vol   | Non   | Vol  |
 *      | 8  | Parent   | Vol   | Vol   | Vol  |
 *      ----------------------------------------
 *       - Non : NonVolatile
 *       - Vol : Volatile
 *
 * Implementation :
 *      1. Partition 정보를 가져온다.
 *
 *      2. Partition 구성을 검사한다.
 *
 *      3. SrcAttrList에 Part의 TBSType를 전달한다.
 *
 *      4. Partition 변경을 검사한다.
 *
 *      5. Partitioned가 Parent, Self 위치에 따라 Volatile인지 결정한다.
 *         5.1. Parent인 경우, Volatile Type이 존재하면 Valatile Table이다.
 *         5.2. Self인 경우, 모두 Volatile Type이면 Valatile Table이다.
 *
 ***********************************************************************/

    qcmPartitionInfoList * sPartInfoList       = NULL;
    qcmPartitionInfoList * sSrcInfoList        = NULL;
    qdPartitionAttribute * sSrcAttrList        = NULL;
    idBool                 sIsVolatileAsSelf   = ID_FALSE;
    idBool                 sIsVolatileAsParent = ID_FALSE;
    SInt                   sCountDiskType      = 0;
    SInt                   sCountMemType       = 0;
    SInt                   sCountVolType       = 0;
    SInt                   sTempCountDisk      = 0;
    SInt                   sTempCountMem       = 0;
    SInt                   sTempCountVol       = 0;
    UInt                   sTableType          = 0;

    sTableType = aTableInfo->tableFlag & SMI_TABLE_TYPE_MASK;

    /* 1. Partition 정보를 가져온다. */
    IDE_TEST( qdbCommon::checkAndSetAllPartitionInfo( aStatement,
                                                      aTableInfo->tableID,
                                                      &( sPartInfoList ) )
              != IDE_SUCCESS );

    /* 2. Partition 구성을 검사한다. */
    qdbCommon::getTableTypeCountInPartInfoList( & sTableType,
                                                sPartInfoList,
                                                & sTempCountDisk,
                                                & sTempCountMem,
                                                & sTempCountVol );

    sCountDiskType += sTempCountDisk;
    sCountMemType  += sTempCountMem;
    sCountVolType  += sTempCountVol;

    /* 3. SrcAttrList에 Part의 TBSType를 전달한다. */
    for ( sSrcAttrList  = aSrcAttrList;
          sSrcAttrList != NULL;
          sSrcAttrList  = sSrcAttrList->next )
    {
        for ( sSrcInfoList  = sPartInfoList;
              sSrcInfoList != NULL;
              sSrcInfoList  = sSrcInfoList->next )
        {
            IDE_DASSERT( QC_IS_NULL_NAME( sSrcAttrList->tablePartName ) == ID_FALSE );

            if ( idlOS::strMatch( sSrcAttrList->tablePartName.stmtText + sSrcAttrList->tablePartName.offset,
                                  sSrcAttrList->tablePartName.size,
                                  sSrcInfoList->partitionInfo->name,
                                  idlOS::strlen( sSrcInfoList->partitionInfo->name ) ) == 0 )
            {
                sSrcAttrList->TBSAttr.mType = sSrcInfoList->partitionInfo->TBSType;
                break;
            }
            else
            {
                /* Nothing to do */
            }
        }

        IDE_TEST_RAISE( sSrcInfoList == NULL, ERR_NO_EXIST_PARTATTR );
    }

    /* 4. Partition 변경을 검사한다.
     *    - 변경 이전 대상은 Type Count를 감산한다.
     *    - 변경 이후 대상은 Type Count를 가산한다.
     */
    if ( aSrcAttrList != NULL )
    {
        qdbCommon::getTableTypeCountInPartAttrList( NULL,
                                                    aSrcAttrList,
                                                    & sTempCountDisk,
                                                    & sTempCountMem,
                                                    & sTempCountVol );
        sCountDiskType -= sTempCountDisk;
        sCountMemType  -= sTempCountMem;
        sCountVolType  -= sTempCountVol;
    }
    else
    {
        /* Nothing to do */
    }

    qdbCommon::getTableTypeCountInPartAttrList( NULL,
                                                aDstAttrList,
                                                & sTempCountDisk,
                                                & sTempCountMem,
                                                & sTempCountVol );
    sCountDiskType += sTempCountDisk;
    sCountMemType  += sTempCountMem;
    sCountVolType  += sTempCountVol;

    /* 5. Partitioned가 Parent, Child 위치에 따라 Volatile인지 결정한다. */
    /* 5.1. Parent인 경우, Volatile Type이 존재하면 Valatile Table이다. */
    if ( sCountVolType > 0 )
    {
        sIsVolatileAsParent = ID_TRUE;
    }
    else
    {
        /* Nothing to do */
    }

    /* 5.2. Self인 경우, 모두 Volatile Type이면 Valatile Table이다. */
    if ( ( sCountDiskType + sCountMemType ) == 0 )
    {
        sIsVolatileAsSelf = ID_TRUE;
    }
    else
    {
        /* Nothing to do */
    }

    *aIsVolatileAsSelf   = sIsVolatileAsSelf;
    *aIsVolatileAsParent = sIsVolatileAsParent;

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_NO_EXIST_PARTATTR )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QMC_UNEXPECTED_ERROR,
                                  "qdbAlter::checkVolatileTableForPartitions",
                                  "No exist part attribure" ) );
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::checkVolatileTableForPartitioned( qcStatement  * aStatement,
                                                   qcmTableInfo * aTableInfo,
                                                   UInt           aNewTableType,
                                                   idBool       * aIsVolatileAsSelf,
                                                   idBool       * aIsVolatileAsParent )
{
/***********************************************************************
 *
 * Description :
 *      PROJ-2465 Tablespace Alteration for Table
 *
 *      Partitioned Table이 Volatile인지 검사한다.
 *
 *      Partitioned Table의 Volatile Type 결정
 *      ----------------------------------------
 *      | No | Position | Part1 | Part2 | Type |
 *      ----------------------------------------
 *      | 1  | Self     | Non   | Non   | Non  |
 *      | 2  | Self     | Non   | Vol   | Non  |
 *      | 3  | Self     | Vol   | Non   | Non  |
 *      | 4  | Self     | Vol   | Vol   | Vol  |
 *      ----------------------------------------
 *      | 5  | Parent   | Non   | Non   | Non  |
 *      | 6  | Parent   | Non   | Vol   | Vol  |
 *      | 7  | Parent   | Vol   | Non   | Vol  |
 *      | 8  | Parent   | Vol   | Vol   | Vol  |
 *      ----------------------------------------
 *       - Non : NonVolatile
 *       - Vol : Volatile
 *
 * Implementation :
 *      1. Partition 정보를 가져온다.
 *
 *      2. Partition 구성을 검사한다.
 *
 *      3. Table 구성을 검사한다.
 *
 *      4. Partitioned가 Parent, Child 위치에 따라 Volatile인지 결정한다.
 *         4.1. Parent인 경우, Volatile Type이 존재하면 Valatile Table이다.
 *         4.2. Self인 경우, 모두 Volatile Type이면 Valatile Table이다.
 *
 ***********************************************************************/

    qcmPartitionInfoList * sPartInfoList       = NULL;
    idBool                 sIsVolatileAsSelf   = ID_FALSE;
    idBool                 sIsVolatileAsParent = ID_FALSE;
    SInt                   sCountDiskType      = 0;
    SInt                   sCountMemType       = 0;
    SInt                   sCountVolType       = 0;
    SInt                   sTempCountDisk      = 0;
    SInt                   sTempCountMem       = 0;
    SInt                   sTempCountVol       = 0;

    if ( aTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        /* 1. Partition 정보를 가져온다. */
        IDE_TEST( qdbCommon::checkAndSetAllPartitionInfo( aStatement,
                                                          aTableInfo->tableID,
                                                          &( sPartInfoList ) )
                  != IDE_SUCCESS );

        /* 2. Partition 구성을 검사한다. */
        qdbCommon::getTableTypeCountInPartInfoList( NULL,
                                                    sPartInfoList,
                                                    & sTempCountDisk,
                                                    & sTempCountMem,
                                                    & sTempCountVol );

        sCountDiskType += sTempCountDisk;
        sCountMemType  += sTempCountMem;
        sCountVolType  += sTempCountVol;
    }
    else
    {
        /* Nothing to do */
    }

    /* 3. Table 구성을 검사한다. */
    qdbCommon::getTableTypeCountInPartInfoList( & aNewTableType,
                                                NULL,
                                                & sTempCountDisk,
                                                & sTempCountMem,
                                                & sTempCountVol );

    sCountDiskType += sTempCountDisk;
    sCountMemType  += sTempCountMem;
    sCountVolType  += sTempCountVol;

    /* 4. Partitioned가 Parent, Child 위치에 따라 Volatile인지 결정한다. */
    /* 4.1. Parent인 경우, Volatile Type이 존재하면 Valatile Table이다. */
    if ( sCountVolType > 0 )
    {
        sIsVolatileAsParent = ID_TRUE;
    }
    else
    {
        /* Nothing to do */
    }

    /* 4.2. Self인 경우, 모두 Volatile Type이면 Valatile Table이다. */
    if ( ( sCountDiskType + sCountMemType ) == 0 )
    {
        sIsVolatileAsSelf = ID_TRUE;
    }
    else
    {
        /* Nothing to do */
    }

    *aIsVolatileAsSelf   = sIsVolatileAsSelf;
    *aIsVolatileAsParent = sIsVolatileAsParent;

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::validateAlterPartition( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *      PROJ-2464 hybrid partitioned table 지원
 *
 *      ALTER TABLE tbl_name
 *       ALTER PARTITION part_name TABLESPACE tbs_name
 *        { INDEX ( part_index_name TABLESPACE tbs_name, ... ) }
 *        { LOB ( column_name TABLESPACE tbs_name, ... ) }
 *      구문의 validation
 *
 *      Non-Partitioned Index는 Tablespace 이동을 지원하지 않는다.
 *
 * Implementation :
 *      1. ALTER TABLE 구문의 공통적인 Validation를 수행한다.
 *
 *      2. Partitioned Table인지 검사한다.
 *
 *      3. Src Partition의 설정한다.
 *         3.1. Src Partitions을 검사한다.
 *
 *      4. Non-Partitioned Index의 리스트를 얻는다. PROJ-1624
 *
 *      5. Dst Partition의 설정
 *         5.1. Dst Partition의 이름을 설정한다.
 *         5.2. Dst Partition의 AccessOption을 설정한다. - PROJ-2359
 *         5.3. Dst Partition의 Tablespace를 검사한다.
 *         5.4. Dst Partition의 Tablespace과 Src Partition의 Tablespace가 동일하면 해당작업을 수행할 수 없다.
 *         5.5. Dst Partition의 제약조건을 검사한다.
 *         5.6. Dst Partition의 컬럼을 조정한다.
 *
 *      6. Lob Storage의 설정한다.
 *
 *      7. ForeienKey 제약을 검사한다.
 *
 *      8. Index 제약을 검사한다.
 *
 *      9. Index Partition를 구성한다
 *
 *      10. Index Partition를 검사한다.
 *
 ***********************************************************************/

    qdTableParseTree     * sParseTree     = NULL;
    qcmTableInfo         * sTableInfo     = NULL;
    qcmTableInfo         * sPartitionInfo = NULL;
    qdPartitionAttribute * sSrcPartAttr   = NULL;
    qdPartitionAttribute * sDstPartAttr   = NULL;
    qcmColumn            * sTargetColumn  = NULL;
    qcmColumn            * sTableColumn   = NULL;
    idBool                 sIsDefaultTBS  = ID_FALSE;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    /* 1. ALTER TABLE 구문의 공통적인 Validation를 수행한다.
     *     - Partitioned Table에 LOCK(IS)
     */
    IDE_TEST( validateAlterCommon( aStatement,
                                   ID_FALSE )
              != IDE_SUCCESS );

    sTableInfo = sParseTree->tableInfo;

    /* 2. Partitioned Table인지 검사한다. */
    IDE_TEST_RAISE( sTableInfo->tablePartitionType == QCM_NONE_PARTITIONED_TABLE,
                    ERR_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE );

    /* 3. Src Partition의 설정한다. */
    sSrcPartAttr = sParseTree->partTable->partAttr;

    /* 3.1. Src Partitions을 검사한다. */
    IDE_TEST( qdbCommon::checkPartitionInfo( aStatement,
                                             sTableInfo,
                                             sSrcPartAttr->tablePartName )
              != IDE_SUCCESS );

    sPartitionInfo = sParseTree->partTable->partInfoList->partitionInfo;

    /* 4. Non-Partitioned Index의 리스트를 얻는다. PROJ-1624 */
    IDE_TEST( qdx::makeAndLockIndexTableList( aStatement,
                                              ID_FALSE,
                                              sTableInfo,
                                              &( sParseTree->oldIndexTables ) )
              != IDE_SUCCESS );

    /* 5. Dst Partition의 설정 */
    sDstPartAttr = sSrcPartAttr->next;

    /* 5.1. Dst Partition의 이름을 설정한다. */
    sDstPartAttr->tablePartName = sSrcPartAttr->tablePartName;

    /* 5.2. Dst Partition의 AccessOption을 설정한다. - PROJ-2359 */
    sDstPartAttr->accessOption = sPartitionInfo->accessOption;

    /* 5.3. Dst Partition의 Tablespace를 검사한다. */
    IDE_TEST( qdbCommon::validateTBSOfPartition( aStatement, sDstPartAttr )
              != IDE_SUCCESS );

    /* PROJ-2639 Altibase Disk Edition */
#ifdef ALTI_CFG_EDITION_DISK
    if ( sTableInfo->tableOwnerID == QC_SYSTEM_USER_ID )
    {
        /* Nothing to do */
    }
    else
    {
        IDE_TEST_RAISE( smiTableSpace::isDiskTableSpaceType( sDstPartAttr->TBSAttr.mType ) == ID_FALSE,
                        ERR_NOT_SUPPORT_MEMORY_VOLATILE_TABLESPACE_IN_DISK_EDITION );
    }
#endif

    /* 5.4. Dst Partition의 Tablespace과 Src Partition의 Tablespace가 동일하면 해당작업을 수행할 수 없다. */
    IDE_TEST_RAISE( sPartitionInfo->TBSID == sDstPartAttr->TBSAttr.mID,
                    ERR_UNSUPPORT_ALTER_PARTITION_ON_SAME_TABLESPACE );

    /* 5.5. Dst Partition의 제약조건을 검사한다. */
    IDE_TEST( validateTablespaceRestriction( sTableInfo, sDstPartAttr->TBSAttr.mType )
              != IDE_SUCCESS );

    /* PROJ-2464 hybrid partitioned table 지원 */
    IDE_TEST( qdbCommon::copyAndAdjustColumnList( aStatement,
                                                  sTableInfo->TBSType,
                                                  sDstPartAttr->TBSAttr.mType,
                                                  sTableInfo->columns,
                                                  &(sDstPartAttr->columns),
                                                  sTableInfo->columnCount,
                                                  ID_FALSE /* aEnableVariableColumn */ )
              != IDE_SUCCESS );

    /* 6. Lob Storage의 설정한다. */
    for ( sTableColumn = sPartitionInfo->columns, sTargetColumn = sDstPartAttr->columns;
          sTableColumn != NULL ;
          sTableColumn = sTableColumn->next, sTargetColumn = sTargetColumn->next )
    {
        if ( ( sTableColumn->basicInfo->module->flag & MTD_COLUMN_TYPE_MASK ) == MTD_COLUMN_TYPE_LOB )
        {
            /* Partitioned Table의 Default Lob Storage 지정 여부를 확인한다. */
            IDE_TEST( qcm::getIsDefaultTBS(
                          aStatement,
                          sTableInfo->tableID,
                          sTableColumn->basicInfo->column.id,
                          & sIsDefaultTBS )
                      != IDE_SUCCESS );

            /* Disk Partition의 경우, Partitioned의 Lob Column TBS(Default TBS)가 지정되어 있으면 Default TBS를 사용한다.
             * BUGBUG 이전 Partition도 Disk 매체인 경우, 이전의 Lob Column TBS를 그대로 이용할 수 있는 처리가 필요하다.
             */
            /* PROJ-2465 Tablespace Alteration for Table
             *  - 부족한 Default TBS 처리를 추가한다.
             */
            if ( ( sIsDefaultTBS == ID_TRUE ) &&
                 ( smiTableSpace::isDiskTableSpaceType( sDstPartAttr->TBSAttr.mType ) == ID_TRUE ) &&
                 ( smiTableSpace::isDiskTableSpaceType( sTableInfo->TBSType ) == ID_TRUE ) )
            {
                /* Create시 ColSpace에 설정된 Default TBS를 그대로 이용한다. */
                /* Nothing to do */
            }
            else
            {
                sTargetColumn->basicInfo->column.colSpace = sDstPartAttr->TBSAttr.mID;
            }
        }
        else
        {
            sTargetColumn->basicInfo->column.colSpace = sDstPartAttr->TBSAttr.mID;
        }
    }

    /* 주어진 Lob Attribute를 검사한다. */
    IDE_TEST( qdbCommon::validateLobAttributeList( aStatement,
                                                   sTableInfo,
                                                   sDstPartAttr->columns,
                                                   &( sDstPartAttr->TBSAttr ),
                                                   sDstPartAttr->lobAttr )
              != IDE_SUCCESS );

    /* Src, Dst Partition을 다시 가져온다. */
    sSrcPartAttr = sParseTree->partTable->partAttr;
    sDstPartAttr = sParseTree->partTable->partAttr->next;

    /* 7. ForeienKey 제약을 검사한다. */
    // qdbCommon::getTableTypeCountInPartAttrList()를 사용하기 위해, Src, Dst Partition List를 잠시 분리한다.
    sSrcPartAttr->next = NULL;
    IDE_TEST( validateTableReferenceForPartitions( aStatement,
                                                   sTableInfo,
                                                   sSrcPartAttr,
                                                   sDstPartAttr )
              != IDE_SUCCESS );
    sSrcPartAttr->next = sDstPartAttr;

    /* 8. Index 제약을 검사한다. */
    IDE_TEST( validateIndexAlterationForPartition( aStatement,
                                                   sTableInfo,
                                                   sPartitionInfo,
                                                   sDstPartAttr )
              != IDE_SUCCESS );

    /* 9. Index Partition를 구성한다. */
    IDE_TEST( makeIndexPartAttr( aStatement,
                                 sTableInfo,
                                 sPartitionInfo,
                                 sDstPartAttr )
              != IDE_SUCCESS );

    /* 10. Index Partition를 검사한다. */
    if ( sDstPartAttr->alterPart->indexPartAttr != NULL )
    {
        IDE_TEST( checkIndexPartAttrList( aStatement,
                                          sTableInfo,
                                          sPartitionInfo,
                                          sSrcPartAttr,
                                          sDstPartAttr,
                                          sParseTree->userID )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_CANNOT_ALTER_TABLE_PARTITION_ON_NONE_PART_TABLE ) );
    }
    IDE_EXCEPTION( ERR_UNSUPPORT_ALTER_PARTITION_ON_SAME_TABLESPACE )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_CANNOT_ALTER_PARTITION_ON_SAME_TABLESPACE ) );
    }
#ifdef ALTI_CFG_EDITION_DISK
    IDE_EXCEPTION( ERR_NOT_SUPPORT_MEMORY_VOLATILE_TABLESPACE_IN_DISK_EDITION );
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_USE_ONLY_DISK_TABLE_PARTITION_IN_DISK_EDITION ) );
    }
#endif
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::executeAlterPartition( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *      PROJ-2464 hybrid partitioned table 지원
 *
 *      ALTER TABLE ~ ALTER PARTITION ~ 구문에서 Partition를 지정된 Tablespace로 옮기는 함수이다.
 *
 * Implementation :
 *
 *      1. Src Partition 정보를 구성한다.
 *         1.1. Partitioned와 Partition에 LOCK(IX)를 설정한다.
 *         1.2. Non-Partitioned Index에 LOCK(IX)를 설정한다.
 *         1.3. Src Partition의 정보를 가져온다.
 *
 *      2. PROJ-1442 Replication Online 중 DDL 허용
 *         2.1. Validate와 Execute는 다른 Transaction이므로, 프라퍼티 검사는 Execute에서 한다.
 *         2.2. Replication 제약조건을 확인한다.
 *         2.3. 관련 Receiver Thread 중지
 *
 *      3. Dst Partition을 구성한다.
 *          3.1. Dst Partition을 생성한다.
 *          3.2. SYS_TABLE_PARTITIONS_의 PARTITION_OID를 수정한다.
 *          3.3. SYS_TABLE_PARTITIONS_의 TBS_ID를 수정한다.
 *          3.4. SYS_PART_LOBS_의 TBS_ID를 수정한다.
 *          3.5. SYS_TABLE_의 정보를 수정한다.
 *          3.6. 새로운 PartitionInfo를 생성한다.
 *          3.7. Dst PartInfo를 가져온다.
 *
 *      4. Partition Move를 수행한다.
 *          4.1. Dst가 Disk이면, moveRow를 수행한다.
 *               4.1.1. copyRow를 수행한다.
 *               4.1.2. Src Partition를 삭제한다.
 *               4.1.2. Src Partition의 Index를 삭제한다.
 *          4.2. Dst Partition Index를 생성한다.
 *          4.3. 새로운 PartitionInfo를 생성한다.
 *          4.4. Dst PartInfo를 가져온다.
 *          4.5. Dst가 Memory이면, moveRow를 수행한다.
 *               4.5.1. copyRow를 수행한다.
 *               4.5.2. Src Partition를 삭제한다.
 *
 *      5. PROJ-1442 Replication Online 중 DDL 허용
 *          5.1. SYS_REPL_ITEMS_의 TABLE_OID 컬럼 갱신
 *          5.2. Table Meta Log Record 기록
 *
 *      6. Partition Info를 정리한다.
 *
 ***********************************************************************/

    qdTableParseTree      * sParseTree                = NULL;
    qcmTableInfo          * sTableInfo                = NULL;
    qcmColumn             * sColumn                   = NULL;
    qcmTableInfo          * sSrcPartInfo              = NULL;
    qcmTableInfo          * sDstPartInfo              = NULL;
    qdPartitionAttribute  * sDstPartAttr              = NULL;
    void                  * sDstPartHandle            = NULL;
    smSCN                   sDstPartSCN;
    smOID                   sDstPartOID               = 0;
    smOID                   sSrcPartOID               = 0;
    smiSegAttr              sSegAttr;
    smiSegStorageAttr       sSegStoAttr;
    idBool                  sIsReplicatedTable        = ID_FALSE;
    UInt                    sPartType                 = 0;
    UInt                    i                         = 0;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // BUG-43292 DDL / DDL partiton 연산시 최신 viewSCN을 보지 못함
    IDU_FIT_POINT( "qdbAlter::executeAlterPartition::beforeIXLock" );

    /* 1. Src Partition 정보를 구성한다. */
    /* 1.1. Partitioned(IX)와 Partition(X)에 LOCK를 설정한다. */
    IDE_TEST( qcmPartition::validateAndLockTableAndPartitions( aStatement,
                                                               sParseTree->tableHandle,
                                                               sParseTree->tableSCN,
                                                               sParseTree->partTable->partInfoList,
                                                               SMI_TABLE_LOCK_IX,
                                                               ID_TRUE ) //aIsSetViewSCN
              != IDE_SUCCESS );

    /* 1.2. Non-Partitioned Index에 LOCK(IX)를 설정한다. */
    if ( sParseTree->oldIndexTables != NULL )
    {
        // Index Table을 재생성하지 않고 DML로 처리하므로, IX Lock을 잡는다.
        IDE_TEST( qdx::validateAndLockIndexTableList( aStatement,
                                                      sParseTree->oldIndexTables,
                                                      SMI_TBSLV_DDL_DML,
                                                      SMI_TABLE_LOCK_IX,
                                                      ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                        ID_ULONG_MAX :
                                                        smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    /* 1.3. Src Partition의 정보를 가져온다. */
    sTableInfo   = sParseTree->tableInfo;
    sSrcPartInfo = sParseTree->partTable->partInfoList->partitionInfo;
    sSrcPartOID  = smiGetTableId( sSrcPartInfo->tableHandle );
    sDstPartAttr = sParseTree->partTable->partAttr->next;

    /* 2. PROJ-1442 Replication Online 중 DDL 허용 */
    /* 2.1. Validate와 Execute는 다른 Transaction이므로, 프라퍼티 검사는 Execute에서 한다. */
    if ( sTableInfo->replicationCount > 0 )
    {
        /* 2.2. Replication 제약조건을 확인한다.
         *      - fix BUG-26741 Volatile Table은 이중화 객체가 아님
         */
        IDE_TEST_RAISE( smiTableSpace::isVolatileTableSpaceType( sDstPartAttr->TBSAttr.mType ) == ID_TRUE,
                        ERR_CANNOT_USE_VOLATILE_TABLE );

        IDE_TEST( qci::mManageReplicationCallback.mIsDDLEnableOnReplicatedTable( 0, 
                                                                                 sTableInfo )
                  != IDE_SUCCESS );

        IDE_TEST_RAISE( QC_SMI_STMT(aStatement)->getTrans()->getReplicationMode() == SMI_TRANSACTION_REPL_NONE,
                        ERR_CANNOT_WRITE_REPL_INFO );

        /* 2.3. 관련 Receiver Thread 중지 */
        IDE_TEST( qciMisc::checkRunningEagerReplicationByTableOID( aStatement,
                                                                   &sSrcPartOID,
                                                                   1 )
                  != IDE_SUCCESS );

        // BUG-22703 : Begin Statement를 수행한 후에 Hang이 걸리지 않아야 합니다.
        // mStatistics 통계 정보를 전달 합니다.
        IDE_TEST( qci::mManageReplicationCallback.mStopReceiverThreads(
                                                        QC_SMI_STMT(aStatement),
                                                        aStatement->mStatistics,
                                                        &sSrcPartOID,
                                                        1 )
                  != IDE_SUCCESS );

        sIsReplicatedTable = ID_TRUE;
    }
    else
    {
        /* Nothing to do */
    }

    /* 3. Dst Partition을 구성한다. */
    sDstPartAttr = sParseTree->partTable->partAttr->next;
    sPartType    = qdbCommon::getTableTypeFromTBSID( sDstPartAttr->TBSAttr.mID );

    /* 3.1. Dst Partition을 생성한다.
     *  - Partition Info를 구성할 때에, Table Option을 Partitioned Table의 값으로 복제한다.
     *  - 따라서, PartInfo의 정보를 이용하지 않고, TBSID에 따라 적합한 값으로 조정해서 이용한다.
     */
    qdbCommon::adjustPhysicalAttr( sPartType,
                                   sTableInfo->segAttr,
                                   sTableInfo->segStoAttr,
                                   & sSegAttr,
                                   & sSegStoAttr,
                                   ID_TRUE /* aIsTable */ );

    IDE_TEST( qdbCommon::createTableOnSM( aStatement,
                                          sDstPartAttr->columns,
                                          sTableInfo->tableOwnerID,
                                          sTableInfo->tableID,
                                          sTableInfo->maxrows,
                                          sDstPartAttr->TBSAttr.mID,
                                          sSegAttr,
                                          sSegStoAttr,
                                          /* 원본 Table Flag를
                                             통째로 복사 =>
                                             MASK 비트를 모두 1로설정*/
                                          QDB_TABLE_ATTR_MASK_ALL,
                                          sTableInfo->tableFlag, /* Flag Value */
                                          sTableInfo->parallelDegree,
                                          & sDstPartOID )
              != IDE_SUCCESS );

    /* 3.2. SYS_TABLE_PARTITIONS_의 PARTITION_OID를 수정한다. */
    IDE_TEST( qdbCommon::updatePartTableSpecFromMeta( aStatement,
                                                      sTableInfo->tableID,
                                                      sSrcPartInfo->partitionID,
                                                      sDstPartOID )
              != IDE_SUCCESS );

    /* 3.3. SYS_TABLE_PARTITIONS_의 TBS_ID를 수정한다. */
    IDE_TEST( qdbCommon::updatePartTableTBSFromMeta( aStatement,
                                                     sTableInfo->tableID,
                                                     sSrcPartInfo->partitionID,
                                                     sDstPartAttr->TBSAttr.mID )
              != IDE_SUCCESS );

    /* 3.4. SYS_PART_LOBS_의 TBS_ID를 수정한다. */
    for ( sColumn = sDstPartAttr->columns; sColumn != NULL; sColumn = sColumn->next )
    {
        if ( ( sColumn->basicInfo->module->flag & MTD_COLUMN_TYPE_MASK ) == MTD_COLUMN_TYPE_LOB )
        {
            IDE_TEST( qdbCommon::updatePartLobsTBSFromMeta( aStatement,
                                                            sParseTree->userID,
                                                            sTableInfo->tableID,
                                                            sSrcPartInfo->partitionID,
                                                            sColumn->basicInfo->column.id,
                                                            sColumn->basicInfo->column.colSpace )
                      != IDE_SUCCESS );
        }
        else
        {
            /* Nothing to do */
        }
    }

    /* 3.5. SYS_TABLE_의 정보를 수정한다. - BUG-14394 */
    IDE_TEST( qdbCommon::updateTableSpecFromMeta( aStatement,
                                                  sParseTree->userName,
                                                  sParseTree->tableName,
                                                  sParseTree->tableInfo->tableID,
                                                  smiGetTableId( sParseTree->tableInfo->tableHandle ),
                                                  sParseTree->tableInfo->columnCount,
                                                  sParseTree->tableInfo->parallelDegree )
             != IDE_SUCCESS );

    /* 3.6. 새로운 PartitionInfo를 생성한다. */
    IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo( QC_SMI_STMT( aStatement ),
                                                        sSrcPartInfo->partitionID,
                                                        sDstPartOID,
                                                        sTableInfo,
                                                        NULL )
              != IDE_SUCCESS );

    /* 3.7. Dst PartInfo를 가져온다. */
    IDE_TEST( qcmPartition::getPartitionInfo( aStatement,
                                              sTableInfo->tableID,
                                              sDstPartAttr->tablePartName,
                                              & sDstPartInfo,
                                              & sDstPartSCN,
                                              & sDstPartHandle )
              != IDE_SUCCESS );

    /* 4. Partition Move를 수행한다. */
    /* 4.1. Dst가 Disk이면, moveRow를 수행한다. */
    if ( ( sDstPartInfo->tableFlag & SMI_TABLE_TYPE_MASK ) == SMI_TABLE_DISK )
    {
        /* 4.1.1. copyRow를 수행한다. */
        IDE_TEST( qdbAlter::copyRowForAlterTablespace( aStatement,
                                                       sSrcPartInfo,
                                                       sDstPartInfo,
                                                       sParseTree->oldIndexTables )
                  != IDE_SUCCESS );

        /* 4.1.2. Src Partition를 삭제한다. */
        IDE_TEST( qdd::dropTablePartitionWithoutMeta( aStatement,
                                                      sSrcPartInfo )
                  != IDE_SUCCESS );
    }
    else
    {
        /* 4.1.2. Src Partition의 Index를 삭제한다. */
        for ( i = 0; i < sSrcPartInfo->indexCount; i++ )
        {
            IDE_TEST( qdd::deleteIndexPartitionFromMeta( aStatement,
                                                         sSrcPartInfo->indices[i].indexPartitionID )
                      != IDE_SUCCESS );
        }
    }

    /* 4.2. Dst Partition Index를 생성한다. */
    if ( sTableInfo->indices != NULL )
    {
        IDE_TEST( qdx::createAllIndexOfTablePart( aStatement,
                                                  sTableInfo,
                                                  sDstPartInfo,
                                                  sDstPartAttr->alterPart->indexPartAttr )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    (void)qcmPartition::destroyQcmPartitionInfo( sDstPartInfo );

    sDstPartInfo = NULL;

    /* 4.3. 새로운 PartitionInfo를 생성한다. */
    IDE_TEST( qcmPartition::makeAndSetQcmPartitionInfo( QC_SMI_STMT( aStatement ),
                                                        sSrcPartInfo->partitionID,
                                                        sDstPartOID,
                                                        sTableInfo,
                                                        NULL )
              != IDE_SUCCESS );

    /* 4.4. Dst PartInfo를 가져온다. */
    IDE_TEST( qcmPartition::getPartitionInfo( aStatement,
                                              sTableInfo->tableID,
                                              sDstPartAttr->tablePartName,
                                              & sDstPartInfo,
                                              & sDstPartSCN,
                                              & sDstPartHandle )
              != IDE_SUCCESS );

    /* 4.5. Dst가 Memory이면, moveRow를 수행한다. */
    if ( ( sDstPartInfo->tableFlag & SMI_TABLE_TYPE_MASK ) != SMI_TABLE_DISK )
    {
        /* 4.5.1. copyRow를 수행한다. */
        IDE_TEST( qdbAlter::copyRowForAlterTablespace( aStatement,
                                                       sSrcPartInfo,
                                                       sDstPartInfo,
                                                       sParseTree->oldIndexTables )
                  != IDE_SUCCESS );

        /* 4.5.2. Src Partition를 삭제한다. */
        IDE_TEST( smiTable::dropTable( QC_SMI_STMT( aStatement ),
                                       sSrcPartInfo->tableHandle,
                                       SMI_TBSLV_DDL_DML )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    /* 5. PROJ-1442 Replication Online 중 DDL 허용 */
    /* 5.1. SYS_REPL_ITEMS_의 TABLE_OID 컬럼 갱신 */
    if ( sIsReplicatedTable == ID_TRUE )
    {
        IDE_TEST( qci::mCatalogReplicationCallback.mUpdateReplItemsTableOID( QC_SMI_STMT(aStatement),
                                                                             sSrcPartOID,
                                                                             sDstPartOID )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    /* 5.2. Table Meta Log Record 기록 */
    if ( ( sIsReplicatedTable == ID_TRUE ) ||
         ( QCU_DDL_SUPPLEMENTAL_LOG == 1 ) )
    {
        IDE_TEST( qci::mManageReplicationCallback.mWriteTableMetaLog( aStatement,
                                                                      sSrcPartOID,
                                                                      sDstPartOID )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    /* 6. Partition Info를 정리한다. */
    (void)qcmPartition::destroyQcmPartitionInfo( sSrcPartInfo );

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_CANNOT_USE_VOLATILE_TABLE )
    {
        IDE_SET( ideSetErrorCode( rpERR_ABORT_RPC_CANNOT_USE_VOLATILE_TABLE ) );
    }
    IDE_EXCEPTION( ERR_CANNOT_WRITE_REPL_INFO )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_CANNOT_WRITE_REPL_INFO ) );
    }
    IDE_EXCEPTION_END;

    (void)qcmPartition::destroyQcmPartitionInfo( sDstPartInfo );

    return IDE_FAILURE;
}

IDE_RC qdbAlter::validateAlterTablespace( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *      PROJ-2465 Tablespace Alteration for Table
 *
 *      ALTER TABLE [user_name.]tbl_name ALTER TABLESPACE tbs_name
 *          { INDEX ( index_name TABLESPACE tbs_name, ... ) }
 *          { LOB ( column_name TABLESPACE tbs_name, ... ) }
 *      구문의 Validation
 *
 *      Non-Partitioned Index는 Tablespace 이동을 지원하지 않는다.
 *
 * Implementation :
 *      1. ALTER TABLE 구문의 공통적인 Validation를 수행한다.
 *         - Table Info를 얻고, Table에 IS LOCK
 *
 *      2. Partitioned Table이면, 모든 Partition을 얻는다.
 *         - Partition Info를 얻고, Partition에 IS LOCK
 *
 *      3. Partitioned Table이면, Global Index 리스트를 얻는다.
 *         - Index Table을 얻고, Index Table에 IS LOCK
 *
 *      4. New Table을 설정한다. (Part 1)
 *         - Old Table의 Access Option을 복사한다.
 *         - 사용자가 지정한 Table의 Tablespace Name으로 Tablespace 속성을 얻는다.
 *         - 제약조건을 검사한다.
 *         - Column을 조정한다.
 *             - Non-Partitioned Table이면, 'Fixed(Disk) -> Variable(Memory/Volatile)' Column 자동 변경을 지원한다.
 *
 *      5. New Table을 설정한다. (Part 2)
 *         - Column Space를 설정한다.
 *         - Default LOB Storage 설정을 제거한다.
 *         - LOB Attribute를 검사하고, LOB Column을 설정한다.
 *
 *      6. Non-Partitioned Table이면, Dictionary Table을 검사한다.
 *         - Dictionary Table은 Volatile Tablespace를 지원하지 않는다.
 *         - Dictionary Table이 Replication 대상이면, Alter Tablespace를 지원하지 않는다.
 *
 *      7. Foreign Key 제약을 검사한다.
 *         - Partitioned Table이면,
 *             - Partitioned Table이 Volatile인지 검사한다. (Self, Parent)
 *             - Self로서 Volatile이 아니면, Parent Table은 Volatile이 아니어야 한다.
 *             - Parent로서 Volatile이면, Child Table은 Volatile이어야 한다.
 *
 *         - Non-Partitioned Table이면,
 *             - New Table이 Volatile이 아니면, Parent Table은 Volatile이 아니어야 한다.
 *             - New Table이 Volatile이면, Child Table은 Volatile이어야 한다.
 *
 *      8. Index 제약을 검사한다.
 *         - Partitioned Table이면,
 *             - Global Index가 아니어야 한다.
 *
 *         - Non-Partitioned Table이면,
 *             - Direct Key 옵션이 있으면, 사용자가 지정한 Table의 Tablespace Type이 Memory이어야 한다.
 *
 *         - Old Table의 저장 매체(Memory, Disk)가 New Table의 저장 매체와 다르면,
 *           New Table에 맞는 Key Column을 만들고, Key Size Limit를 검사한다.
 *         - Old Table의 Index에 Persistent 옵션이 있으면, New Table의 Tablespace Type이 Memory이어야 한다.
 *
 *      9. Index를 구성한다.
 *         - Index의 Tablespace를 사용자가 중복 지정했는지 검사한다.
 *         - Index를 기존 값으로 초기화한다.
 *         - 사용자가 지정한 Table의 Tablespace 정보를 복사한다.
 *         - 모든 Index의 Tablespace Name으로 Tablespace 속성을 얻는다.
 *
 ***********************************************************************/

    qdTableParseTree          * sParseTree              = NULL;
    qcmTableInfo              * sTableInfo              = NULL;
    qcmColumn                 * sNewColumn              = NULL;
    qdIndexPartitionAttribute * sIndexTBSAttr           = NULL;
    UInt                        sNewTableType           = SMI_TABLE_DISK;
    idBool                      sExistCompressionColumn = ID_FALSE;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    /* 1. ALTER TABLE 구문의 공통적인 Validation를 수행한다.
     *    - Table Info를 얻고, Table에 IS LOCK
     */
    IDE_TEST( validateAlterCommon( aStatement, ID_FALSE )
              != IDE_SUCCESS );

    sTableInfo = sParseTree->tableInfo;

    /* 2. Partitioned Table이면, 모든 Partition을 얻는다.
     *    - Partition Info를 얻고, Partition에 IS LOCK
     *
     * 3. Partitioned Table이면, Global Index 리스트를 얻는다.
     *    - Index Table을 얻고, Index Table에 IS LOCK
     */
    if ( sTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        /* 파티션 리스트를 파스트리에 달아놓는다. */
        IDE_TEST( qdbCommon::checkAndSetAllPartitionInfo( aStatement,
                                                          sTableInfo->tableID,
                                                          &( sParseTree->partTable->partInfoList ) )
                  != IDE_SUCCESS );

        /* PROJ-1624 non-partitioned index */
        IDE_TEST( qdx::makeAndLockIndexTableList( aStatement,
                                                  ID_FALSE,
                                                  sTableInfo,
                                                  &( sParseTree->oldIndexTables ) )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    /* 4. New Table을 설정한다. (Part 1)
     *    - Old Table의 Access Option을 복사한다.
     *    - 사용자가 지정한 Table의 Tablespace Name으로 Tablespace 속성을 얻는다.
     *    - 제약조건을 검사한다.
     *    - Column을 조정한다.
     *        - Non-Partitioned Table이면, 'Fixed(Disk) -> Variable(Memory/Volatile)' Column 자동 변경을 지원한다.
     */
    sParseTree->accessOption = sTableInfo->accessOption;

    IDE_TEST( qdbCommon::validateTBSOfTable( aStatement )
              != IDE_SUCCESS );

    /* PROJ-2639 Altibase Disk Edition */
#ifdef ALTI_CFG_EDITION_DISK
    if ( ( qcuTemporaryObj::isTemporaryTable( sTableInfo ) == ID_TRUE ) ||
         ( sTableInfo->tableOwnerID == QC_SYSTEM_USER_ID ) )
    {
        /* Nothing to do */
    }
    else
    {
        IDE_TEST_RAISE( smiTableSpace::isDiskTableSpaceType( sParseTree->TBSAttr.mType ) == ID_FALSE,
                        ERR_NOT_SUPPORT_MEMORY_VOLATILE_TABLESPACE_IN_DISK_EDITION );
    }
#endif

    IDE_TEST( validateTablespaceRestriction( sTableInfo, sParseTree->TBSAttr.mType )
              != IDE_SUCCESS );

    if ( sTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST( qdbCommon::copyAndAdjustColumnList( aStatement,
                                                      sTableInfo->TBSType,
                                                      sParseTree->TBSAttr.mType,
                                                      sTableInfo->columns,
                                                      &(sParseTree->columns),
                                                      sTableInfo->columnCount,
                                                      ID_FALSE /* aEnableVariableColumn */ )
                  != IDE_SUCCESS );
    }
    else
    {
        IDE_TEST( qdbCommon::copyAndAdjustColumnList( aStatement,
                                                      sTableInfo->TBSType,
                                                      sParseTree->TBSAttr.mType,
                                                      sTableInfo->columns,
                                                      &(sParseTree->columns),
                                                      sTableInfo->columnCount,
                                                      ID_TRUE /* aEnableVariableColumn */ )
                  != IDE_SUCCESS );
    }

    /* 5. New Table을 설정한다. (Part 2)
     *    - Column Space를 설정한다.
     *    - Default LOB Storage 설정을 제거한다.
     *    - LOB Attribute를 검사하고, LOB Column을 설정한다.
     */
    for ( sNewColumn = sParseTree->columns;
          sNewColumn != NULL;
          sNewColumn = sNewColumn->next )
    {
        sNewColumn->basicInfo->column.colSpace = sParseTree->TBSAttr.mID;

        if ( ( sNewColumn->basicInfo->module->flag & MTD_COLUMN_TYPE_MASK )
                                                  == MTD_COLUMN_TYPE_LOB )
        {
            sNewColumn->flag &= ~QCM_COLUMN_LOB_DEFAULT_TBS_MASK;
            sNewColumn->flag |= QCM_COLUMN_LOB_DEFAULT_TBS_FALSE;
        }
        else
        {
            /* Nothing to do */
        }

        if ( ( sNewColumn->basicInfo->column.flag & SMI_COLUMN_COMPRESSION_MASK )
                                                 == SMI_COLUMN_COMPRESSION_TRUE )
        {
            sExistCompressionColumn = ID_TRUE;
        }
        else
        {
            /* Nothing to do */
        }
    }

    IDE_TEST( qdbCommon::validateLobAttributeList( aStatement,
                                                   sTableInfo,
                                                   sParseTree->columns,
                                                   &( sParseTree->TBSAttr ),
                                                   sParseTree->lobAttr )
              != IDE_SUCCESS );

    /* 6. Non-Partitioned Table이면, Dictionary Table을 검사한다.
     *    - Dictionary Table은 Volatile Tablespace를 지원하지 않는다.
     *    - Dictionary Table이 Replication 대상이면, Alter Tablespace를 지원하지 않는다.
     */
    if ( ( sTableInfo->tablePartitionType == QCM_NONE_PARTITIONED_TABLE ) &&
         ( sExistCompressionColumn == ID_TRUE ) )
    {
        IDE_TEST_RAISE( smiTableSpace::isVolatileTableSpaceType( sParseTree->TBSAttr.mType ) == ID_TRUE,
                        ERR_NOT_SUPPORTED_TABLESPACE_TYPE );

        IDE_TEST_RAISE( sTableInfo->replicationCount > 0, ERR_REORGANIZE_REPL_TABLE );
    }
    else
    {
        /* Nothing to do */
    }

    /* 7. Foreign Key 제약을 검사한다.
     *    - Partitioned Table이면,
     *        - Partitioned Table이 Volatile인지 검사한다. (Self, Parent)
     *        - Self로서 Volatile이 아니면, Parent Table은 Volatile이 아니어야 한다.
     *        - Parent로서 Volatile이면, Child Table은 Volatile이어야 한다.
     *
     *    - Non-Partitioned Table이면,
     *        - New Table이 Volatile이 아니면, Parent Table은 Volatile이 아니어야 한다.
     *        - New Table이 Volatile이면, Child Table은 Volatile이어야 한다.
     */
    sNewTableType = qdbCommon::getTableTypeFromTBSType( sParseTree->TBSAttr.mType );

    IDE_TEST( validateTableReferenceForPartitioned( aStatement,
                                                    sTableInfo,
                                                    sNewTableType )
              != IDE_SUCCESS );

    /* 8. Index 제약을 검사한다.
     *    - Partitioned Table이면,
     *        - Global Index가 아니어야 한다.
     *
     *    - Non-Partitioned Table이면,
     *        - Direct Key 옵션이 있으면, 사용자가 지정한 Table의 Tablespace Type이 Memory이어야 한다.
     *
     *    - Old Table의 저장 매체(Memory, Disk)가 New Table의 저장 매체와 다르면,
     *      New Table에 맞는 Key Column을 만들고, Key Size Limit를 검사한다.
     *    - Old Table의 Index에 Persistent 옵션이 있으면, New Table의 Tablespace Type이 Memory이어야 한다.
     */
    IDE_TEST( validateIndexAlterationForPartitioned( aStatement,
                                                     sTableInfo,
                                                     sParseTree->columns,
                                                     sNewTableType )
              != IDE_SUCCESS );

    /* 9. Index를 구성한다.
     *    - Index의 Tablespace를 사용자가 중복 지정했는지 검사한다.
     *    - Index를 기존 값으로 초기화한다.
     *    - 사용자가 지정한 Table의 Tablespace 정보를 복사한다.
     *    - 모든 Index의 Tablespace Name으로 Tablespace 속성을 얻는다.
     */
    IDE_TEST( makeIndexAttr( aStatement,
                             sTableInfo,
                             sParseTree->TBSName,
                             & (sParseTree->indexTBSAttr) )
              != IDE_SUCCESS );

    for ( sIndexTBSAttr = sParseTree->indexTBSAttr;
          sIndexTBSAttr != NULL;
          sIndexTBSAttr = sIndexTBSAttr->next )
    {
        IDE_TEST( qdtCommon::getAndValidateIndexTBS( aStatement,
                                                     sParseTree->TBSAttr.mID,
                                                     sParseTree->TBSAttr.mType,
                                                     sIndexTBSAttr->TBSName,
                                                     sParseTree->userID,
                                                     & (sIndexTBSAttr->TBSAttr.mID),
                                                     & (sIndexTBSAttr->TBSAttr.mType) )
                  != IDE_SUCCESS );
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_NOT_SUPPORTED_TABLESPACE_TYPE )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_COMPRESSION_NOT_SUPPORTED_TABLESPACE ) );
    }
    IDE_EXCEPTION( ERR_REORGANIZE_REPL_TABLE );
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_CANNOT_ALTER_REORGANIZE_COMPRESSION_COL_WITH_REPLICATED_TBL ) );
    }
#ifdef ALTI_CFG_EDITION_DISK
    IDE_EXCEPTION( ERR_NOT_SUPPORT_MEMORY_VOLATILE_TABLESPACE_IN_DISK_EDITION );
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_USE_ONLY_DISK_TABLE_PARTITION_IN_DISK_EDITION ) );
    }
#endif
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::executeAlterTablespace( qcStatement * aStatement )
{
/***********************************************************************
 *
 * Description :
 *      PROJ-2465 Tablespace Alteration for Table
 *
 *      ALTER TABLE [user_name.]tbl_name ALTER TABLESPACE tbs_name
 *          { INDEX ( index_name TABLESPACE tbs_name, ... ) }
 *          { LOB ( column_name TABLESPACE tbs_name, ... ) }
 *      구문의 Execution
 *
 * Implementation :
 *      1. Lock을 획득한다.
 *         - Partitioned Table이면,
 *             - Partitioned Table과 Table Partition에 LOCK을 잡는다.
 *                 - Partitioned Table에 X LOCK
 *                 - Table Partition에 X LOCK
 *
 *         - Non-Partitioned Table이면,
 *             - Table에 LOCK을 잡는다.
 *                 - Table에 X LOCK
 *
 *      2. Replication 대상 Table인 경우, 제약 조건을 검사한다.
 *         - New Table의 Tablespace Type은 Volatile이 아니어야 한다.
 *         - REPLICATION_DDL_ENABLE 시스템 프라퍼티가 1이어야 한다.
 *         - REPLICATION 세션 프라퍼티가 NONE이 아니어야 한다.
 *
 *         - Non-Partitioned Table이면, Replication 대상 Table인 경우, Receiver Thread를 중지한다.
 *             - 해당 Table 관련 Eager Sender Thread가 없어야 한다.
 *             - 해당 Table 관련 Eager Receiver Thread가 없어야 한다.
 *             - 해당 Table 관련 Receiver Thread를 중지한다.
 *
 *      3. Non-Partitioned Table이면, Dictionary Table을 생성한다.
 *         - Compressed Column List를 만든다.
 *         - Dictionary Table OID Array를 만든다.
 *         - New Dictionary Table을 생성한다.
 *         - Compressed Column List의 Column에 지정한 New Dictionary Table OID를 New Table의 Column에 복사한다.
 *
 *      4. Old Table의 Physical Attributes를 기반으로, New Table의 저장 매체(Memory, Disk)에 맞는 Physical Attributes를 구성한다.
 *         - Segment Attributes
 *         - Segment Storage Attributes
 *
 *      5. New Table을 생성한다. (SM, Meta Table, Meta Cache)
 *         - Old Table의 Table Option을 기반으로, New Table의 저장 매체에 맞는 Table을 생성한다.
 *         - Meta Table을 수정한다.
 *         - New Table Info를 생성하고, SM에 등록한다.
 *         - New Table Info를 얻는다.
 *
 *      6. Non-Partitioned Table이면, New Table이 Disk인 경우
 *         - Old Table의 Row를 New Table에 복사한다.
 *
 *      7. New Table에 Index를 생성한다.
 *         - Old Table의 Index를 기반으로, New Table의 저장 매체(Memory, Disk)에 맞는 Index을 생성한다.
 *         - Meta Table을 수정한다.
 *
 *      8. New Table Info를 갱신한다.
 *         - New Table Info를 제거한다.
 *         - New Table Info를 생성하고, SM에 등록한다.
 *         - New Table Info를 얻는다.
 *
 *         - Partitioned Table이면, New Partition Info를 생성한다.
 *            - New Partition의 Table SCN을 갱신한다.
 *            - New Partition Info를 생성하고, SM에 등록한다.
 *            - New Partition Info를 얻는다.
 *
 *      9. Non-Partitioned Table이면, New Table이 Memory/Volatile인 경우
 *         - Old Table의 Row를 New Table에 복사한다.
 *
 *      10. Non-Partitioned Table이면, Old Dictionary Table의 Row를 New Dictionary Table로 복사한다.
 *         - New Dictionary Table에 Compressed Column 값을 추가하고, New Table의 Compressed Column에 New OID를 갱신한다.
 *         - Meta Table에서 Compressed Column을 갱신한다.
 *
 *      11. Old Table에 smiTable::dropTable()을 수행한다.
 *
 *      12. Non-Partitioned Table이면, Replication 대상 Table인 경우,
 *          Meta Table을 수정하고, 해당 Table의 변경 사항을 Logging한다.
 *          - SYS_REPL_ITEMS_ Meta Table의 TABLE_OID Column을 갱신한다.
 *          - Table Meta Log Record를 기록한다.
 *
 *      13. Non-Partitioned Table이면,
 *          - Old Dictionary Table을 제거한다. (SM, Meta Table)
 *          - Old Dictionary Table Info를 제거한다.
 *
 *      14. Old Table Info를 제거하고,
 *          - Partitioned Table이면, Old Partition Info를 제거한다.
 *
 ***********************************************************************/

    qdTableParseTree      * sParseTree                = NULL;
    qcmTableInfo          * sTableInfo                = NULL;
    qcmTableInfo          * sOldDictionaryTableInfo   = NULL;
    qcmTableInfo         ** sDictionaryTableInfoArr   = NULL;
    qcmDictionaryTable    * sDictionaryTable          = NULL;
    qcmDictionaryTable    * sNewDictionaryTable       = NULL;
    qcmPartitionInfoList  * sOldPartInfoList          = NULL;
    qcmPartitionInfoList  * sNewPartInfoList          = NULL;
    smOID                   sOldTableOID              = SMI_NULL_OID;
    smOID                   sNewTableOID              = SMI_NULL_OID;
    idBool                  sIsReplicatedTable        = ID_FALSE;
    UInt                    sNewTableType             = SMI_TABLE_DISK;
    smiSegAttr              sSegAttr;
    smiSegStorageAttr       sSegStoAttr;
    qcmTableInfo          * sNewTableInfo             = NULL;
    void                  * sNewTableHandle           = NULL;
    smSCN                   sNewSCN;
    qcmColumn             * sCompressedColumnList     = NULL;
    smOID                 * sDictionaryTableOIDArr    = NULL;
    UInt                    sCompressedColumnCount    = 0;
    UInt                    i                         = 0;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    // BUG-43292 DDL / DDL partiton 연산시 최신 viewSCN을 보지 못함
    IDU_FIT_POINT( "qdbAlter::executeAlterTablespace::beforeXLock" );

    /* 1. Lock을 획득한다.
     *    - Partitioned Table이면,
     *        - Partitioned Table과 Table Partition에 LOCK을 잡는다.
     *            - Partitioned Table에 X LOCK
     *            - Table Partition에 X LOCK
     *
     *    - Non-Partitioned Table이면,
     *        - Table에 LOCK을 잡는다.
     *            - Table에 X LOCK
     */
    IDE_TEST( qcm::validateAndLockTable( aStatement,
                                         sParseTree->tableHandle,
                                         sParseTree->tableSCN,
                                         SMI_TABLE_LOCK_X )
              != IDE_SUCCESS );
    
    if ( sParseTree->tableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST( qcmPartition::validateAndLockPartitionInfoList( aStatement,
                                                                  sParseTree->partTable->partInfoList,
                                                                  SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                                  SMI_TABLE_LOCK_X,
                                                                  ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                                    ID_ULONG_MAX :
                                                                    smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );

        // 예외 처리를 위하여, Lock을 잡은 후에 Partition List를 설정한다.
        sOldPartInfoList = sParseTree->partTable->partInfoList;
    }
    else
    {
        /* Nothing to do */
    }
    
    // BUG-43292 DDL / DDL partiton 연산시 최신 viewSCN을 보지 못함
    IDE_TEST( smiStatement::setViewSCNOfAllStmt( QC_SMI_STMT( aStatement ) )
              != IDE_SUCCESS );

    sTableInfo    = sParseTree->tableInfo;
    sOldTableOID  = smiGetTableId( sTableInfo->tableHandle );
    sNewTableType = qdbCommon::getTableTypeFromTBSType( sParseTree->TBSAttr.mType );

    /* 2. Replication 대상 Table인 경우, 제약 조건을 검사한다.
     *    - New Table의 Tablespace Type은 Volatile이 아니어야 한다.
     *    - REPLICATION_DDL_ENABLE 시스템 프라퍼티가 1이어야 한다.
     *    - REPLICATION 세션 프라퍼티가 NONE이 아니어야 한다.
     *
     *    - Non-Partitioned Table이면, Replication 대상 Table인 경우, Receiver Thread를 중지한다.
     *        - 해당 Table 관련 Eager Sender Thread가 없어야 한다.
     *        - 해당 Table 관련 Eager Receiver Thread가 없어야 한다.
     *        - 해당 Table 관련 Receiver Thread를 중지한다.
     */
    if ( sTableInfo->replicationCount > 0 )
    {
        IDE_TEST_RAISE( smiTableSpace::isVolatileTableSpaceType( sParseTree->TBSAttr.mType ) == ID_TRUE,
                        ERR_CANNOT_USE_VOLATILE_TABLE );

        IDE_TEST( qci::mManageReplicationCallback.mIsDDLEnableOnReplicatedTable( 0, 
                                                                                 sTableInfo )
                  != IDE_SUCCESS );

        IDE_TEST_RAISE( QC_SMI_STMT(aStatement)->getTrans()->getReplicationMode() == SMI_TRANSACTION_REPL_NONE,
                        ERR_CANNOT_WRITE_REPL_INFO );

        IDE_TEST( qciMisc::checkRunningEagerReplicationByTableOID( aStatement,
                                                                   &sOldTableOID,
                                                                   1 )
                  != IDE_SUCCESS );

        // BUG-22703 : Begin Statement를 수행한 후에 Hang이 걸리지 않아야 합니다.
        // mStatistics 통계 정보를 전달 합니다.
        IDE_TEST( qci::mManageReplicationCallback.mStopReceiverThreads(
                                                        QC_SMI_STMT(aStatement),
                                                        aStatement->mStatistics,
                                                        &sOldTableOID,
                                                        1 )
                  != IDE_SUCCESS );

        sIsReplicatedTable = ID_TRUE;
    }
    else
    {
        /* Nothing to do */
    }

    /* 3. Non-Partitioned Table이면, Dictionary Table을 생성한다.
     *    - Compressed Column List를 만든다.
     *    - Dictionary Table OID Array를 만든다.
     *    - New Dictionary Table을 생성한다.
     *    - Compressed Column List의 Column에 지정한 New Dictionary Table OID를 New Table의 Column에 복사한다.
     */
    IDE_TEST( recreateDictionaryTableForAlterTablespace( aStatement,
                                                         sTableInfo,
                                                         sParseTree->columns,
                                                         &(sParseTree->TBSAttr),
                                                         &sCompressedColumnList,
                                                         &sCompressedColumnCount,
                                                         &sDictionaryTableOIDArr,
                                                         &sDictionaryTableInfoArr,
                                                         &sNewDictionaryTable )
              != IDE_SUCCESS );

    /* 4. Old Table의 Physical Attributes를 기반으로,
     *    New Table의 저장 매체(Memory, Disk)에 맞는 Physical Attributes를 구성한다.
     *    - Segment Attributes
     *    - Segment Storage Attributes
     */
    qdbCommon::adjustPhysicalAttr( sNewTableType,
                                   sTableInfo->segAttr,
                                   sTableInfo->segStoAttr,
                                   & sSegAttr,
                                   & sSegStoAttr,
                                   ID_TRUE /* aIsTable */ );

    /* 5. New Table을 생성한다. (SM, Meta Table, Meta Cache)
     *    - Old Table의 Table Option을 기반으로, New Table의 저장 매체에 맞는 Table을 생성한다.
     *    - Meta Table을 수정한다.
     *    - New Table Info를 생성하고, SM에 등록한다.
     *    - New Table Info를 얻는다.
     */
    IDE_TEST( qdbCommon::createTableOnSM( aStatement,
                                          sParseTree->columns,
                                          sTableInfo->tableOwnerID,
                                          sTableInfo->tableID,
                                          sTableInfo->maxrows,
                                          sParseTree->TBSAttr.mID,
                                          sSegAttr,
                                          sSegStoAttr,
                                          /* 원본 Table Flag를 통째로 복사 => MASK 비트를 모두 1로 설정 */
                                          QDB_TABLE_ATTR_MASK_ALL,
                                          sTableInfo->tableFlag, /* Flag Value */
                                          sTableInfo->parallelDegree,
                                          & sNewTableOID )
              != IDE_SUCCESS );

    IDE_TEST( qdbCommon::updateTableTBSFromMeta( aStatement,
                                                 sTableInfo->tableID,
                                                 sNewTableOID,
                                                 sParseTree->TBSAttr.mID,
                                                 sParseTree->TBSAttr.mName,
                                                 sSegAttr,
                                                 sSegStoAttr )
              != IDE_SUCCESS );

    IDE_TEST( qdbCommon::updateColumnFlagFromMeta( aStatement,
                                                   sParseTree->columns )
              != IDE_SUCCESS );

    IDE_TEST( qdbCommon::updateLobTBSFromMeta( aStatement,
                                               sParseTree->columns )
              != IDE_SUCCESS );

    IDE_TEST( qcm::makeAndSetQcmTableInfo( QC_SMI_STMT( aStatement ),
                                           sTableInfo->tableID,
                                           sNewTableOID )
              != IDE_SUCCESS );

    IDE_TEST( qcm::getTableInfoByID( aStatement,
                                     sTableInfo->tableID,
                                     & sNewTableInfo,
                                     & sNewSCN,
                                     & sNewTableHandle )
              != IDE_SUCCESS );

    /* 6. Non-Partitioned Table이면, New Table이 Disk인 경우
     *    - Old Table의 Row를 New Table에 복사한다.
     */
    if ( sNewTableType == SMI_TABLE_DISK )
    {
        IDE_TEST( qdbAlter::copyRowForAlterTablespace( aStatement,
                                                       sTableInfo,
                                                       sNewTableInfo,
                                                       NULL )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    /* 7. New Table에 Index를 생성한다.
     *    - Old Table의 Index를 기반으로, New Table의 저장 매체(Memory, Disk)에 맞는 Index을 생성한다.
     *    - Meta Table을 수정한다.
     */
    IDE_TEST( qdx::createAllIndexOfTableForAlterTablespace( aStatement,
                                                            sTableInfo,
                                                            sNewTableInfo,
                                                            sParseTree->indexTBSAttr )
              != IDE_SUCCESS );

    IDE_TEST( qdbCommon::updateIndexTBSFromMeta( aStatement,
                                                 sTableInfo->indices,
                                                 sTableInfo->indexCount,
                                                 sParseTree->indexTBSAttr )
              != IDE_SUCCESS );

    /* 8. New Table Info를 갱신한다.
     *    - New Table Info를 제거한다.
     *    - New Table Info를 생성하고, SM에 등록한다.
     *    - New Table Info를 얻는다.
     *
     *    - Partitioned Table이면, New Partition Info를 생성한다.
     *       - New Partition의 Table SCN을 갱신한다.
     *       - New Partition Info를 생성하고, SM에 등록한다.
     *       - New Partition Info를 얻는다.
     */
    (void)qcm::destroyQcmTableInfo( sNewTableInfo );
    sNewTableInfo = NULL;

    IDE_TEST( qcm::makeAndSetQcmTableInfo( QC_SMI_STMT( aStatement ),
                                           sTableInfo->tableID,
                                           sNewTableOID )
              != IDE_SUCCESS );

    IDE_TEST( qcm::getTableInfoByID( aStatement,
                                     sTableInfo->tableID,
                                     & sNewTableInfo,
                                     & sNewSCN,
                                     & sNewTableHandle )
              != IDE_SUCCESS );

    IDE_TEST( qcmPartition::makeAndSetAndGetQcmPartitionInfoList( aStatement,
                                                                  sNewTableInfo,
                                                                  sOldPartInfoList,
                                                                  & sNewPartInfoList )
              != IDE_SUCCESS );

    /* 9. Non-Partitioned Table이면, New Table이 Memory/Volatile인 경우
     *    - Old Table의 Row를 New Table에 복사한다.
     */
    if ( sNewTableType != SMI_TABLE_DISK )
    {
        IDE_TEST( qdbAlter::copyRowForAlterTablespace( aStatement,
                                                       sTableInfo,
                                                       sNewTableInfo,
                                                       NULL )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    /* 10. Non-Partitioned Table이면, Old Dictionary Table의 Row를 New Dictionary Table로 복사한다.
     *    - New Dictionary Table에 Compressed Column 값을 추가하고, New Table의 Compressed Column에 New OID를 갱신한다.
     *    - Meta Table에서 Compressed Column을 갱신한다.
     */
    if ( sCompressedColumnList != NULL )
    {
        IDE_TEST( qcmDictionary::rebuildDictionaryTable( aStatement,
                                                         sTableInfo,
                                                         sNewTableInfo,
                                                         sNewDictionaryTable )
                  != IDE_SUCCESS );

        for ( sDictionaryTable = sNewDictionaryTable, i = 0;
              sDictionaryTable != NULL;
              sDictionaryTable = sDictionaryTable->next, i++ )
        {
            sOldDictionaryTableInfo = sDictionaryTableInfoArr[i];

            IDE_TEST( qcmDictionary::updateCompressionTableSpecMeta( aStatement,
                                                                     sOldDictionaryTableInfo->tableID,
                                                                     sDictionaryTable->dictionaryTableInfo->tableID )
                      != IDE_SUCCESS );
        }
    }
    else
    {
        /* Nothing to do */
    }

    /* 11. Old Table에 smiTable::dropTable()을 수행한다. */
    IDE_TEST( smiTable::dropTable( QC_SMI_STMT( aStatement ),
                                   sTableInfo->tableHandle,
                                   SMI_TBSLV_DDL_DML )
              != IDE_SUCCESS );

    /* 12. Non-Partitioned Table이면, Replication 대상 Table인 경우,
     *     Meta Table을 수정하고, 해당 Table의 변경 사항을 Logging한다.
     *     - SYS_REPL_ITEMS_ Meta Table의 TABLE_OID Column을 갱신한다.
     *     - Table Meta Log Record를 기록한다.
     */
    if ( sIsReplicatedTable == ID_TRUE )
    {
        IDE_TEST( qci::mCatalogReplicationCallback.mUpdateReplItemsTableOID( QC_SMI_STMT(aStatement),
                                                                             sOldTableOID,
                                                                             sNewTableOID )
                  != IDE_SUCCESS );

        IDE_TEST( qci::mManageReplicationCallback.mWriteTableMetaLog( aStatement,
                                                                      sOldTableOID,
                                                                      sNewTableOID )
                  != IDE_SUCCESS );
    }
    else
    {
        if ( QCU_DDL_SUPPLEMENTAL_LOG == 1 )
        {
            IDE_TEST( qci::mManageReplicationCallback.mWriteTableMetaLog( aStatement,
                                                                          sOldTableOID,
                                                                          sNewTableOID )
                      != IDE_SUCCESS );
        }
        else
        {
            /* Nothing to do */
        }
    }

    /* Touch와 Commit 사이의 간격을 줄이기 위해, Touch를 마지막에 수행한다. */
    IDE_TEST( qcmPartition::touchPartitionInfoList( QC_SMI_STMT( aStatement ),
                                                    sOldPartInfoList )
              != IDE_SUCCESS );

    /* 13. Non-Partitioned Table이면,
     *     - Old Dictionary Table을 제거한다. (SM, Meta Table)
     *     - Old Dictionary Table Info를 제거한다.
     */
    for ( i = 0; i < sCompressedColumnCount; i++ )
    {
        IDE_TEST( qcmDictionary::removeDictionaryTableWithInfo( aStatement,
                                                                sDictionaryTableInfoArr[i] )
                  != IDE_SUCCESS );
    }

    for ( i = 0; i < sCompressedColumnCount; i++ )
    {
        (void)qcm::destroyQcmTableInfo( sDictionaryTableInfoArr[i] );
    }

    /* 14. Old Table Info를 제거하고,
     *     - Partitioned Table이면, Old Partition Info를 제거한다.
     */
    (void)qcmPartition::destroyQcmPartitionInfoList( sOldPartInfoList );
    (void)qcm::destroyQcmTableInfo( sTableInfo );

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_CANNOT_USE_VOLATILE_TABLE )
    {
        IDE_SET( ideSetErrorCode( rpERR_ABORT_RPC_CANNOT_USE_VOLATILE_TABLE ) );
    }
    IDE_EXCEPTION( ERR_CANNOT_WRITE_REPL_INFO )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_CANNOT_WRITE_REPL_INFO ) );
    }
    IDE_EXCEPTION_END;

    (void)qcm::destroyQcmTableInfo( sNewTableInfo );
    (void)qcmPartition::destroyQcmPartitionInfoList( sNewPartInfoList );

    for ( sDictionaryTable = sNewDictionaryTable;
          sDictionaryTable != NULL;
          sDictionaryTable = sDictionaryTable->next )
    {
        (void)qcm::destroyQcmTableInfo( sDictionaryTable->dictionaryTableInfo );
    }

    qcmPartition::restoreTempInfo( sTableInfo,
                                   sOldPartInfoList,
                                   NULL );

    return IDE_FAILURE;
}

IDE_RC qdbAlter::recreateDictionaryTableForAlterTablespace( qcStatement          * aStatement,
                                                            qcmTableInfo         * aTableInfo,
                                                            qcmColumn            * aNewColumns,
                                                            smiTableSpaceAttr    * aNewTBSAttr,
                                                            qcmColumn           ** aCompressedColumnList,
                                                            UInt                 * aCompressedColumnCount,
                                                            smOID               ** aDictionaryTableOIDArr,
                                                            qcmTableInfo       *** aDictionaryTableInfoArr,
                                                            qcmDictionaryTable  ** aDictionaryTable )
{
/***********************************************************************
 *
 * Description :
 *      PROJ-2465 Tablespace Alteration for Table
 *
 *      Tablespace Alteration을 위해, Dictionary Table을 생성한다.
 *
 * Implementation :
 *      1. Compressed Column List를 만든다.
 *      2. Dictionary Table OID Array를 만든다.
 *      3. New Dictionary Table을 생성한다.
 *      4. Compressed Column List의 Column에 지정한 New Dictionary Table OID를 New Table의 Column에 복사한다.
 *
 ***********************************************************************/

    qcmColumn           * sColumn                 = NULL;
    qcmColumn           * sNewColumn              = NULL;
    qcmColumn           * sCompressedColumnList   = NULL;
    smOID               * sDictionaryTableOIDArr  = NULL;
    qcmTableInfo       ** sDictionaryTableInfoArr = NULL;
    qcmDictionaryTable  * sDictionaryTable        = NULL;
    UInt                  sCompressedColumnCount  = 0;
    UInt                  sTableType              = SMI_TABLE_DISK;
    UInt                  sNewTableType           = SMI_TABLE_DISK;
    UInt                  i                       = 0;

    sTableType    = aTableInfo->tableFlag & SMI_TABLE_TYPE_MASK;
    sNewTableType = qdbCommon::getTableTypeFromTBSType( aNewTBSAttr->mType );

    if ( ( sTableType == SMI_TABLE_DISK ) && ( sNewTableType == SMI_TABLE_DISK ) )
    {
        // Dictionary Table을 Default Memory Tablespace에서 Default Memory Tablespace로 이동하는 경우,
        // Compressed Column List에서 제외한다.
        //     Disk Table -> Disk Table
    }
    else
    {
        IDE_TEST( qcm::copyQcmColumns( QC_QMX_MEM(aStatement),
                                       aNewColumns,
                                       & sNewColumn,
                                       aTableInfo->columnCount )
                  != IDE_SUCCESS );

        while ( sNewColumn != NULL )
        {
            if ( ( sNewColumn->basicInfo->column.flag & SMI_COLUMN_COMPRESSION_MASK )
                                                     == SMI_COLUMN_COMPRESSION_TRUE )
            {
                sColumn               = sNewColumn;
                sNewColumn            = sNewColumn->next;

                sColumn->next         = sCompressedColumnList;
                sCompressedColumnList = sColumn;
                sCompressedColumnCount++;
            }
            else
            {
                sNewColumn = sNewColumn->next;
            }
        }

        if ( sCompressedColumnList != NULL )
        {
            IDU_FIT_POINT( "qdbAlter::recreateDictionaryTableForAlterTablespace::alloc::sDictionaryTableOIDArr",
                           idERR_ABORT_InsufficientMemory );

            IDE_TEST( QC_QMX_MEM(aStatement)->alloc( ID_SIZEOF(smOID) * sCompressedColumnCount,
                                                     (void **) & sDictionaryTableOIDArr )
                      != IDE_SUCCESS );

            IDU_FIT_POINT( "qdbAlter::recreateDictionaryTableForAlterTablespace::alloc::sDictionaryTableInfoArr",
                           idERR_ABORT_InsufficientMemory );

            IDE_TEST( QC_QMX_MEM(aStatement)->alloc( ID_SIZEOF(qcmTableInfo *) * sCompressedColumnCount,
                                                     (void **) & sDictionaryTableInfoArr )
                      != IDE_SUCCESS );

            // Compressed Column List와 같은 순서로 Dictionary Table OID Array를 생성한다.
            for ( sColumn = sCompressedColumnList, i = 0;
                  sColumn != NULL;
                  sColumn = sColumn->next, i++ )
            {
                sDictionaryTableOIDArr[i] = sColumn->basicInfo->column.mDictionaryTableOID;

                sDictionaryTableInfoArr[i] = (qcmTableInfo *)smiGetTableRuntimeInfoFromTableOID(
                                                 sDictionaryTableOIDArr[i] );
            }

            IDE_TEST( qcmDictionary::recreateDictionaryTable( aStatement,
                                                              aTableInfo,
                                                              sCompressedColumnList,
                                                              aNewTBSAttr->mID,
                                                              &sDictionaryTable )
                      != IDE_SUCCESS );

            for ( sColumn = sCompressedColumnList;
                  sColumn != NULL;
                  sColumn = sColumn->next )
            {
                sNewColumn = qdbCommon::findColumnInColumnList( aNewColumns,
                                                                sColumn->basicInfo->column.id );

                IDE_TEST_RAISE( sNewColumn == NULL, ERR_COLUMN_NOT_FOUND );

                sNewColumn->basicInfo->column.mDictionaryTableOID =
                        sColumn->basicInfo->column.mDictionaryTableOID;
            }
        }
        else
        {
            /* Nothing to do */
        }
    }

    *aCompressedColumnList   = sCompressedColumnList;
    *aCompressedColumnCount  = sCompressedColumnCount;
    *aDictionaryTableOIDArr  = sDictionaryTableOIDArr;
    *aDictionaryTableInfoArr = sDictionaryTableInfoArr;
    *aDictionaryTable        = sDictionaryTable;

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_COLUMN_NOT_FOUND )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QMC_UNEXPECTED_ERROR,
                                  "qdbAlter::recreateDictionaryTableForAlterTablespace",
                                  "Column Not Found" ) );
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::makeIndexPartAttr( qcStatement           * aStatement,
                                    qcmTableInfo          * aTableInfo,
                                    qcmTableInfo          * aPartInfo,
                                    qdPartitionAttribute  * aDstPartAttr )
{
/***********************************************************************
 *
 * Description :
 *      PROJ-2464 hybrid partitioned table 지원
 *
 *      ALTER TABLE ~ ALTER PARTITION ~ 구문에서 Index Partition Attribute를 구성하는 함수이다.
 *      Tablespace가 변경되기 때문에, 기존의 Index 전부 동일 Tablespace로 변경해야 한다.
 *      따라서, 변경사항으로 주어진 Index Attribute 외에도 모든 Index에 대해서 변경사항을 구성한다.
 *
 * Implementation :
 *      1. 주어진 Index의 중복체크를 수행한다.
 *
 *      2. IndexPartAttr를 위한 동적할당을 수행한다.
 *
 *      3. IndexPartAttr를 기존 정보로 설정한다.
 *         3.1. 기본값으로 초기화한다
 *         3.2. Partition Name은 동일하므로, aDstPartAttr와 같은 위치를 이용하도록 전달해도 된다.
 *         3.3. 기존의 Index Partition Name을 복사한다.
 *         3.4. TBSName와 TBSAttr는 aDstPartAttr의 정보를 기본값으로 설정한다.
 *         3.5. Index Partition Attribute를 연결한다.
 *
 *      4. 주어진 Index Attribute를 반영한다.
 *
 *      5. 구성한 IndexPartAttr를 기존 정보과 교체한다.
 *
 ***********************************************************************/

    qdIndexPartitionAttribute * sIndexPartAttr    = NULL;
    qdIndexPartitionAttribute * sCurIndexPartAttr = NULL;
    qdIndexPartitionAttribute * sDstIndexPartAttr = NULL;
    qcmIndex                  * sPartitionedIndex = NULL;
    qcmIndex                  * sPartitionIndex   = NULL;
    qcuSqlSourceInfo            sqlInfo;
    UInt                        i                 = 0;
    UInt                        j                 = 0;

    IDE_DASSERT( aPartInfo != NULL );
    IDE_DASSERT( aDstPartAttr != NULL );

    /* 1. 주어진 Index의 중복체크를 수행한다. */
    for ( sDstIndexPartAttr  = aDstPartAttr->alterPart->indexPartAttr;
          sDstIndexPartAttr != NULL;
          sDstIndexPartAttr  = sDstIndexPartAttr->next )
    {
        for ( sCurIndexPartAttr  = sDstIndexPartAttr->next;
              sCurIndexPartAttr != NULL;
              sCurIndexPartAttr  = sCurIndexPartAttr->next )
        {
            if ( QC_IS_NAME_MATCHED( sDstIndexPartAttr->partIndexName,
                                     sCurIndexPartAttr->partIndexName )
                 == ID_TRUE )
            {
                sqlInfo.setSourceInfo( aStatement,
                                       & sDstIndexPartAttr->partIndexName );

                IDE_RAISE( ERR_DUPLICATED_PARTITIONED_INDEX );
            }
            else
            {
                /* Nothing to do */
            }
        }
    }

    /* 2. IndexPartAttr를 위한 동적할당을 수행한다. */
    if ( aPartInfo->indexCount > 0 )
    {
        IDU_FIT_POINT( "qdbAlter::makeIndexPartAttr::STRUCT_ALLOC_WITH_COUNT::sIndexPartAttr",
                       idERR_ABORT_InsufficientMemory );

        IDE_TEST( STRUCT_ALLOC_WITH_COUNT( QC_QMP_MEM( aStatement ),
                                           qdIndexPartitionAttribute,
                                           aPartInfo->indexCount,
                                           & sIndexPartAttr )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    /* 3. IndexPartAttr를 기존 정보로 설정한다. */
    for ( i = 0; i < aPartInfo->indexCount; i++ )
    {
        sPartitionIndex = & aPartInfo->indices[i];

        for ( j = 0; j < aTableInfo->indexCount; j++ )
        {
            sPartitionedIndex = & aTableInfo->indices[j];

            if ( sPartitionedIndex->indexId == sPartitionIndex->indexId )
            {
                break;
            }
            else
            {
                /* Nothing to do */
            }
        }

        IDE_TEST_RAISE( j == aTableInfo->indexCount, ERR_NO_EXIST_INDEX );

        /* 3.1. 기본값으로 초기화한다.*/
        sCurIndexPartAttr = & sIndexPartAttr[i];
        QD_SET_INIT_INDEX_PART_ATTR( sCurIndexPartAttr );

        /* 3.2. Partition Name은 동일하므로, aDstPartAttr와 같은 위치를 이용하도록 전달해도 된다. */
        sCurIndexPartAttr->partIndexName.stmtText = sPartitionedIndex->name;
        sCurIndexPartAttr->partIndexName.offset   = 0;
        sCurIndexPartAttr->partIndexName.size     = idlOS::strlen( sPartitionedIndex->name );

        /* 3.3. 기존의 Index Partition Name을 복사한다. */
        sCurIndexPartAttr->indexPartName.stmtText = sPartitionIndex->name;
        sCurIndexPartAttr->indexPartName.offset   = 0;
        sCurIndexPartAttr->indexPartName.size     = idlOS::strlen( sPartitionIndex->name );

        /* 3.4. TBSName와 TBSAttr는 aDstPartAttr의 정보를 기본값으로 설정한다. */
        sCurIndexPartAttr->TBSName = aDstPartAttr->TBSName;
        sCurIndexPartAttr->TBSAttr = aDstPartAttr->TBSAttr;

        /* 3.5. Index Partition Attribute를 연결한다. */
        if ( ( i + 1 ) < aPartInfo->indexCount )
        {
            sCurIndexPartAttr->next = & sIndexPartAttr[i + 1];
        }
        else
        {
            sCurIndexPartAttr->next = NULL;
        }
    }

    /* 4. 주어진 Index Attribute를 반영한다. */
    IDE_TEST( changeIndexAttr( aStatement,
                               aDstPartAttr->alterPart->indexPartAttr,
                               sIndexPartAttr )
              != IDE_SUCCESS );

    /* 5. 구성한 IndexPartAttr를 기존 정보과 교체한다. */
    aDstPartAttr->alterPart->indexPartAttr = sIndexPartAttr;

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_DUPLICATED_PARTITIONED_INDEX );
    {
        (void)sqlInfo.init( aStatement->qmeMem );
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_DUP_PARTITIONED_INDEX_NAME,
                                  sqlInfo.getErrMessage()) );
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION( ERR_NO_EXIST_INDEX )
    {
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QMC_UNEXPECTED_ERROR,
                                  "qdbAlter::makeIndexPartAttr",
                                  "No exist index" ) );
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::makeIndexAttr( qcStatement                * aStatement,
                                qcmTableInfo               * aTableInfo,
                                qcNamePosition               aTableTBSName,
                                qdIndexPartitionAttribute ** aUserDefinedIndexTBSAttr )
{
/***********************************************************************
 *
 * Description :
 *      PROJ-2465 Tablespace Alteration for Table
 *
 *      ALTER TABLE ~ ALTER TABLESPACE ~ 구문에서 Index TBS Attribute를 구성하는 함수이다.
 *      Table의 Tablespace가 변경되기 때문에, 사용자가 지정하지 않은 Index의 Tablespace도 변경한다.
 *
 * Implementation :
 *      1. 사용자가 지정한 Index Name의 중복 검사를 수행한다.
 *
 *      2. 모든 Index TBS Attribute를 동적으로 할당한다.
 *
 *      3. Index TBS Attribute를 Table 정보로 초기화한다.
 *
 *      4. 사용자가 지정한 Index TBS Attribute를 반영한다.
 *
 *      5. 새로 구성한 Index TBS Attribute를 기존의 것과 교체한다.
 *
 ***********************************************************************/

    qdIndexPartitionAttribute * sAllIndexTBSAttr         = NULL;
    qdIndexPartitionAttribute * sUserDefinedIndexTBSAttr = NULL;
    qdIndexPartitionAttribute * sCurIndexTBSAttr         = NULL;
    qcmIndex                  * sIndex                   = NULL;
    qcuSqlSourceInfo            sqlInfo;
    UInt                        i                        = 0;

    /* 1. 사용자가 지정한 Index Name의 중복 검사를 수행한다. */
    for ( sUserDefinedIndexTBSAttr  = *aUserDefinedIndexTBSAttr;
          sUserDefinedIndexTBSAttr != NULL;
          sUserDefinedIndexTBSAttr  = sUserDefinedIndexTBSAttr->next )
    {
        for ( sCurIndexTBSAttr  = sUserDefinedIndexTBSAttr->next;
              sCurIndexTBSAttr != NULL;
              sCurIndexTBSAttr  = sCurIndexTBSAttr->next )
        {
            if ( QC_IS_NAME_MATCHED( sUserDefinedIndexTBSAttr->partIndexName,
                                     sCurIndexTBSAttr->partIndexName )
                 == ID_TRUE )
            {
                sqlInfo.setSourceInfo( aStatement,
                                       & sUserDefinedIndexTBSAttr->partIndexName );

                IDE_RAISE( ERR_DUPLICATED_PARTITIONED_INDEX );
            }
            else
            {
                /* Nothing to do */
            }
        }
    }

    /* 2. 모든 Index TBS Attribute를 동적으로 할당한다. */
    if ( aTableInfo->indexCount > 0 )
    {
        IDU_FIT_POINT( "qdbAlter::makeIndexAttr::STRUCT_ALLOC_WITH_COUNT::sAllIndexTBSAttr",
                       idERR_ABORT_InsufficientMemory );

        IDE_TEST( STRUCT_ALLOC_WITH_COUNT( QC_QMP_MEM( aStatement ),
                                           qdIndexPartitionAttribute,
                                           aTableInfo->indexCount,
                                           & sAllIndexTBSAttr )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    /* 3. Index TBS Attribute를 Table 정보로 초기화한다. */
    for ( i = 0; i < aTableInfo->indexCount; i++ )
    {
        sIndex = & aTableInfo->indices[i];

        sCurIndexTBSAttr = & sAllIndexTBSAttr[i];
        QD_SET_INIT_INDEX_PART_ATTR( sCurIndexTBSAttr );

        sCurIndexTBSAttr->partIndexName.stmtText = sIndex->name;
        sCurIndexTBSAttr->partIndexName.offset   = 0;
        sCurIndexTBSAttr->partIndexName.size     = idlOS::strlen( sIndex->name );

        sCurIndexTBSAttr->TBSName = aTableTBSName;

        if ( ( i + 1 ) < aTableInfo->indexCount )
        {
            sCurIndexTBSAttr->next = & sAllIndexTBSAttr[i + 1];
        }
        else
        {
            sCurIndexTBSAttr->next = NULL;
        }
    }

    /* 4. 사용자가 지정한 Index Attribute를 반영한다. */
    IDE_TEST( changeIndexAttr( aStatement,
                               *aUserDefinedIndexTBSAttr,
                               sAllIndexTBSAttr )
              != IDE_SUCCESS );

    /* 5. 새로 구성한 Index TBS Attribute를 기존의 것과 교체한다. */
    *aUserDefinedIndexTBSAttr = sAllIndexTBSAttr;

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_DUPLICATED_PARTITIONED_INDEX );
    {
        (void)sqlInfo.init( aStatement->qmeMem );
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_DUP_PARTITIONED_INDEX_NAME,
                                  sqlInfo.getErrMessage() ) );
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::changeIndexAttr( qcStatement               * aStatement,
                                  qdIndexPartitionAttribute * aUserDefinedIndexTBSAttr,
                                  qdIndexPartitionAttribute * aAllIndexTBSAttr )
{
/***********************************************************************
 *
 * Description :
 *      PROJ-2464 hybrid partitioned table 지원
 *
 *      사용자가 정의한 Index TBS Name을 전체 Index TBS Attr에 반영한다.
 *
 * Implementation :
 *
 ***********************************************************************/

    qdIndexPartitionAttribute * sUserDefinedIndexTBSAttr = NULL;
    qdIndexPartitionAttribute * sAllIndexTBSAttr         = NULL;
    qcuSqlSourceInfo            sqlInfo;
    idBool                      sIsFound;

    for ( sUserDefinedIndexTBSAttr  = aUserDefinedIndexTBSAttr;
          sUserDefinedIndexTBSAttr != NULL;
          sUserDefinedIndexTBSAttr  = sUserDefinedIndexTBSAttr->next )
    {
        sIsFound = ID_FALSE;

        for ( sAllIndexTBSAttr  = aAllIndexTBSAttr;
              sAllIndexTBSAttr != NULL;
              sAllIndexTBSAttr  = sAllIndexTBSAttr->next )
        {
            if ( idlOS::strMatch( sUserDefinedIndexTBSAttr->partIndexName.stmtText +
                                  sUserDefinedIndexTBSAttr->partIndexName.offset,
                                  sUserDefinedIndexTBSAttr->partIndexName.size,
                                  sAllIndexTBSAttr->partIndexName.stmtText +
                                  sAllIndexTBSAttr->partIndexName.offset,
                                  sAllIndexTBSAttr->partIndexName.size ) == 0 )
            {
                sAllIndexTBSAttr->TBSName = sUserDefinedIndexTBSAttr->TBSName;
                sIsFound = ID_TRUE;

                break;
            }
            else
            {
                /* Nothing to do */
            }
        }

        if ( sIsFound == ID_FALSE )
        {
            sqlInfo.setSourceInfo( aStatement,
                                   & sUserDefinedIndexTBSAttr->partIndexName );

            IDE_RAISE( ERR_NOT_EXIST_INDEX );
        }
        else
        {
            /* Nothing to do */
        }
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION( ERR_NOT_EXIST_INDEX );
    {
        (void)sqlInfo.init( aStatement->qmeMem );
        IDE_SET( ideSetErrorCode( qpERR_ABORT_QDB_NOT_EXIST_INDEX,
                                  sqlInfo.getErrMessage() ) );
        (void)sqlInfo.fini();
    }
    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::copyRowForAlterTablespace( qcStatement      * aStatement,
                                            qcmTableInfo     * aSrcTableInfo,
                                            qcmTableInfo     * aDstTableInfo,
                                            qdIndexTableList * aIndexTables )
{
/***********************************************************************
 *
 * Description :
 *      PROJ-2464 hybrid partitioned table 지원
 *
 *      Tablespace를 변경하기 위해, Row를 복사한다.
 *      Non-Partitioned Index는 UPDATE로 처리한다. 즉, Non-Partitioned Index의 Tablespace를 변경하지 않는다.
 *
 * Implementation :
 *       1. copyRow를 위한 환경설정을 한다.
 *          1.1. lob-locator를 저장할 공간을 할당한다.
 *          1.2. sCursorProperty를 위한 환경설정을 한다.
 *               1.2.1. Fetch Column List를 구성한다.
 *               1.2.2. Record Read를 위한 공간을 할당한다.
 *               1.2.3. Disk-variable 컬럼의 rid비교를 위해 초기화한다.
 *          1.3. newRow를 저장할 공간을 할당한다.
 *          1.4. Index Table Cursors를 초기화한다.
 *
 *       2. SrcTblCursor를 구성한다.
 *          2.1. SrcTblCursor를 초기화한다.
 *          2.2. sSrcCursorProperty를 설정한다.
 *          2.3. SrcTblCursor를 연다.
 *
 *       3. DstTblCursor를 구성한다.
 *          3.1. DstTblCursor를 초기화한다.
 *          3.2. sCursorProperty를 설정한다.
 *
 *       4. copyRow를 수행한다.
 *          4.1. Memory 재사용을 위하여 현재 위치 기록한다.
 *          4.2. Insert를 위해서 적합한 Row 형태로 생성한다.
 *          4.3. Insert를 수행한다.
 *          4.4. Lob Column를 처리한다.
 *          4.5. Non-Partitioned Index를 처리한다.
 *
 *       5. 작업을 종료한다.
 *          5.1. Table Cursor를 닫는다.
 *          5.2. Index Table Cursor를 닫는다.
 *
 ***********************************************************************/

    qdTableParseTree    * sParseTree        = NULL;
    qdIndexTableCursors   sIndexTableCursorInfo;
    qmxLobInfo          * sLobInfo          = NULL;
    const void          * sOldRow           = NULL;
    smiValue            * sNewRow           = NULL;
    void                * sInsRow           = NULL;
    smiCursorProperties   sSrcCursorProperty;
    smiCursorProperties   sDstCursorProperty;
    smiTableCursor        sSrcTblCursor;
    smiTableCursor        sDstTblCursor;
    smiFetchColumnList  * sFetchColumnList  = NULL;
    iduMemoryStatus       sQmxMemStatus;
    smOID                 sPartOID          = smiGetTableId( aDstTableInfo->tableHandle );
    scGRID                sGRID;
    scGRID                sInsGRID;
    idBool                sInitedCursorInfo = ID_FALSE;
    UInt                  sRowSize          = 0;
    SInt                  sStage            = 0;

    qdbAnalyzeUsage     * sAnalyzeUsage     = NULL;
    ULong                 sProgressCnt      = 0;

    sParseTree = (qdTableParseTree *)aStatement->myPlan->parseTree;

    /* 1. copyRow를 위한 환경설정을 한다. */
    /* 1.1. lob-locator를 저장할 공간을 할당한다. */
    IDE_TEST( qmx::initializeLobInfo( aStatement,
                                      & sLobInfo,
                                      (UShort)sParseTree->tableInfo->lobColumnCount )
              != IDE_SUCCESS );

    /* 1.2. sCursorProperty를 위한 환경설정을 한다. */
    if ( ( aSrcTableInfo->tableFlag & SMI_TABLE_TYPE_MASK ) == SMI_TABLE_DISK )
    {
        /* 1.2.1. Fetch Column List를 구성한다. -PROJ-1705  */
        IDE_TEST( qdbCommon::makeFetchColumnList( QC_PRIVATE_TMPLATE( aStatement ),
                                                  aSrcTableInfo->columnCount,
                                                  aSrcTableInfo->columns,
                                                  ID_TRUE,
                                                  & sFetchColumnList )
                  != IDE_SUCCESS );

        /* 1.2.2. Record Read를 위한 공간을 할당한다. */
        IDE_TEST( qdbCommon::getDiskRowSize( aSrcTableInfo->tableHandle,
                                             & sRowSize )
                  != IDE_SUCCESS );

        /* 1.2.3. Disk-variable 컬럼의 rid비교를 위해 초기화한다. - BUG-14820 */
        IDU_FIT_POINT( "qdbAlter::copyRowForAlterTablespace::cralloc::sOldRow",
                       idERR_ABORT_InsufficientMemory );

        IDE_TEST( aStatement->qmxMem->cralloc( sRowSize,
                                               (void **) & sOldRow )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    /* 1.3. newRow를 저장할 공간을 할당한다. */
    IDU_FIT_POINT( "qdbAlter::copyRowForAlterTablespace::alloc::sNewRow",
                   idERR_ABORT_InsufficientMemory );

    IDE_TEST( aStatement->qmxMem->alloc( ID_SIZEOF( smiValue ) * aDstTableInfo->columnCount,
                                         (void **) & sNewRow )
              != IDE_SUCCESS );

    /* 1.4. Index Table Cursors를 초기화한다. */
    if ( aIndexTables != NULL )
    {
        IDE_TEST( qdx::initializeUpdateIndexTableCursors( aStatement,
                                                          aIndexTables,
                                                          & sIndexTableCursorInfo )
                  != IDE_SUCCESS );

        sInitedCursorInfo = ID_TRUE;
    }
    else
    {
        // Nothing to do.
    }

    /* 2. SrcTblCursor를 구성한다. */
    /* 2.1. SrcTblCursor를 초기화한다. */
    sSrcTblCursor.initialize();

    /* 2.2. sSrcCursorProperty를 설정한다. */
    SMI_CURSOR_PROP_INIT_FOR_FULL_SCAN( &sSrcCursorProperty, aStatement->mStatistics );

    sSrcCursorProperty.mLockWaitMicroSec = 0;
    sSrcCursorProperty.mIsUndoLogging    = ID_FALSE;
    sSrcCursorProperty.mFetchColumnList  = sFetchColumnList;

    /* 2.3. SrcTblCursor를 연다. */
    IDE_TEST( sSrcTblCursor.open( QC_SMI_STMT( aStatement ),
                                  aSrcTableInfo->tableHandle,
                                  NULL,
                                  smiGetRowSCN( aSrcTableInfo->tableHandle ),
                                  NULL,
                                  smiGetDefaultKeyRange(),
                                  smiGetDefaultKeyRange(),
                                  smiGetDefaultFilter(),
                                  SMI_LOCK_READ|
                                  SMI_TRAVERSE_FORWARD|
                                  SMI_PREVIOUS_DISABLE,
                                  SMI_SELECT_CURSOR,
                                  & sSrcCursorProperty )
              != IDE_SUCCESS );

    sStage = 1;

    /* 3. DstTblCursor를 구성한다. */
    /* 3.1. DstTblCursor를 초기화한다. */
    sDstTblCursor.initialize();

    /* 3.2. sCursorProperty를 설정한다. */
    SMI_CURSOR_PROP_INIT_FOR_FULL_SCAN( &sDstCursorProperty, aStatement->mStatistics );

    sDstCursorProperty.mLockWaitMicroSec = 0;
    sDstCursorProperty.mIsUndoLogging    = ID_FALSE;

    /* 3.3. DstTblCursor를 연다. */
    IDE_TEST( sDstTblCursor.open( QC_SMI_STMT( aStatement ),
                                  aDstTableInfo->tableHandle,
                                  NULL,
                                  smiGetRowSCN( aDstTableInfo->tableHandle ),
                                  NULL,
                                  smiGetDefaultKeyRange(),
                                  smiGetDefaultKeyRange(),
                                  smiGetDefaultFilter(),
                                  SMI_LOCK_WRITE|
                                  SMI_TRAVERSE_FORWARD|
                                  SMI_PREVIOUS_DISABLE,
                                  SMI_INSERT_CURSOR,
                                  & sDstCursorProperty )
              != IDE_SUCCESS );

    sStage = 2;

    /* 4. copyRow를 수행한다. */
    IDE_TEST( sSrcTblCursor.beforeFirst() != IDE_SUCCESS );

    IDE_TEST( sSrcTblCursor.readRow( & sOldRow,
                                     & sGRID,
                                     SMI_FIND_NEXT )
              != IDE_SUCCESS );

    /* PROJ-2465 Tablespace Alteration for Table */
    IDE_TEST( qdbCommon::initializeAnalyzeUsage( aStatement,
                                                 aSrcTableInfo,
                                                 aDstTableInfo,
                                                 &( sAnalyzeUsage ) )
              != IDE_SUCCESS );

    while ( sOldRow != NULL )
    {
        /* PROJ-2465 Tablespace Alteration for Table */
        IDE_TEST( qdbCommon::checkAndSetAnalyzeUsage( aStatement,
                                                      sAnalyzeUsage )
                  != IDE_SUCCESS );

        /* 4.1. Memory 재사용을 위하여 현재 위치 기록한다. - To Fix PR-11704 */
        IDE_TEST( aStatement->qmxMem->getStatus( & sQmxMemStatus )
                  != IDE_SUCCESS );

        (void)qmx::clearLobInfo( sLobInfo );

        /* 4.2. Insert를 위해서 적합한 Row 형태로 생성한다.
         *      - 2번 파라메터 aTableInfo와 11번 파라메터 aConvertContextList는 사용하지 않는다.
         *      - echar->char, char->echar 등의 변환이 발생할 때, 두 파라메터를 이용한다.
         */
        IDE_TEST( qdbAlter::makeNewRow( QC_PRIVATE_TMPLATE( aStatement ),
                                        NULL,
                                        aSrcTableInfo->columns,
                                        aDstTableInfo->columns,
                                        sOldRow,
                                        sNewRow,
                                        & sSrcTblCursor,
                                        sGRID,
                                        sLobInfo,
                                        NULL )
                  != IDE_SUCCESS );

        /* 4.3. Insert를 수행한다. */
        IDE_TEST( sDstTblCursor.insertRow( sNewRow,
                                           & sInsRow,
                                           & sInsGRID)
                  != IDE_SUCCESS );

        /* 4.4. Lob Column를 처리한다. */
        IDE_TEST( qmx::copyAndOutBindLobInfo( aStatement,
                                              sLobInfo,
                                              & sDstTblCursor,
                                              sInsRow,
                                              sInsGRID )
                      != IDE_SUCCESS );

        /* 4.5. Non-Partitioned Index를 처리한다. */
        if ( aIndexTables != NULL )
        {
            IDE_TEST( qdx::updateIndexTableCursors( aStatement,
                                                    & sIndexTableCursorInfo,
                                                    sPartOID,
                                                    sGRID,
                                                    sInsGRID )
                      != IDE_SUCCESS );
        }
        else
        {
            /* Nothing to do */
        }

        // BUG-42920 DDL print data move progress
        IDE_TEST( qdbAlter::printProgressLog4Partition( sParseTree->tableInfo,
                                                        aSrcTableInfo,
                                                        &sProgressCnt,
                                                        ID_FALSE )
                  != IDE_SUCCESS );

        IDE_TEST( aStatement->qmxMem->setStatus( &sQmxMemStatus )
                  != IDE_SUCCESS );


        IDE_TEST( sSrcTblCursor.readRow( &sOldRow, &sGRID, SMI_FIND_NEXT )
                      != IDE_SUCCESS );
    }

    // BUG-42920 DDL print data move progress
    IDE_TEST( qdbAlter::printProgressLog4Partition( sParseTree->tableInfo,
                                                    aSrcTableInfo,
                                                    &sProgressCnt,
                                                    ID_TRUE )
              != IDE_SUCCESS );

    IDU_FIT_POINT( "qdbAlter::copyRowForAlterTablespace::close::sDstTblCursor",
                   idERR_ABORT_InsufficientMemory );

    /* 5. 작업을 종료한다. */
    /* 5.1. Table Cursor를 닫는다. */
    sStage = 1;

    IDE_TEST( sDstTblCursor.close() != IDE_SUCCESS );

    sStage = 0;

    IDE_TEST( sSrcTblCursor.close() != IDE_SUCCESS );

    /* 5.2. Index Table Cursor를 닫는다. */
    if ( aIndexTables != NULL )
    {
        IDE_TEST( qdx::closeUpdateIndexTableCursors( &sIndexTableCursorInfo )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    switch ( sStage )
    {
        case 2:
            sDstTblCursor.close();
        case 1:
            sSrcTblCursor.close();
        case 0:
            break;
        default:
            break;
    }

    if ( sInitedCursorInfo == ID_TRUE )
    {
        qdx::finalizeUpdateIndexTableCursors( & sIndexTableCursorInfo );
    }
    else
    {
        /* Nothing to do */
    }

    (void)qmx::finalizeLobInfo( aStatement, sLobInfo );

    return IDE_FAILURE;
}

IDE_RC qdbAlter::validateTouchTable(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... TOUCH 의 validation 수행
 *
 * Implementation :
 *    1. validateAlterCommon 호출
 *
 ***********************************************************************/

    // ALTER TABLE 구문의 공통적인 validation 수행
    // => 테이블에 LOCK(IS)
    return validateAlterCommon( aStatement, ID_FALSE );
}

IDE_RC qdbAlter::executeTouchTable(qcStatement * aStatement)
{
/***********************************************************************
 *
 * Description :
 *    ALTER TABLE ... TOUCH 의 execute 수행
 *
 * Implementation :
 *    1. Table에 대한 Lock을 획득
 *    2. touchTable 수행
 *
 ***********************************************************************/

    qdTableParseTree     * sParseTree       = (qdTableParseTree *)aStatement->myPlan->parseTree;
    qcmPartitionInfoList * sOldPartInfoList = NULL;
    qcmTableInfo         * sOldTableInfo    = NULL;

    // Table에 대한 Lock을 획득한다.
    IDE_TEST( qcm::validateAndLockTable( aStatement,
                                         sParseTree->tableHandle,
                                         sParseTree->tableSCN,
                                         SMI_TABLE_LOCK_X )
              != IDE_SUCCESS);

    sOldTableInfo    = sParseTree->tableInfo;

    if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST( qcmPartition::getPartitionInfoList( aStatement,
                                                      QC_SMI_STMT( aStatement ),
                                                      QC_QMX_MEM( aStatement ),
                                                      sOldTableInfo->tableID,
                                                      & sOldPartInfoList )
                  != IDE_SUCCESS );

        IDE_TEST( qcmPartition::validateAndLockPartitionInfoList( aStatement,
                                                                  sOldPartInfoList,
                                                                  SMI_TBSLV_DDL_DML, // TBS Validation 옵션
                                                                  SMI_TABLE_LOCK_X,
                                                                  ( ( smiGetDDLLockTimeOut() == -1 ) ?
                                                                    ID_ULONG_MAX :
                                                                    smiGetDDLLockTimeOut() * 1000000 ) )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    IDE_TEST(qcm::touchTable( QC_SMI_STMT( aStatement ),
                              sOldTableInfo->tableID,
                              SMI_TBSLV_DDL_DML )
             != IDE_SUCCESS);

    if ( sOldTableInfo->tablePartitionType == QCM_PARTITIONED_TABLE )
    {
        IDE_TEST( qcmPartition::touchPartitionInfoList( QC_SMI_STMT( aStatement ),
                                                        sOldPartInfoList )
                  != IDE_SUCCESS );
    }
    else
    {
        /* Nothing to do */
    }

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    return IDE_FAILURE;
}

IDE_RC qdbAlter::recreateIndexForReorganize( qcStatement       * aStatement,     /* in  */
                                             qdTableParseTree  * aParseTree,     /* in  */
                                             smOID               aNewTableOID,   /* in  */
                                             qcmTableInfo     ** aNewTableInfo ) /* out */
{
/***********************************************************************
 *
 * Description :
 *    BUG-44230 ADD, DROP, MODIFY, REORGANIZE DDL의 INDEX, CONSTRAINT 생성 순서 변경
 *     - REORGANIZE COL을 위한 Recreate Index
 *
 * Implementation :
 *
 *    1. 새로운 Index 정보 구축을 위한 공간 할당
 *    2. Meta에서 기존 column spec 삭제
 *    3. 새로운 table에 constraint 재 생성
 *    4. 새로운 table에 index 재 생성
 *    5. 연관된 VIEW Invalidate
 *    6. Meta Cache( Table Header에 저장된 qcmTableInfo ) 재구성
 *    7. not null constraint 생성
 *    8. Meta Cache( Table Header에 저장된 qcmTableInfo ) 재구성
 *    9. 새로운 tableinfo 반환
 *
 ************************************************************************/

    UInt           sTableID;
    qcmTableInfo * sOldTableInfo  = NULL;
    qcmTableInfo * sNewTableInfo  = NULL;
    qcmIndex     * sNewTableIndex = NULL;
    void         * sNewTableHandle = NULL;
    smSCN          sSCN;
    UInt           i;

    sTableID      = aParseTree->tableInfo->tableID;
    sOldTableInfo = aParseTree->tableInfo;

    /* 1. 새로운 Index 정보 구축을 위한 공간 할당 */
    if ( sOldTableInfo->indexCount > 0 )
    {
        IDU_FIT_POINT( "qdbAlter::recreateIndexForReorganize::alloc::sNewTableIndex",
                        idERR_ABORT_InsufficientMemory );
        IDE_TEST( aStatement->qmxMem->alloc( ID_SIZEOF( qcmIndex ) * sOldTableInfo->indexCount,
                                             (void**)& sNewTableIndex )
                  != IDE_SUCCESS );

        idlOS::memcpy( sNewTableIndex,
                       sOldTableInfo->indices,
                       ID_SIZEOF( qcmIndex ) * sOldTableInfo->indexCount );
    }
    else
    {
        /* Nothing to do */
    }

    /* 2. Meta에서 기존 column spec 삭제 */
    IDE_TEST( qdd::deleteConstraintsFromMeta( aStatement, sTableID )
              != IDE_SUCCESS );

    IDE_TEST( deleteIndexSpecFromMeta( aStatement, sTableID )
              != IDE_SUCCESS );

    /* 3. 새로운 table에 constraint 재 생성 */
    IDE_TEST( qdbCommon::createConstraintFromInfo( aStatement,
                                                   sOldTableInfo,
                                                   aNewTableOID,
                                                   0,    /* aPartitionCount,    */
                                                   NULL, /* sNewPartitionOID,   */
                                                   SMI_INDEX_BUILD_UNCOMMITTED_ROW_ENABLE,
                                                   sNewTableIndex,
                                                   NULL, /* sNewPartIndex,      */
                                                   0,    /* sNewPartIndexCount, */
                                                   aParseTree->oldIndexTables,
                                                   &( aParseTree->newIndexTables ),
                                                   NULL )
              != IDE_SUCCESS );

    /* 4. 새로운 table에 index 재 생성 */
    IDE_TEST( qdbCommon::createIndexFromInfo( aStatement,
                                              sOldTableInfo,
                                              aNewTableOID,
                                              0,    /* aPartitionCount,    */
                                              NULL, /* sNewPartitionOID,   */
                                              SMI_INDEX_BUILD_UNCOMMITTED_ROW_ENABLE,
                                              sNewTableIndex,
                                              NULL, /* sNewPartIndex,      */
                                              0,    /* sNewPartIndexCount, */
                                              aParseTree->oldIndexTables,
                                              &( aParseTree->newIndexTables ),
                                              NULL,
                                              ID_TRUE )
              != IDE_SUCCESS );

    /* 5. 연관된 VIEW Invalidate */
    IDE_TEST( qcmView::setInvalidViewOfRelated( aStatement,
                                                aParseTree->userID,
                                                sOldTableInfo->name,
                                                idlOS::strlen( (SChar*)sOldTableInfo->name ),
                                                QS_TABLE )
              != IDE_SUCCESS );

    /* 6. Meta Cache( Table Header에 저장된 qcmTableInfo ) 재구성 */
    IDE_TEST( qcm::makeAndSetQcmTableInfo( QC_SMI_STMT( aStatement ),
                                           sTableID,
                                           aNewTableOID )
              != IDE_SUCCESS );

    IDE_TEST( qcm::getTableInfoByID( aStatement,
                                     sTableID,
                                     & sNewTableInfo,
                                     & sSCN,
                                     & sNewTableHandle )
             != IDE_SUCCESS );

    IDE_TEST( qcm::validateAndLockTable( aStatement,
                                         sNewTableHandle,
                                         sSCN,
                                         SMI_TABLE_LOCK_X )
              != IDE_SUCCESS );

    /* 7. not null constraint 생성 */
    if ( sNewTableInfo->primaryKey != NULL )
    {
        for ( i = 0;
              i < sNewTableInfo->primaryKey->keyColCount;
              i++ )
        {
            IDE_TEST( qdbCommon::makeColumnNotNull( aStatement,
                                                    sNewTableHandle,
                                                    sNewTableInfo->maxrows,
                                                    NULL,     /* sNewPartInfoList, */
                                                    ID_FALSE, /* aIsPartitioned,   */
                                                    sNewTableInfo->primaryKey->keyColumns[i].column.id )
                      != IDE_SUCCESS );
        }
    }

    /* 8. Meta Cache( Table Header에 저장된 qcmTableInfo ) 재구성 */
    (void)qcm::destroyQcmTableInfo( sNewTableInfo );

    sNewTableInfo = NULL;

    IDE_TEST( qcm::makeAndSetQcmTableInfo( QC_SMI_STMT( aStatement ),
                                           sTableID,
                                           aNewTableOID )
              != IDE_SUCCESS );

    IDE_TEST( qcm::getTableInfoByID( aStatement,
                                     sTableID,
                                     & sNewTableInfo,
                                     & sSCN,
                                     & sNewTableHandle )
              != IDE_SUCCESS );

    IDE_TEST( qcm::validateAndLockTable( aStatement,
                                         sNewTableHandle,
                                         sSCN,
                                         SMI_TABLE_LOCK_X )
              != IDE_SUCCESS );

    /* 9. 새로운 tableinfo 반환 */
    *aNewTableInfo = sNewTableInfo;

    return IDE_SUCCESS;

    IDE_EXCEPTION_END;

    /* cleanup new table info */
    (void)qcm::destroyQcmTableInfo( sNewTableInfo );

    return IDE_FAILURE;
}
